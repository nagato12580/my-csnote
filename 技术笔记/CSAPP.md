# 第一章 计算机系统概述

**hello.c程序**  ^3db0f6
```c
#include<stdio.h>
int main()
{
	printf("hello,world\n");
	return 0;
}
```

## 1. .c文件
1. **.c**程序是以字节序列的方式存储在文件中的，称为文本文件。
> 例如：hello.c![[Pasted image 20221211232419.png]]

2. 基本思想：
	系统中所有的信息一一包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。


## 2. 程序执行的四个阶段

![[Pasted image 20221211232758.png]]
**目标文件helloo这个翻译过程可分为四个阶段完成，如上图所示。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilationsystem)。**

### 2.1预处理阶段：解析头文件，修改源程序
预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如**hello.c**中第1行的#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插人程序文本中。结果就得到了另一个C程序**hello.i**，通常是以.i作为文件扩展名。


### 2. 2 编译阶段：也就是把ASCII码组成的文本文件翻译成汇编语言。
编译器（ccl)将文本文件**hello.i**翻译成文本文件**hello.s**，它包含一个汇编语言程序。该程序包含函数main的定义，如下所示：
![[Pasted image 20221212111824.png]]


### 2.3 汇编阶段：将汇编语言的文件转化为二进制机器码
汇编器（as）将**hello.s**翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatableobjectprogram)的格式，并将结果保存在目标文件**hello.o**中。**hello.o**文件是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开**hello.o**文件，将看到一堆乱码。 ^8c7b28

### 2.4 连接阶段：
链接阶段。请注意，**hello.c**程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器(ld）就负责处理这种合并。结果就得到hello文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。

## 3.了解编译系统工作的益处

* **优化程序性能**
>一个swich语句是否总是比一系列的if-else语句高效得多？
>一个函数调用的开销有多大？
>while循环比for循环更有效吗？
>指针引用比数组索引更有效吗？
>为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？
>为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快？
 
* **理解连接时出现的错误**
>链接器报告说它无法解析一个引用，这是什么意思？
>静态变量和全局变量的区别是什么？
>如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？
>静态库和动态库的区别是什么？
>我们在命令行上排列库的顺序有什么影响？
>为什么有些链接错误直到运行时才会出现？

* **避免安全漏洞**
	避免安全漏洞。多年来，缓冲区溢出错误是造成大多数网络和lnternet服务器上安漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。

## 4. 处理器读取并解释内存中的指令

### 4.1 shell是什么
shell是一个命令行解释器，它输出一个提示符，等待输人一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell将加载并运行hello程序，然后等待程序终止。hello程序在屏幕上输出它的消息，然后终止。shell随后输出一个提示符，等待下一个输人的命令行。

### 4.2 系统的硬件组成

==典型的系统硬件组成==
![[Pasted image 20221212125440.png]]

#### 4.2.1 总线
**总线：** 贯穿整个系统的是一组电子管道。

>总线携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节（64位）


#### 4.2.2 I/O设备
**I/O（输人/输出）设备：** 是系统与外部世界的联系通道。

> 每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。

#### 4.2.3 主存
**主存：** 主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从**物理**上来说，主存是由一组**动态随机存取存储器(DRAM）** 芯片组成的。从**逻辑**上来说，存储器是一个**线性的字节数组**，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。

#### 4.2.4 处理器
**处理器：** **中央处理单元（CPU）**，简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。


### 4.3 运行hello程序
1. shell程序执行执行，等待键盘输入一个命令。*./hello* shell程序将祝福注意读入寄存器，再把它存放到内存中。
![[Pasted image 20221212130552.png]]
2. 输入结束后，shell执行指令加载可执行hello文件。这些指令将hello.c目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello，worrld\n” .

>利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。如下图所示：
![[Pasted image 20221212131550.png]]

3. hello目标代码和数据加载到主存之后，处理器开始执行hello程序中的main程序中的及其语言指令。这些指令将"hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。
![[Pasted image 20221212131847.png]]
## 5. 高速缓存的重要性

**根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。**

处理器处理速度和主存读取速度不匹配，处理器处理速度块，主存读取速度慢，造成处理器需要等待主存读取的局面。

为了**解决处理器与主存之间的差异**，引入了**高速缓存存储器(Cache)**，作为展示的集结区域，存放处理器近期可能需要的数据。

>例子：
>![[Pasted image 20221212132618.png]]

## 6. 存储器设备的层次结构
![[Pasted image 20221212132813.png]]
在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或记为L0。这里我们展示的是三层高速缓存L1到L3，占据存储器层次结构的第1层到第3层。主存在第4层，以此类推。

**存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。**
> 寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。


## 7. 操作系统管理硬件

**程序依靠操作系统提供的服务。** 我们可以把操作系统看成是应用程序和硬件之间插人的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。
![[Pasted image 20221212133123.png]]

#### 7. 1 操作系统的基本功能

**操作系统有两个基本功能：**
（1）防止硬件被失控的应用程序滥用；
（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。
操作系统通过几个基本的抽象概念（[[#7. 2 进程]]、虚拟内存和文件）来实现这两个功能。

#### 7. 2 进程

==进程是操作系统对一个正在运行的程序的一种抽象。==每个进程都好像在独占地使用硬件。

##### 7.2.1 进程的并发运行
一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数。

##### 7.2.2 上下文切换
**操作系统实现这种进程交错执行的机制称为上下文切换。操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容等。**

当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。
![[Pasted image 20221212134135.png]]

#### 7. 2 线程
在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

#### 7. 3 虚拟内存

##### 7.3.1 虚拟地址空间

虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为**虚拟地址空间。**

![[Pasted image 20221212134605.png]]

在**Linux**中，地址空间**最上面的区域**是保留给**操作系统中的代码和数据**的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。**上图中的地址是从下往上增大的**。

##### 7.3.2 虚拟地址空间各区功能

**从最低的地址开始，逐步向上。**
1. **程序代码和数据。** 对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。
2. **堆。** 代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，**堆可以在运行时动态地扩展和收缩。**
3. **栈。** 位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，**每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。**
4.  **内核虚拟地址。** 内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

#### 7. 4 文件
**文件就是字节序列，** 仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输人输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。

## 8. 系统之间的网络通信

现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个I/O设备，如图所示。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。
![[Pasted image 20221212135627.png]]

## 9. 重要主题
### 9.1 Amdahl定律
该定律思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为
T<sub>old</sub>。假设系统某部分所需执行时间与该时间的比例为α，而该部分性能提升比例为k。即该部分初始所需时间为αT<sub>old</sub> 现在所需时间为(αT<sub>old</sub>)/k。
因此，总的执行时间应为
![[Pasted image 20221212140216.png]]

![[Pasted image 20221212140225.png]]
![[Pasted image 20221212140327.png]]

#### 9.2 并发和并行

驱动进步的持续动力：
1. 我们想要计算机做得更多
2. 我们想要计算机运行得更快。

**并发：** 指一个同时具有多个活动得系统
**并行：** 指**用并发**来使一个系统运行得更快。==并行可以再计算机系统得多个抽象层次上使用。==

### 9.2.1 线程级并发
这种并发形式允许多个用户同时与系统交互。
>例如，当许多人想要从一个服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启web浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为单处理器系统。

* **多核处理器：** 多核处理器是将多个CPU(称为“核”）集成到一个集成电路芯片上。
![[Pasted image 20221212141404.png]]

* **超线程：** 有时称为同时多线程(simultaneousmulti-threading)，是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。
	>常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。举例来说，lntelCorei7处理器可以让每个核执行两个线程，所以一个4核的系统实际上可以并行地执行8个线程。

**多处理器得使用从两方面提高系统性能：**
1. 减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。
2. 可以使得多线程方式的应用程序运行得更快。

### 9.2.2 指令级并行

在较低的抽象层次上，现代处理器可以**同时执行多条指令**的属性称为指令级并行。

**流水线技术：** 在流水线中，将执行一条指令所需要的**活动划分成不同的步骤**，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些**阶段**可以**并行**地操作，用来处理不同指令的不同部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一个时钟周期一条指令的执行速率。

**好标量处理器：** 处理器可以达到比一个周期一条指令更快的执行速率，称之为超标量处理器，大多数现代处理器偶支持超标量操作。


### 9.2.3 单指令、多数据并行

**单指令、多数据并行：** 在最低层次上，许多现代处理器拥有特殊的硬件，允许**一条指令产生多个可以并行执行的操作**，这种方式称为单指令、多数据，即**SIMD并行**。例如，较新几代的lntel和AMD处理器都具有并行地对8对单精度浮点数（C数据类型flooat）做加法的指令。

### 9.3 计算机系统中抽象的重要性

**抽象的使用是计算机科学中最为重要的概念之一。**

#### 9.3.1 三个抽象
* 文件：文件是对I/O设备的抽象
* 虚拟内存：虚拟内存是对程序存储器的抽象
* 进程：进程是对一个正在运行的程序的抽象。

#### 9.3.2 虚拟机
**虚拟机提供整个计算机的抽象，包括操作系统、处理器和程序。**

![[Pasted image 20221212142733.png]]



# 第二章 信息的处理和表示

## 2.1 信息存储

### 名词解释

#### 字节 

大多数计算机使用8位的块，或者**字节**，作为**最小的寻址单元**，而不是访问内存中单独的位。

#### 虚拟内存

机器及程序将内存视为一个非常大的字节数组，称为虚拟内存。

#### 虚拟地址

内存中每个字节都由一个唯一的数值来标识，称为字节的地址。

#### 虚拟地址空间
所有可能的字节地址的集合就成为虚拟地址空间。

>**指针** 是C语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，**指针也有两个方面：值和类型。** 它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。

### 十六进制表示法

十六进制（简写为"hex”）使用数字'0，'9，以及字符'A，'F，来表示16个可能的值。

在C语言中，以0x或0×开头的数字常量被认为是十六进制的值。

#### 二进制转十六进制

==每4位一组来转换为十六进制。==
不过要注意，如果位总数不是4的倍数，最左边的一组可以少于4位，前面用0补足。然后将每个4位组转换为相应的十六进制数字：
![[Pasted image 20221213152712.png]]

>当值是2的非负整数次幂时，也就是x=2”，我们可以很容易地将x写成十六进制形式，只要记住的二进制表示就是1后面跟”个0。十六进制数字0代表个二进制0。所以，当“表示成一4j的形式，其中0<i<3，我们可以把工写成开头的十六进制数字为1(i=0）、2(i=1)、4(i=2）或者8(i=3），后面跟随着丿个十六进制的0。
>
>2<sup>n</sup> 转换为二进制为最高位为1，其后n个0，如下图：
>![[Pasted image 20221213153113.png]]
>因为二进制的四位标识16进制的一位，于是我们可以计算n是由多少个四位组成，即n=4*j+i* ，余数*i*标识不足4位的高位的0的个数(i<4)。
>于是，有j个二进制四位一组的0，可以转换为有j和十六进制0。i个高位0，通过最高位0前面补充1，若不足4位高位补充0，构成四位一组，从而转换为十六进制。
>2048=2<sup>11</sup>=2<sup>3+4*2</sup> ，其中一共有2个四位一组的0，转换为16进制00，高位余下三个0，补充为四位后变成：1000，转换为十六进制8。
>于是2048的十六进制为：0x800

#### 十进制转十六进制

利用**辗转相除法**
![[Pasted image 20221213154409.png]]

#### 十六进制进制转十进制
![[Pasted image 20221213154505.png]]



### 字

每台计算机都有一个字长指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是[[#7.3.1 虚拟地址空间|虚地址空间]]的最大大小。也就是说，对于一个字长为w位的机器而言，虚拟地址的范围为0～2<sup>w</sup> -1程序最多访问2<sup>w</sup>个字节。

一个虚地址对应一个字节
32位字长的机器，虚拟地址空间为2<sup>32</sup>B=4* *2<sup>30</sup>B=4GB。最多可以访问4千兆个字节。


程序称为“32位程序”或“64位程序”时，**区别在于该程序是如何编译的**，而不是其运行的机器类型。大多数64位的机器可以运行32位机器编译的程序。

int和long可以提供各种数据大小。即使是为64位系统编译，数据类型**int通常也只有4个字节**。数据类型long一般在32位程序中为4字节，在64位程序中则为8字节。
![[Pasted image 20221213162008.png]]
程序员应该用有符号字符的声明来保证其为一个字节的有符号数值。不过，在很多情况下，程序行为对数据类型char是有符号的还是无符号的并不敏感。

C语言标准对不同数据类型的数字范围设置了下界（这点在后面还将讲到），但是却没有上界。


### 字、字节、虚拟地址的关联

计算机中最小的单位是位，一位可以是0或者1，8位组成一个字节。
[[#字]]数据是由几个[[#字节]]组成的用来标识字节的地址，即[[#虚拟地址]] 。


### 寻址和字节顺序

### 对象的地址

多字节对象被存储位**连续的字节序列**，对象的地址为所使用的**字节中最小的地址。**
>假设一个int的变量x地址为0x000，即&x=0x000，int对象的四个字节被存储在0x000、0x001、0x002、0x003.

### 字节顺序
考虑一个位的整数，其位表示为[x<sub>w
-1</sub>,x<sub>w
-2</sub>, ……，，x<sub>1</sub> ，x<sub>0</sub>]，]w是8的倍数，这些位能被分割为字节，最高有效字节包含前八个位，其前为最高有效位，最低有效字节包含最后八个字节，称为最低有效位。

假设变量x的类型为int，位于地址0x1佣处，它的十六进制值0x01234567。地范围0x100～0x103的字节顺序依赖于机器的类型：

==一个字节是8位，一个十六进制数包含四位，则一个字节可以保存两个16进制数==。
>字节是最小的寻址单元



#### 小端法
最低有效字节存储在前面
![[Pasted image 20221213171150.png]]

大多数Intel兼容机都只用小端模式。
==Android和ISO只能运行于小端模式== 

#### 大端法
最高有效字节存储在最前面
![[Pasted image 20221213171144.png]]

IBM和Oracle的大多数则是按照大端模式操作。

### 字节顺序的重要性

1. 是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，**字里的字节成了反序** 。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。
2. 当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在检查机器级程序时。小端法生成的机器级程序，字节序列是最低位字节在左边，最高位字节在右边（小端法），则正好与通常数学数字时最高有效位在左边，最低有效位在右边的方式相反。
3. 当编写规避正常的类型系统的程序时。在C语言中，可以通过使用**强制类型转换**（cast）或联合（union）来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。
	*每个数据类型所占的字节数不同，当进行强制类型转换之后，一个变量的类型改变，那么存储该变量的字节数可能也会会改变，于是标识该数据的地址长度也会改变。 *
![[Pasted image 20221214194600.png]]
>参数12345的十六进制表示为0x00003039。对于int类型的数据，除了字节顺序以外，我们在所有机器上都得到相同的结果。特别地，我们可以看到在Linux32、Windows和Linux64上，最低有效字节值0x39最先输出，这说明它们是小端法机器；而在Sun上最后输出，这说明Sun是大端法机器。同样地，float数据的字节，除了字节顺序以外，也都是相同的。另一方面，指针值却是完全不同的。不同的机器/操作系统配置使用不同的存储分配规则。一个值得注意的特性是Linux32、Windows和Sun的机器使用4字节地址，而Linux64使用8字节地址。

> 书P31图2-4的小思考 
> ![[Pasted image 20221214195622.png]]
> byte_point接收的是一个字节序列的地址，len是长度。
> 比如在win操作系统中，int占4字节，将一个int数据的首地址传入，len应该为4，因为**字节是最小的寻址单元** ，该int类型一共占四个地址，show_bytes函数中遍历该int的地址，每次取出一个字节地址，一个字节占8位，而4位表示一个16进制数，所以一个字节里面保存的是两个16进制数，假设传入数字是12345，十六进制为00003039，一共4个十六进制数，保存在两个字节中，于是如果是[[#大端法]]，则会打印 00 00 30 39，如果是[[#小端法]]则打印39 30 00 00

^show


> **反汇编器：** 是一种确定可执行程序文件所表示的指令序列的工具。


#### 小小例题
![[Pasted image 20221214200837.png]]![[Pasted image 20221214200844.png]]
+ *分析：* 根据[[#^show|show_bytes]]函数分析，打印结果是以字节为单位的十六进制数。
+ **解答：** 
	+ 首先两个十六进制数占用一个字节，如果调用是show_bytes(valps,4)。那么输出结果是。
		+ 小端法：12345678
		+ 大端法：87654321
	- show_bytes(valps,1)。那么输出结果是。
		+ 小端法：12
		+ 大端法：87
	- show_bytes(valps,2)。那么输出结果是。
		+ 小端法：1234
		+ 大端法：8765
	- show_bytes(valps,3)。那么输出结果是。
		+ 小端法：123456
		+ 大端法：876543


### 字符串表示

C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是**ASCII字符码**。因此，如果我们以参数“12345”和6

>_ASCII编码范围0x00-0x7F_,即十进制的0-127,定义了128个单字节字符。
*ASCII码可以用一个字节表示（一个字节范围0-255），因此一个char用ASCII码存储在一个字节中*


>如果我们以参数“12345”和6调用[[#^show|show_bytes]]函数，则将输出每一个字符对应的_ASCII码，每一个ASCII码输出为十六进制为：
>31 32 33 34 35

#### 例题

![[Pasted image 20221214203631.png]]

**解答：** 调用[[#^show|show_bytes]]函数:
该字符串对应的ASCII码依次是61 62 63 64 65 66
转换为十六进制表示为：3d 3e 3f 40 41 42

>UTF-8表示将每个字符编码为一个字节序列，这样标准ASCII字符还是使用和它们在ASCII中一样的单字节编码，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。


### 代码表示

```c++
int sum(int x,int y){
	return x+y;
}
```
![[Pasted image 20221214204303.png]]

**产生原因：**
不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有**不同的编码规则**，因此**二进制代码是不兼容的**。二进制代码很少能在不同机器和操作系统组合之间移植。

### 布尔代数

#### 布尔运算

![[Pasted image 20221214204519.png]]

#### 位向量的运算

**二进制数之间每一位进行运算**

![[Pasted image 20221214204649.png]]

>**布尔运算&、|之间遵循分配律**
>a&(b|c)=(a&b)|(a&c)
>a|(b&c)=(a|b)&(a|c)


#### C语言中的移位运算

|       操作       | 值1      | 值2      |
|:----------------:| -------- | -------- |
|      参数x       | 01100011 | 10010101 |
|   x << 4(左移)   | 00110000 | 01010000 |
| x >> 4(逻辑右移) | 00000110 | 00001001 |
| x >> 4(算数右移) | 00000110 | 11111001 |

- 左移动：每一位向左移动，丢弃最高位，末尾补零
- 右移动： ^b16ae3
	- **逻辑右移**：每一位向左移动，丢弃最低位，**高位补0**. ^bebe94
	- **算术右移**：每一位向左移动。
		- 最高位是0：丢弃最高位，高位补0.
		- *最高位是1*：丢弃最低位，**高位补1**.

>实际上，几乎所有的编译器/机器组合都对**有符号数**使用**算术右移**，程序员也都假设机器会使用这种右移。另一方面，对于**无符号数**，采用**逻辑右移**。


## 整形数据表示

- 32位
![[Pasted image 20221214211514.png]]

- 64位
![[Pasted image 20221214211538.png]]

> c&c++都支持有符号数和无符号数，而java只支持有符号数

>long 的长度与机器字长相关，64位占8字节，32位占4字节。

### 有符号数和无符号的编码方式
[九曲阑干CSAPP](https://www.bilibili.com/video/BV1ba4y1E7qy)


#### 无符号数编码

[计算机对无符号数进行编码的方式](https://www.bilibili.com/video/BV1ba4y1E7qy#t=63.548379)



![[Pasted image 20221216142312.png]]

[图形化表示方法：](https://www.bilibili.com/video/BV1ba4y1E7qy#t=145.788479)
![[Pasted image 20221216142444.png]]


#### 无符号数编码

[无符号数的编码](https://www.bilibili.com/video/BV1ba4y1E7qy#t=193.296038)

**补码形式**
![[Pasted image 20221216142553.png]]
**最高位表示负权重，在转换为十进制时需要添加正负号**[03:47](https://www.bilibili.com/video/BV1ba4y1E7qy#t=227.856537)

![[Pasted image 20221216142711.png]]

**图形化表示方法：** [04:10](https://www.bilibili.com/video/BV1ba4y1E7qy#t=250.996739)

![[Pasted image 20221216142850.png]]

**当最高位为0时，对十进制结果没有影响，当最高位为1时，转换为十进制结果一定是负数。**
>有符号数1111转换为十进制结果为-1，有符号数0111转换为十进制结果为7.所以对于四位的有符号数，表示十进制的范围为-8~7.


#### 不同字长表示的有/无符号数的范围

*无符号数最小值均为0*
##### 无符号数
![[Pasted image 20221216151422.png]]

##### 有符号数
**最大值**
![[Pasted image 20221216151504.png]]

**最小值**
![[Pasted image 20221216151555.png]]
**符号位为1，其余均为0**
>因为只有最高位（符号位）表示负权重，其余位都是正权重，如果其他位有1将使得数据变大。


###### 有符号数-1（负1）
![[Pasted image 20221216151738.png]]
**不论字长为多少位，-1有符号数表示方式全为1.**
>类比8位有符号数，最高位负权重是-2<sup>8</sup>=-256 ,其他各位权重之和等于255，之和就是-1


#### 例子：12345和-12345

[12345和-12345与53191的编码](https://www.bilibili.com/video/BV1ba4y1E7qy#t=403.023527)
![[Pasted image 20221216154542.png]]
**结论：-12345是12345的补码**
>原码：十进制数对应的二进制
>正数的原码补码反码均相同。
>对于负数：反码是原码除去符号位的按位取反，补码是反码+1
>移码是在补码的基础上，符号数取反。

**由图中可以看出，-12345的补码是对12345的原码进行取反之后+1**
**补码是用于表示原码的负数。**


### 有符号数和无符号数的转换

C语言允许在各种不同的数字数据类型之间做强制[[CPP#类型转换|类型转换]]。

```c++
short int a=-12345;
usigned short b = (unsigned short)a;
printf("a=%d,b=%u",a,b)
//输出结果为：-12345，53191
```

**-12345和53191的位模式不变，但是解释方式改变导致变成不同的十进制值**
>-12345：1100 1111 1100 0111
>53191：1100 1111 1100 0111

**对于大多数C语言的实现，有符号数和无符号数之间的转换的规则是：位模式不变，但是解释这些位的方式改变了**

**相同位模式下，无符号数和有符号数映射成十进制的联系:**
>B2T：位模式转换为无符号数
>B2T：位模式转换为有符号数
>T2U：有符号数转换为无符号数
>U2T：无符号数转换为有符号数

#### 有符号数转化为无符号数
![[Pasted image 20221216155355.png]]
	**结论：（上图式子移项得到）**
	![[Pasted image 20221216155509.png]]

**有符号数到无符号数的函数映射T2U：** 假设x为一个有符号数
![[Pasted image 20221216160325.png]] ^79d93f
**当x>0时，x<sub>w-1</sub>=1，x<0时，x<sub>w-1</sub>=1，等价于下面公式** ^7beffc
$$
T2U_m(x)=x+x_{w-1}*2^w
$$
- 当最高位x<sub>w-1</sub>=1,该有符号数x 表示一个负数 即，x<0
- 当最高位x<sub>w-1</sub>=0,该有符号数x表示一个正数 即，x>=0

#### 无符号数转化为有符号数
**无符号数到有符号数的函数映射U2T：** 假设u是一个无符号数
![[Pasted image 20221216160917.png]]
>当无符号数u最高位为0时，表示的最大数值与有符号数最大数相等，即与有符号数的正数相等。
>当无符号数最高位为1时，无符号数可以表示的数值大于有符号数的最大值

**在C/C++中如果一个运算包含有符号数和无符号数，那么有符号数会被强制转换为无符号数进行运算。**

#### 有符号数转换无符号数的转换例子

![[Pasted image 20221216161202.png]]

**原因分析：有符号数和无符号数比较时，有符号数a强制转换成无符号数，即[[#有符号数转化为无符号数]]，等于-1+2<sup>32</sup>**


#### 有符号数和无符号数转换成更大的数据类型

##### 无符号数转换成更大的数据类型

**零扩展：** 最高位补零。

##### 有符号数转换成更大的数据类型

进行**符号位扩展** 。需要分两种情况。
- 当有符号数为**正数**，最高位为0时，与无符号数一样在**高位补0**即可。
- 当有符号数为**负数**，最高位为1时，与无符号数相反在**高位补1**即可。
	>高位补1之后与原数相等，利用数学归纳法证明之。证明过程如下。

**数学归纳法证明过程：**
**基本思想：证明拓展了一位，即补1个1 之后与原数保持不变，即可以证明补k位之后也与原数保持不变。** 以扩展1位为例子：
![[Pasted image 20221216162854.png]]

**证明：B2T<sub>w+1</sub>=等于=B2T<sub>w+1</sub>** 。（相减）
![[Pasted image 20221216163110.png]]

**结论：负数的有符号数高位补1之后，与原数数值相等。**


#### 有符号数和无符号数转换成更小的数据类型

##### 无符号数转换成更小的数据类型

**采取截断操作，舍弃高位，保留地位，会改变数值。相当于取模操作** ^003fc0

>类比十进制的截断（取模）操作。
>对于123456，取456，相当于截取后三位，也就是对123456%10<sup>3</sup>=123

**结论：十进制截取后k位，则模10<sup>k</sup>，二进制截取后k位，则模2<sup>k</sup>.**



##### 有符号数转换成更小的数据类型

书中表达式：
![[Pasted image 20221216163708.png]]
![[Pasted image 20221216163744.png]]


**保留最低k位的步骤：**
1. 使用无符号数的函数映射来解释有符号数底层的二进制位。（最高位不当成负权重）然后对其进行截断（取模%2<sup>k</sup>）
2. 将第一步阶段后的无符号数，利用有符号数的函数映射解释二进制位转换为有符号数（最高位当成负权重）。
**总结：** 有符号数的截断后k位，先将其看成无符号数，进行截断（取模%2<sup>k</sup>）之后，在将其看成有符号数。



## 整数运算

### 无符号加法
![[Pasted image 20221217222412.png]]
**如果溢出则截断取w位，即取模（%w）**
>为什么图中的公式溢出的时候是减2<sup>w</sup>？
>因为：要保持数据w位，溢出之后的结果的不会超过一倍，即结果不可能是2<sup>w</sup>的 两倍，所以对其取模相当于与2<sup>w</sup>做差。

#### 检测无符号加法的溢出
  ![[Pasted image 20221217223432.png]]
当返回结果是1时则表示没有溢出，返回结果为0则表示发生了溢出。

**证明：**
当程序溢出时，sum=x+y-2<sup>w</sup>，
由于0≤y<sup>w</sup><2<sup>w</sup>；
即y-2<sup>w</sup><0
同时加上x，x+y-2<sup>w</sup>< x 

### 补码加法
**有符号数是补码表示**，补码加法也就是有符号数的加法。
![[Pasted image 20221217224313.png]]

 **负数相加，结果为正数，发生负溢出**
 **正数相加，结果为负数，发生正溢出**
 >正溢出实际上是一种假溢出，因为没有舍弃位，而是最高位由0变为1，产生了负权重。
 >负溢出是真正意义的溢出，最高位产生溢出，而被丢弃，使得负权重丢失，让结果变为正数。
 
#### 正溢出例子
![[Pasted image 20221217230050.png]]

**分析：** 计算结果就是舍弃溢出位保留w位再用有符号数解释的结果。
位计算，最高位发生溢出，**符号位由0变成1**，根据有符号数的解释方式，符号位占负权重，即-2<sup>w</sup>。
![[Pasted image 20221217230118.png]]

#### 负溢出例子
**分析：** 计算结果就是舍弃溢出位保留w位用有符号数解释的结果。
真是结果转计算结果：
位计算，最高位发生溢出，**符号位由1变成0**，原本两个数都有负权重 -2<sup>w-1</sup>，实际结果是负权重相加，再加上其他w-1位相加的和，而**计算结果**只要保留w位，即最高位0+其他w-1位相加的和，即在**实际结果基础上舍掉两个负权重**，所以实际结果+2<sup>w</sup>=计算结果 。
![[Pasted image 20221217230404.png]]



### 减法运算
**减去某个数等于加上这个数的相反数，即加法逆元**
$$
x+x'=0,
x'+x=0
$$
x与x‘互为相反数，所以
$$y-x=y+x'$$


#### 无符号数的减法运算
**对于有符号数，两个数相加结果,如果产生溢出那么结果就为0**
$$y-x=0=2^w$$

所以，对于$x(0≤x<2^w)$的逆元$x’$，可以标识为：

$$-^u_wx=x'= \begin{cases}
x, & x=0 \\
2^w-x,& x≥0\\
\end{cases}$$


#### 有符号数的减法运算
所以，对于$x(-2^{w-1}≤x<2^{w-1}-1)$的逆元$x’$，可以标识为：
$$-^t_wx=x'= \begin{cases}
-x, & x>TMin_w \\
TMin_w,& x=TMin_w\
\end{cases}$$
**因为补码的最大值绝对值总是比最小值的绝对值小1，所以无法直接给最小值添加-号来获取相反数，而由于最小值相加之后产生负溢出，结果为0，所以可以说最小值的相反数就是其自身。**


### 乘法运算

#### 有符号数的乘法运算
![[Pasted image 20221218144431.png]]
**即保留w位，对计算结果截断[[#无符号数转换成更小的数据类型|取模]]操作。**


#### 无符号数的乘法运算
![[Pasted image 20221218150628.png]]
**在无符号数乘法的基础上，取模之后再转化为有符号数。**

>有符号数乘法和无符号数乘法，截断之后的解释不同，但是**二进制位级表示是相同的。**

![[Pasted image 20221218151906.png]]
   
**无符号数的乘法**
$$x=x*2^k$$
上述式子可以看成，x向左移k位。
**证明如下：左移k位等一乘以2<sup>k</sup>**** 
![[Pasted image 20221218152837.png]]




### 除法运算
**同理与乘法，乘以2<sup>k</sup>，等价于左移动，那么除以2<sup>k</sup>，等价于右移。 

**由于有符号数是算术右移，负数高位补1，无符号数是逻辑右移，高位补0**

**整数除法总是舍人到零。**
如果是负数，则向上舍入，如果是正数则向下舍入，摄入结果总是取靠近于0的那一个。
![[Pasted image 20221218154152.png]]


#### 无符号数除法
1. 假设有一个无符号数x，位模式如下：
![[Pasted image 20221218154242.png]]
2. 将x右移k位([[#^bebe94|逻辑右移]])，得到x1
 ![[Pasted image 20221218154455.png]]
3. 被移出去的低k位，记为x2
![[Pasted image 20221218154641.png]]
4.  将x1左移k位(乘以2<sup>k</sup>)，得到x3
![[Pasted image 20221218154724.png]]
5. 将x3+x2，得到x4，**x4等于x**
![[Pasted image 20221218154836.png]]
6. 由于x2的长度为k，取值范围为$0<x2<2^k,$ 因此
$$
x/2^k=[(x1*2^k+x2)/2^k]=x1+0=x1
$$
**而x1是x右移k位的结果，所以可以说无符号数除以2的k次方，等于无符号数逻辑右移k位。**

**结论：对于无符号数，除以2的k次方，等于无符号数逻辑右移k位。****

#### 有符号数除法

##### 正数

**正数最高位为0，除法与[[#无符号数除法]]相同。**

##### 负数

对于-12340移动不同数位的结果如下：
![[Pasted image 20221218155729.png]]
*-772是向下舍入的结果，期望结果是-771（逼近0）*
**解决方法，引入偏置，计算结果加上偏置值，修正不合适的舍入**

![[Pasted image 20221218160233.png]]
**偏置值为$(1<<k)-1=2^k-1,$**
>k=4时，偏置值=(1<<4)-1=15
>k=8时，偏置值=(1<<8)-1=255

原数x加上偏置值相当于$+2^k-1,$再除$2^k$,$(x+2^k-1)/2^k=[x/2^k],$能保持结果不变，且保持向上取整。页面P73
![[Pasted image 20221218171652.png]]
![[Pasted image 20221218174546.png]]

## 浮点数

### 定长二进制小数
![[Pasted image 20221220205801.png]]
$101.11_2=1*2^2+0*2^1+1*2^0+1*2^{-1}+1*2^{-2}=4+0+1+1/2+1/4=5*3/4$
### IEEE浮点表示不定长小数
**IEEE浮点标准:** $V=(-1)^S*M*2^E$
- **符号:** s表示符号位,s=1表负数,s=0表正数.数值0的符号位解释是特殊情况.
- **尾数M:** M是一个二进制小时,范围是1~2-ε,或者0~1-ε.
- **阶码:** E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数)0

![[Pasted image 20221220211348.png]]

#### 单精度浮点数值分类

**根据阶码的不同进行分类,可以分为三种不同类型的值.**

##### 规格化的值
阶码的位不全为0同时也不全为1时.
即0000 0001~1111 1110,十进制是1~254
**由于阶码可能也会有负数,所以要减去偏置,即E=e-Bias**
>**偏置Bias**=$2^{k-1}-1$(单精度时为127,双精度为1023)
即阶码的表示范围为:-126~127

尾数定义为M=1+f,f用23位表示

##### 非规格化的值
**阶码的位全为0时**
此时,阶码值为E=**1-Bias**
尾数的值为M=f
>非规格化E的定义，有利于规格化数和非规格化数之间的平滑转变。

**用途:** 
- 表示-0.0,符号位0,阶码全0，小数位全0.
- 表示+0.0,符号位1,阶码全0，小数全位0
- 表示非常接近0的数,它们提供了一种*逐渐溢出*的属性

##### 特殊值
**阶码全为1**
- 尾数全为0,表示无穷
	- s=0,表示正无穷
	- s=1,表示负无穷
	>*作用:* 无穷能表示溢出结果
- 尾数为非零时,表示NaN,即**不是一个数**
	>一些运算的结果不能是实数或无穷，就会返回这样的NaN值，比如:根号-1或者无穷减无穷时.


### 舍入
**舍入目的：** 找到最为匹配的$x'$，用期望的浮点数形式表示$x$.
**方法：** 向偶数舍入、向零舍入、向下舍入、向上舍入、
![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221227230746.png)

#### 向偶数舍入
**向偶数舍入为最接近的值舍入，是默认的方式。**
**只是简单地考虑最低有效数，将最低有效位的值0认为是偶数，1认为是奇数。**
**方法：** $x^-$向下舍入的值，$x^+$向上舍入的值
- 如果$x^-<x<x^+$，同时$x≠(x^-+x^+)/2$将采用四舍五入，即，被舍入位如果大于最低有效位的1/2则向上舍入，小于则向下舍入。
- 如果$x=(x^-+x^+)/2$ ，采用**向偶数舍入**，即使得最低有效位为偶数。
>这种方法将1.5美元和2.5美元都舍入成2美元。


### 浮点运算
![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221227233921.png)

![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221227233953.png)

![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221227234013.png)

**因为舍入的原因，浮点数+和* 运算没有结合性和分配性



# 第三章 程序的机器级表示

## 3.2 程序编码

### 机器级代码
![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20230104210721.png)
1. 以上是x86-64的指令。**指令长度从1到15字节不等。** 常用的指令以及操作数较少的指令所需字节数少。
2. 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令`pushq％rbx`是以字节值53开头的。
3. **反汇编器只是基于机器代码文件中的字节序列来确定汇编代**码。它不需要访问该程序的源代码或汇编代码。
4. 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。


## 数据格式

![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20230104212317.png)
如图所示，大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。
例如，数据传送指令有四个变种：`movb`（传送字节）、`movw`“（传送字）、`movl`(传送双字）和`movq`（传送四字）。
后缀l，用来表示双字，因为32位数被看成是“长字（long
word)”。注意，汇编代码也使用后缀l，来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。


## 访问信息
![[Pasted image 20230105165003.png]]

当这些指令以寄存器作为目标时，对于生成小于8字节（64位）结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则：
1. 生成1字节和2字节数字的指令会保持剩下的字节不变
2. 生成4字节数字的指令会把高位4个字节置为0。
>[!note]
>第二条规则是作为从A32到x86-64的扩展的一部分而采用的。


### 操作数指示符

**操作数：** 指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

各种不同的操作数的可能性被分为三种类型。
1. **立即数。** 用于表示常数值。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
2. **寄存器。** 它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位。
3. **内存引用。** 第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。形如M[addr ]表示对存储在内存中从地址addr 开始的b个字节值的引用。为了简便，我们通常省去下标b。
![[Pasted image 20230105174330.png]]


### 数据传送指令

#### MOV类

MOV类指令把数据从源位置复制到目的位置，不做任何变化。
**MOV类由四条指令组成：movb、movw、movl和
movq。**
这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是1、2、4和8字节。
![[Pasted image 20230105175109.png]]
源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。

将一个值从一个内存位置复制到另一个内存位置需要两条指令。
1. 第一条指令将源值加载到寄存器中。
2. 第二条将该寄存器值写人目的位置。
>[!note]
>1. x86-64加了一条限制，传送指令的**两个操作数不能都指向内存位置**。
>2. 寄存器部分的大小必须与指令最后一个字符（b，w，l或q，）指定的大小匹配。
>3. mov指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。
>	- .原因是x86-64的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置0. 

源和目的类型的五种可能类型的组合。**第一个操作数是源操作数，第二个是目的操作数。**
![[Pasted image 20230105180850.png]]
>`movabsq`指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

`Mov`类指令包含两类数据移动指令。**在将较小的源值复制到较大的目的时使用。**
每条指令名字的最后两个字符都是大小指示符：
1. 第一个字符指定源的大小，。
2. 第二个指明目的的大小。

##### 两类数据移动指令：MOVZ类
`MOVZ`类指令把目的中剩余的字节**填充为0**。
![[Pasted image 20230105181514.png]]


##### 两类数据移动指令：MOVZ类
`MOVS`类指令通过**符号扩展来填充**，把源操作的最高位进行复制。
![[Pasted image 20230105181531.png]]

### 数据传送示例

![[Pasted image 20230105201046.png]]
1. 过程参数`xp`和`y`分别存储在寄存器`%rdi`和`%rsi`中。
2. C语言中的指针，其实就是地址，也就是寄存器中保存的不是立即数，而是一个地址，需要根据这个地址再去内存中获取数。%%寄存器间接寻址%% ^c1ebd4
3. 局部变量通常保存在寄存器中。


### 压入和弹出栈数据
在x86-64中，程序栈存放在**内存**中某个区域。
![[Pasted image 20230107160020.png]]
栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。（根据惯例，我们的栈是倒过来画的，栈“顶”在图的底部。）
- **栈指针`%rsp`保存着栈顶元素的地址。** ^8e4007

![[Pasted image 20230107161836.png]]

#### 入栈
![[Pasted image 20230107160921.png]]
首先在栈指针中取出栈顶地址，地址-8之后得到新的栈顶地址，在内存中该地址上写入数据。
**pushq %rbq等价下面两条指令。**
![[Pasted image 20230107161025.png]]

>[!FAQ] 为什么是地址-8？
>因为该指令是pushq，一次压入数据大小是四个字，而一个字=16位=2字节，所以四个字=8字节。字节是最小寻址单元，所以地址要-8.


#### 出栈
![[Pasted image 20230107161421.png]]
在内存中找出栈顶指针(寄存器%rsp)保存的地址，在内存中该地址的数据取出之后，栈顶指针保存的地址要+8.
等价于下面两条指令。
![[Pasted image 20230107161812.png]]



## 算数和逻辑操作
![[Pasted image 20230107162340.png]]

- **除了`leaq`指令没有其他大小的变种外，其他指令有各种带不同大小操作数额变种。**
>例如，`addb`、`addw`、`addl`、`addq`分别对应字节加法、字加法、双字加法、四字加法。

- 以上指令被分为四组。
	- [[#加载有效地址]]
	- [[#一元操作]]
	- [[#二元操作]]
	- [[#移位操作]]


### 加载有效地址

**指令`leaq`实际上是`movq`指令的变形。** 它的指令形式是**从内存读数据到寄存器，** 但实际上它根本就没有引用内存。**而是将有效地址写入目的操作数。**
![[Pasted image 20230107164703.png]]


### 一元和二元操作

#### 一元操作
- **一元操作只有一个操作数，** 既是源又是目的。
- 这个操作数可以是一个**寄存器**，也可以是一个**内存位置**。
>`incq (%rsp)`：使栈顶的8字节元素+1.(%rsp是栈顶指针，保存栈顶地址。)

#### 二元操作
- 源操作数是第一个，目的操作数是第二个。
- **第二个操作数既是源又是目的。** 
>类似cpp中的赋值运算
>`x+=y`

- 第一个操作数可以是立即数、寄存器或是内存位置。
- 第二个操作数可以是寄存器或是内存位置。
>[!waring]
>当**第二个操作数为内存地址时**，处理器必须从内存读出值，执行操作，再把结果写回
内存。


### 移位操作

- 第一项是**移位量**，然后第二项给出的是要移位的数。
- **移位量**可以是一个立即数，或者放在单字节寄存器`%cl`中。（这些指令很特别，因为*只允许以这个特定的寄存器作为操作数。*）

- 原则上来说，1个字节的移位量使得移位量的编码范围可以达到$2^8-1=255$。x86-64中，移位操作对位长的数据值进行操作，移位量是由`%cl`寄存器的低m位决定的，这里$2^m=w$。高位会被忽略。所以，例如当寄存器`%cl`的十六进制值为0xFF时，指令`salb`会移7位，`salw`会移15位，`sall`会移31位，而`salq`会移63位。

- 右移指令不同，`SAR`执行算术移位（填上符号位），而`SHR`执行逻辑移位（填上0)。
- 移位操作的**目的操作数可以是一个寄存器或是一个内存位置**。



### 特殊的算术操作
**两个64位**有符号或无符号整数相乘得到的**乘积需要128位**来表示。
![[Pasted image 20230107174530.png]]


## 控制
用`jump`指令可以**改变一组机器代码指令的执行顺序**，jump指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。

### 条件码
- **条件码寄存器：** CPU维护的一组单个位的条件码寄存器。它们描述了最近的算术或逻辑操作的属性。**可以检测这些寄存器来执行条件分支指令。**
	- CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
	- ZF：零标志。最近的操作得出的结果为0。
	- SF：符号标志。最近的操作得到的结果为负数。
	- OF：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。


#### 会设置条件码的指令
1. [[#算数和逻辑操作]]小节中的四类指令，除了`leaq`不改变任何条件码之外，其他三类指令都会设置条件码。
>`leaq`是用来进行地址计算的，不改变条件码。

**以下两类只设置条件码而不改变任何其他寄存器。** 它们都有8、16、32、64位的形式。
2. CMP指令。根据两个操作数之差来设置条件码。除了只设置条件码不更新目的寄存器之外，CMP指令和SUB指令的行为是一样的。
3. TEST指令。TEST指令和AND指令的行为是一样的。
![[Pasted image 20230109212820.png]]
**不同指令有不同的设置条件码的规则。** ^0d89ae

### 访问条件码
1. 可以根据条件码的某种组合，将一个字节设置为0或者1。
利用条件码的组合，再利用SET指令将一个字节设置0或者1.从而实现条件判断。
![[Pasted image 20230109214617.png]]
![[Pasted image 20230109215211.png]]
> [!FAQ]- 如何判断是否小于？
>根据SF^OF(符号标志位与溢出标志位的异或结果来判定。)
>![[Pasted image 20230109215540.png]]
>1. a<b,t<0,没有溢出情况，此时SF=1,SF^OF=1
>2. a>b,t>0,没有溢出情况，此时SF=0,SF^OF=0
>3. a<b,t>0,发生溢出，此时SF=0，OF=1，SF^OF=1
>4. a>b,t<0,发生溢出，此时SF=1，OF=1，SF^OF=0
>综上，根据SF^OF异或结果，等于1时，表示等于；等于0时，表示不小于。

2. 可以条件跳转到程序的某个其他的部分。
3. 可以有条件地传送数据。

### 跳转指令
- `jmp`指令：无条件跳转,可以是**直接跳转**，也可以是**间接跳转**。
	```c++
	jmp *%rax //寄存器rax中的值作为跳转目标
	jmp *(%rax)//以寄存器中的值作为地址，从内存中读出跳转目标。
	```
![[Pasted image 20230109224443.png]]
>[!note]
>表中的跳转指令，**根据条件码的某种组合，** 或者跳转或者继续执行代码中的下一条指令。这些指令的名字和跳转条件与`SET`指令的名字和设置条件是相匹配的。


### 跳转指令的编码
跳转指令有几种不同的编码，但是最常用都是**PC相对的**(PC-reIative)。
- 第一种：**PC相对**寻址
>它们会将**目标指令的地址**与**紧跟在跳转指令后面那条指令的地址**之间的**差**作为编码。这些地址偏移量可以编码为1、2或4个字节。

![[Pasted image 20230109225603.png]]
>第一条跳转指令的目标编码(编码的第二个字节)为0x03，将其加上下一条指令的地址0x5，可以得到0x8，既是跳转的目标地址，即第四行指令的地址。
>第二条跳转指令的目标编码为f8(补码表示，十进制为-8)，将其加上下一条指令的地址0xd(十进制13)，可以得到0x5，即第三行指令的地址。

- 第二种：编码方法是给出 **“绝对”地址**，用4个字节直接指定目标。

**汇编器和链接器会选择适当的跳转目的编码。**


### 用条件控制来实现条件分支
- 原始C代码：
![[Pasted image 20230111101213.png]]

- 与之等价的goto版本代码
![[Pasted image 20230111101259.png]]

- GCC产生的汇编代码
![[Pasted image 20230111101311.png]]


### 用条件传送来实现条件分支
条件操作的方法：
1. **使用控制的条件转移。** 条件满足或者不满足走两条不同的代码路径，简单但是低效。
2. **使用数据的条件控制。** 计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。更符合现代处理器的性能特性，使用情况受限。

#### 使用数据的条件控制

- 原始C代码
![[Pasted image 20230111101735.png]]
- 使用条件控制
![[Pasted image 20230111101837.png]]

- 产生的汇编代码
![[Pasted image 20230111101854.png]]

- **计算了两种情况下的数据保存在寄存器中，然后再进行条件判断，返回符合条件的数据值。**
- **现代处理器通过使用流水线技术获得高性能，** 在流水线中，条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支”）时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到90％以上的成功率），指令流水线中就会充满着指令。


- x86-64中可用的条件传送指令
![[Pasted image 20230111103728.png]]
>所以对所有的操作数长度，都可以使用同一个的指令名字


### 循环

以计算$n!$为例。


#### do-while循环
![[Pasted image 20230111104057.png]]

**`body-statement`中的代码至少会执行一次。**

- C代码
![[Pasted image 20230111104332.png]]

- 计算$n!$的goto代码
![[Pasted image 20230111104409.png]]

- 对应的汇编代码
![[Pasted image 20230111104413.png]]


#### while循环
![[Pasted image 20230111104725.png]]

- C代码
![[Pasted image 20230111105300.png]]

**gcc翻译while循环有两种方法**
##### 第一种方法：跳转到中间
跳转到中间：执行一个无条件条件到循环结尾处的测试，以此来执行初始的测试。

- 通用goto代码：
![[Pasted image 20230111105015.png]]

- 计算$n!$对应的goto代码
![[Pasted image 20230111105329.png]]

- 对应的汇编代码
![[Pasted image 20230111105343.png]]


##### 第二种方法：guarded-do
guarded-do：首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环。
![[Pasted image 20230111110017.png]]

>当使用命令行编译选项`-O1`时，编译器采用该策略。

- 通用goto代码
![[Pasted image 20230111110033.png]]

- 计算$n!$对应的goto代码
![[Pasted image 20230111110232.png]]

- 对应的汇编代码
![[Pasted image 20230111110255.png]]


##### 第三种方法：for循环
![[Pasted image 20230111110428.png]]
与之等价的while循环
![[Pasted image 20230111110446.png]]

GCC为for循环产生的代码是while循环的两种翻译之一，这取决于优化的等级。
- 例子for循环阶乘C代码
![[Pasted image 20230111111618.png]]

 转换成while代码
 ![[Pasted image 20230111111659.png]]
 

- 采用[[#第一种方法：跳转到中间]]：
![[Pasted image 20230111111512.png]]
![[Pasted image 20230111111517.png]]
goto代码
![[Pasted image 20230111111752.png]]
对应的汇编代码
![[Pasted image 20230111111808.png]]


- 采用[[#第二种方法：guarded-do]]
![[Pasted image 20230111111547.png]]


### switch语句
- `switch`（开关）语句可以根据一个整数索引值进行多重分支。
- 用**跳转表**这种数据结构使得实现更加高效。优点是是**执行开关语句的时间与开关情况的数量无关。** 
- GCC根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如4个以上），并且值的范围跨度比较小时，就会使用跳转表。
- 程序可以只用一次跳转表引用就分支到5个不同的位置。甚至当switch语句有上百种情况的时候，也可以只用一次跳转表访问去处理。

>当`switch`语句有上百种情况的时候，也可以只用一次跳转表访问去处理,因此中执行效率较`ifelse`语句高。

## 过程
不同编程语言中，过程的形式多样：函数(function)、方法(method)、子例程(subroutine)、处理函数(handler)等等，但是它们有一些共有的特性。

### 运行时栈
![[Pasted image 20230112115744.png]]
x86-64的过程利用寄存器保存参数的值，超过寄存器能存储的大小时会在栈上分配空间保存，函数调用过程中所需要的存储空间（例如局部变量）使用栈来保存。

**栈帧：** 栈上存放的过程中的数据的存储空间。


- 正在执行的过程的帧总是在栈顶。
- 过程如果包含参数小于等于6个，那么所有参数都可以通过寄存器传递，无需用到堆帧。

### 控制转移

#### call指令和ret指令
![[Pasted image 20230112144716.png]]
**call作用：** 把返回地址A压人栈中，并将PC设置为被调用函数的起始地址。
**ret作用：** 从堆中弹出地址A的值，然后跳转到该地址。

>A是紧跟在call指令后的那条指令的地址


### 数据传送
x86-64中，可以通过寄存器最多传递6个整型（例如整数和指针）参数。超出部分使用栈帧来传递。

![[Pasted image 20230112151528.png]]

**通过栈传递参数**时，所有的数据大小都向8的倍数对齐。

#### 参数保存例子
- 原函数：
![[Pasted image 20230112152120.png]]

- 参数在保存的位置
>%rsp是栈指针，保存栈顶的地址。栈顶保存在低地址。[[#压入和弹出栈数据]]
![[Pasted image 20230112152309.png]]
![[Pasted image 20230112152859.png]]

### 栈上的局部存储
局部数据必须放在内存中的情况：
- 寄存器不足够存放所有的本地数据
- 对一局部变量使用地址运算符`&`，因此必须能够为它产生一个地址。
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。
一般来说，**过程通过减小栈指针在栈上分配空间。**

#### 例子1
- C语言原函数：
![[Pasted image 20230113131443.png]]

- 对应的汇编代码
![[Pasted image 20230113131500.png]]
	- **栈顶是低地址**，第2行在栈上分配16个字节，以保存`arg1`和`arg2`变量。
	- 第3和第4条指令分别将操作数`arg1`和`arg2`压入栈中。
	- 第5、6行将参数的地址存放在两个寄存器中
	- 第7行调用函数swap_add,函数执行完毕之后会继续执行第8行的指令。
	- 第8行第9行从寄存器中取出两个参数，将相减的值存在寄存器%rdx中
	- 第10行计算乘积
	- 11行通过栈指针加16的操作**释放两个局部变量占用的存储空间。**

>[!note]
>过程中的局部变量存储在栈中，在调用结束之后就被释放。


#### 例子2
- C原函数
![[Pasted image 20230113133446.png]]

- 对应的汇编代码
![[Pasted image 20230113133513.png]]
	- 第7、10、12、14行leaq指令生成存放局部变量地址的指针，即把地址存在寄存器中。

- 栈空间
![[Pasted image 20230113133537.png]]
- 局部变量在栈中存储是不需要8字节对齐的，而参数在栈中存储则需要8字节对齐。

### 寄存器中的局部存储空间
- 寄存器组是唯一被所有过程共享的资源。
- 所有过程必须遵循寄存器调用惯例。
- 寄存器使用惯例：
	- 寄存器`%rbx`、`%rbp`和`%r12~%r15`被划分为**被调用者保存寄存器**
	- %rdi、%rsi、%rdx、%rcx、%r8，%r9、%rax，%r10，%r11为**调用者保存寄存器。**

由于寄存器是通用的在过程调用中，调用过程可能用到相同的寄存器而导致前一次调用过程中的值被覆盖，所以在过程调用之前，应该先把寄存器中的值保存在该过程的栈中，在调用结束之后再将其弹出。

**因为P函数两次调用Q，用到相同的寄存器保存，后一次会将前一次覆盖，在第二次调用Q之前，使用寄存器%rbp保存x的值，使用rbx保存第一次调用Q返回的值。**
![[Pasted image 20230113140711.png]]
![[Pasted image 20230113140719.png]]

### 递归过程
过程调用在栈中都有它自己的私有空间，调用结束之后就会释放。
**递归不能太多层，不然栈会溢出**

#### 例子
- C代码
![[Pasted image 20230113141251.png]]

- 对应的汇编
![[Pasted image 20230113141302.png]]
	- %rbx保存当前函数参数的n值，%rax保存1，函数每一次调用就将当前参数n压入栈中，当n=1时，就将其弹出，弹出后程序将上一次调用`rfact`后的下一跳指令地址也就是执行`imulq`指令，执行之后再弹出n继续返回`rfact`直至到最上层的`rfact`为止。

- 栈空间状态
![[Pasted image 20230113141353.png]]


## 数组分配和访问

### 基本原则
- 声明数组：`T A[N]`。表示在内存中分配一个L* N字节的连续区域，L是数据类型的大小（单位是字节）
>利用X+L* i可以计算出第i个元素的地址

### 指针运算
C语言允许对指针进行运算，而计算出来的**值会根据该指针引用的数据类型的大小进行伸缩**。也就是说，如果`p`是一个指向类型为`T`的数据的指针，`p`的值为，那么表达式`p+i`的值为`xp+L·i`，这里`L`是数据类型`T`的大小。
![[Pasted image 20230114225322.png]]
- `int` 4字节，`int *` 8字节
- 最后是计算同一个数据结构中的两个指针之差，结果的数据类型为`long`，值等于两个地址之差除以该数据类型的大小。

### 嵌套的数组
**嵌套数组**可以看成是数组的数组，即数组中的元素类型是数组

- 定义一个二维数组
```c++
typedef int row3_t[3];//定义嵌套数组中的内数组
row3_t A[5]

//等价于
int A[5][3]
```
- 存储情况
![[Pasted image 20230114225953.png]]

- 计算第i行j列的地址
`T D[R][C]`数组中元素`D[i][j]`的内存地址为：`&D[i][j]` = $X_D+L(C*i+j)$
>其中$C*i$可以看成是计算该位置前面的所有行的元素所占的空间，j该元素在当前行的偏移量，L是该数据类型所占的字节大小。

### 定长数组
C语言编译器能够优化定长多维数组上的操作代码。

- C语言例子：
![[Pasted image 20230114231945.png]]
>计算矩阵A的第i行与矩阵B第k列的内积。

- GCC在优化等级O1时候产生的汇编代码
![[Pasted image 20230114232235.png]]
	- 第2行计算`A[i][0]`距离数组首地址的相对地址
	- 第3行计算`A[i][0]`的地址保存在寄存器`%rdi`中
	- 第4行计算`B[0][k]`的地址，保存在寄存器`%rcx`中
	- 第五行计算`B[N][k]`，保存在`%rsi`中其中$1024=16*16*4$

- 由该汇编代码反汇编而成的C语言
![[Pasted image 20230114232245.png]]

### 变长数组
ISO C99中允许数组的维度是表达式，在数组被分配时才计算。
```c++
int A[expr1][expr2];//声明一个变长数组，两个维度都是表达式

int var_ele(long n,int A[n][n],long i,long j){
	return A[i][j];
}
//参数n必须在参数A[n][n]之前，这样函数就可以在遇到这个数组的时候计算出数组的维度。对应的汇编代码如下
```
![[Pasted image 20230114233824.png]]
>第五行是根据公式计算地址，读出`A[i][j]`的值。

**动态数组在计算地址时候需要使用乘法指令，** 不能使用一系列的移位和加法，这点区别于定长数组地址的计算。

在一个循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的计算。

>左边是定长数组，右边是变长数组产生的汇编代码。在变长数组的汇编代码中，程序既使用了伸缩过的值（寄存器`%r9`）来增加`Bptr`，也是用了`n`的值(寄存器`%rdi`)来检查循环的边界，而C代码中并没有体现出需要这两个值，但是由于指针运算的伸缩，才使用了这两个值。
![[Pasted image 20230114235202.png]]


## 异质的数据结构
C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：
- 结构，用关键字`struct`来声明，将多个对象集合到一个单位中；
- 联合，用关键字`union`来声明，允许用几种不同的类型来引用一个对象。

### 结构
- c语言的`struct`声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。
- 类似于数组的实现，**结构的所有组成部分都存放在内存中一段连续的区域内**，而指向结构的指针就是结构第一个字节的地址。
- 编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。


### 联合
- 作用：能够规避C语言的类型系统，允许以多种类型来引用一个对象，联合声明的语法与结构的语法一样，只不过语义相差比较大 。**它们是用不同的字段来引用相同的内存块。**

- 声明
```c++
structS3{
	char C;
	int i[2];
	double v;
};
unionU3{
	Char C；
	int i[2]；
	double V；
};
```

- ![[Pasted image 20230115001128.png]]
**一个联合的总的大小等于它最大字段的大小。**

- **应用**：相较于结构，将不同的互斥字段声明在联合中，作为联合的一部分会减少分配空间的总量。
例子1：使用联合存储二叉树，该二叉树内部节点只有左右之争，叶子节点有两个数值，因为一个节点不是内部节点就是叶子节点所以可以使用联合来定义该二叉树的节点。
```c++
//1. 结构体实现，占用32字节
struct node_s{
	struct node_s *left;
	struct node_s *right;
	double data[2];
}

//2. 联合体占用16个字节，但是该定义无法表示当前节点是内部节点还是叶子节点
union node_u{
	struct{
		union node_u *left;
		union node_u *right;
	}internal;//用于表示内部节点
	double data[2];//用于表示叶子节点
}

//3. 采用枚举类型，表示当前节点
//type占4字节，internal 16字节，data 16字节采用八字节对齐type填充4字节所以一共需要4+4+16=24字节
typedef enum {N_LEAF,N_INTERNAL} nodetype_t;
struct node_s{
	nodetype_t type;//用于标识当前节点的类型
	struct{
		union node_u *left;
		union node_u *right;
	}internal;//用于表示内部节点
	double data[2];//用于表示叶子节点
}
```

- **应用：** 联合还可以用来访问不同数据类型的位模式。当用联合来将各种不同大小的数据类型结合到一起时，字节顺序问题就变得很重要，大端小端机器会对位模式进行不同的解读。
例子2：使用联合保存两个数据类型实现强制转换
```c++
//以一种数据类型来存储联合中的参数，又以另一种数据类型来访问它
unsigned long double2bits(double d){
	union{
		double d;
		unsigned long u;
	}temp;
	temp.d=d;
	return temp.u;
}
```


### 数据对齐
数据对其的原则：任何K字节的基本对象的地址必须是K的倍数。`.align 8`保证了后面的数据的起始地址是8的倍数。

对于包含结构的代码，编译器可能需要在字段的分配中插人间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。
```c++
struct S1{
	int i;
	char c;
	int j;
}
```
![[Pasted image 20230115153218.png]]
保持了四字节对齐。

编译器末尾可能也会需要对齐，因为如果是结构体数组的话，末尾如果不对齐会导致之后的元素也不对其。


## 在机器级程序中将控制与数据结合起来

### 理解指针
指针映射到机器代码的关键原则：
- 每个指针都对应一个类型。
- 每个指针都有一个值。这个值是某个指定类型的对象的地址。
- 指针用`&`，运算符创建。
- `*`操作符用于间接引用指针。其结果是一个值，它的类型与该指针的类型一致。
- 数组与指针紧密联系。一个数组的名字可以像一个指针变量一样引用（但是不能修改）。
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。
>p是一个`char *`类型的指针，值为pp，那么表达式`(int *)p+7`计算结果为pp+28，而`(int *)(p+7)`的计算结果为pp+7.（强制类型转换的优先级高于加法。）
- 指针也可以指向函数称为 [[CPP#函数指针|函数指针]]，函数指针的值是该函数机器代码中第一条指令的地址

### 应用：使用GDB调试器
P194

### 内存越界引用和缓冲区溢出
C对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。

#### 缓冲区溢出
![[Pasted image 20230115160024.png]]
**gets函数的作用：** 从标准输人读人一行，在遇到一个回车换行字符或某个错误情况时停止。它将这个字符串复制到参数指明的位置，并在字符串结尾加上`null`字符。
	- **存在问题：** 没有办法确定是否为保存整个字符串分配了足够的空间。

**echo函数的作用：** 简单地从标准输人中读人一行，再把它回送到标准输出。

echo的汇编代码如下
![[Pasted image 20230115160230.png]]
该程序把栈指针减去24（栈顶是低地址），在栈上分配了24个字节，字符数组buf位于栈顶。
![[Pasted image 20230115160602.png]]
一旦数组字符串超过23个字符返回指针的值以及更多可能的保存状态会被破坏。如果存储的返回地址的值被破坏了，那么ret指
令（第8行）会导致程序跳转到一个完全意
想不到的位置。

>程序改进：使用`fgets`函数，该函数包括一个参数，限制待读入的最大字节数。

### 对抗缓冲区溢出攻击
#### 栈随机化
**栈随机化的思想使得栈的位置在程序每次运行时都有变化**。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段
0~n字节之间的随机大小的空间，例如，使用分配函数`alloca`在栈上分配指定字节数量的空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。分配的范围n”必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间。

在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化，或者简称ASLR\[99]。采用ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量
和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，它们的地址映射大相径庭。这样才能够对抗一些形式的
攻击。

 在实际的攻击代码前插人很长一段的`nop`指令。执行这种指令除了对程序计数器加一，使之指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是**空操作雪橇**

#### 栈破坏检测
**栈保护者机制：** 在栈帧中任何局部缓冲区与栈状态之间存储一个特殊金丝雀值，在恢复寄存器状态和从函数返回之前程序检查金丝雀值是否被该函数某个操作或者该函数调用的某个操作改变了，如果改变，那么程序异常终止。
>金丝雀值也叫哨兵值，是程序次运行时随机产生的。
>GCC编译时，`-fno-stack-protector`可以组织GCC使用栈保护者机制。
![[Pasted image 20230115162216.png]]
![[Pasted image 20230115162616.png]]
![[Pasted image 20230115162639.png]]

- 第3行从内存中读出一个值，再把它存放在栈中相对于`%rsp`偏移量为8的地方。参数`%fs:40`指明金丝雀值是用段寻址从内存中读入。
- 将金丝雀值存放在一个特殊的段中，标志为“只读”，这样攻击者就不能覆盖存储的金丝雀值。
- 在恢复寄存器状态和返回前，函数将存储在栈位置处的值与金丝雀值做比较，如果两个数相同，`xorq`指令就会得到0，函数会按照正常方式完成，非零表明栈上的金丝雀值被修改过，那么代码就会调用一个错误处理例程。

#### 限制可执行代码区域
- 限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。
以前，x86体系结构将读和执行访问控制合并成一个1位的标志，这样任何被标记为**可读的页也都是可执行的。** 而栈必须是可读既可写的，因此，栈上的字节也都是可执行的。

后来，AMD和Intel将读和执行访问模式分开，栈可以被标记为可读和可写，但是不可执行，而检查页是否可执行由硬件来完成，效率上没有损失。

“即时“编译技术为解释语言（例如java）编写的程序动态地产生代码，以提高性能。是否能够将可执行代码限制在由编译器在创建原始程序时产生的那个部分中，取决于语言和操作系统。


### 支持变长栈帧
当函数调用`alloca`时，会为函数动态分配存储空间，因此需要的局部存储是变长的。
>`alloca`是一个标准库函数，可以在栈上分配任意字节数量的存储。

![[Pasted image 20230115163935.png]]
- 局部变量`i`和指针数组存在该函数的栈帧中。

![[Pasted image 20230115164203.png]]
- `%rbp`作为帧指针指向该函数的起始地址。
- `%rbp`是一个被调用者保存寄存器
- 在函数调结尾，leave指令(第20行)将帧指针恢复到之前的值，即把栈指针设置为%rbp保存的值的位置，然后把该值从栈中弹出到`%rbp`。这个指令组合具有释放整个栈帧的效果。（释放该函数的在栈上的存储空间）
- 在较早版本的x86代码中，每个函数调用都使用了帧指针。而现在，只在栈帧长可变的情况下才使用。


## 浮点代码
浮点体系结构影响对浮点数据操作的程序如何被映射到机器上，包括：
- 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。
- 对浮点数据操作的指令。
- ·向函数传递浮点数参数和从数返回浮点数结果的规则。
- 函数调用过程中保存寄存器的规则一一例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。

AVX浮点体系结构允许数据存储在16个YMM寄存器中，它们的名字为%ymm0~%ymm15。每个YMM寄存器都是256位（32字节）。
- 当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位（对于`float`)或64位（对于`double`)。
- 汇编代码中使用寄存器的SSE XMM寄存器名字%xmm0~%xmm15来使用它们，每个XMM寄存器都是对应的YMM寄存器的低128位。
![[Pasted image 20230116163322.png]]

### 浮点传送和转换操作
- 浮点传送指令：
![[Pasted image 20230116163923.png]]
>无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议32位内存数据满足4字节对齐，64位数据满足8字节对齐。
>指令名字中的字母'a，表示对齐的。当用于读写内存时，如果不满足16字节对齐将导致异常。

对于在两个XMM寄存器之间传送数据，GCC会使用两种指令之一：
- `vmovaps`传送单精度数。
- `vmovapd`传送双精度数。


把浮点数转换成整数时，指令会执行[[#^003fc0|截断]]，把值向0进行舍入。这是C和大多数其他编程语言的要求。

- 浮点转换指令：
![[Pasted image 20230116165053.png]]
![[Pasted image 20230116165159.png]]
三操作数浮点转换指令。有两个源和一个目的。
	- 第一个操作数读自于内存或一个通用目的寄存器。
	- 第二个操作数的值只会影响结果的高位字节，这里我们的目标寄存器是XMM，所以第二操作数可以忽略。

将单精度转换成双精度，并将结果存储在寄存器%xmm0的低8位字节(一半)。
	- 指令：假设%xmm0的低4位字节保存着一个单精度值。
	- ![[Pasted image 20230116171343.png]]
	- 汇编：
	- ![[Pasted image 20230116171453.png]]
	- 使用`vunpcklps`指令，如果原始寄存器的值是$[x_3,x_2,x_1,x_0]$，(其中一位是4字节，双字)那么该指令会将寄存器的值更新为$[x_1,x_1,x_0,x_0]$.
	- 使用`vcvtps2pd`指令，把源XMM寄存器中的两个低位单精度值扩展成目的XMM寄存器中的两个双精度值。即会得到值$[dx_0,dx_0]$,这里$dx_0$是将转换成双精度后的结果。
	- 这两条指令的最终效果是将原始的%xmm0低位4字节中的单精度值转换成双精度值，再将其两个副本保存到%xmm0中。

>`vunpcklps`指令通常用来交叉放置来自两个XMM寄存器的值，把它们存储到第三个寄存器中。
>如果一个源寄存器的内容为字$[s_3,s_2,s_1,s_0]$，另一个源寄存器为字$[d_3,d_2,d_1,d_0]$，那么目的寄存器的值会是$[s_1,d_1,s_0,d_0]$.

将双精度转换成单精度：
	- 指令：假设这些指令开始执行前寄存器%xmm0保存着两个双精度值$[x_1,x_0]$。
	- 汇编：
	- ![[Pasted image 20230116172830.png]]
	- `vmovddup`指令：把%xmm0中的值设置成$[x_0,x_0]$。
	- `vcvtpd2psx`指令：这两个值转换成单精度，再存放到该寄存器的低位一半中，并将高位一半设置为0，$[0,0,x_0,x_0]$

### 过程中的浮点代码
XMM寄存器用来向函数传递浮点参数，以及从数返回浮点值。

规则：
- XMM寄存器%xmm0~%xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。
- 函数使用寄存器%xmm0来返回浮点值。
- 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。

当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过XMM寄存器传递。也就是说，参数到寄存器的映射取决于它们的类型和排列的顺序。

### 浮点运算操作

标量AVX2浮点指令：
每条指令有一个($S_1$)或两($S_1,S_2$)源操作数和一个目的操作数D。
- 第一个源操作数可以是一个XMM寄存器或一个内存位置。
- 第二个源操作数和目的操作数都必须是XMM寄存器。
- 每个操作都有一条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。
![[Pasted image 20230116173812.png]]

![[Pasted image 20230116174147.png]]
![[Pasted image 20230116174157.png]]

### 定义和使用浮点常数
**AVX浮点操作不能以立即数值作为操作数。** 相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码在把这些值从内存读入。

P212例子

### 在浮点代码中使用位级操作

![[Pasted image 20230116175227.png]]


### 浮点比较操作
AVX2提供了两条用于比较浮点数值的指令：
![[Pasted image 20230116175359.png]]
- 这些指令类似于[[#^0d89ae|CMP指令]]，它们都比较操作数和（但是顺序可能与预计的相反），并且设置条件码指示它们的相对值。
- 参数$S_2$必须在XMM寄存器中，而$S_1$可以在XMM寄存器中，也可以在内存中。

浮点操作设置的[[#条件码]]：
- 零标志位ZF
- 进位标志位CF
- 奇偶标志位PF，在GCC产生的X86代码不太常见。

奇偶标志位的作用：
- 对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的(即这个字节中有偶数个1)，那么就会设置该标志位。
- 对于浮点，当两个操作数中任一个是`NaN`时，会设置该位。
>c语言中如果有个参数为`NaN`，就认为比较失败了。当x为`NaN`时，比较`x==x`，结果是0

条件码设置条件：
![[Pasted image 20230116180118.png]]
>当任一操作数为NaN时，就会出现无序的情况。可以通过奇偶标志位发现这种情况。

除了无序情况，进位和零标志位的值都和对应的无符号比较一样：
- 当两个操作数相等时，设置ZF
- $S_2<S_1$，时设置CF
**ja和jb指令根据标志位的各种组合进行条件跳转。**

例子P215

### 对浮点代码的观察结论
- AVX2代码包括许多比只执行整数运算的函数更加不同的指令和格式。
- 对比整数操纵，浮点操作处理不同的数据类型以及对包含混合数据类型的表达式求值的规则有许多复杂之处。(因为可能要进行类型转换)

### 拓展
C++的早期实现就只是简单地执行了从C++到C的源到源的中转换，并对结果运行C编译器，产生目标代码。C++的对象用结构来表示，类似于C的struct。
- C++的方法是用指向实现方法的代码的指针来表示的．相比而言，Java的实现方式完全不同。
- Java的目标代码码是一种特殊的二进制表示，码是一种特殊的二进制表示，称为Java字节代码。这种代码可以看成是虚拟机的机器级程序。正如它的名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。
- 及时编译的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时（例如在循环中），这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行，而在本章谈到的机器代码只能在x86-64机器上运行。



# 处理器体系结构

## Y86-64指令集体系结构
定义一个指令集体系结构包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

### 程序员可见的状态

**程序员可见状态**：Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分，这称为程序员可见状态。
>这里的“程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。

只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照ISA暗示的方式来表示和组织这个处理器状态。

Y86-64的状态类似于x86-64
- 有15个程序寄存器。
	- 寄存器%rsp被人栈、出栈、调用和返回指令作为栈指针。
![[Pasted image 20230117162815.png]]
>省略了x86-64的寄存器15简化指令编码。四位标识一个寄存器的编码，一共能标识16个寄存器，但是要保留一个编码用于标识0xF，即无寄存器

- 有3个一位的条件码：ZF、SF和OF。它们保存着最近的算术或逻辑指令所造成影响的有关信息。
- 程序计数器（PC）存放当前正在执行指令的地址。
![[Pasted image 20230117163121.png]]
- 状态码stat，它表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常。

### Y86-64指令
Y86一64指令集基本上是x86一64指令集的一个子集。它只包括8字节整数操作，寻址方式较少，操作也较少。

Y86-64指令细节：
- x86-64的`movq`指令分成了4个不同的指令：`irmovq`、`rrmovq`、`mrmovq`和`rmmovq`。
![[Pasted image 20230117163658.png]]
- 有4个整数操作指令。分别是`addq`,`subq`,`andq`,`xorq`，只对寄存器数据进行操作。这些指令会设置3个条件码
- 7个跳转指令。jmp，jle，jl，je，jne，jge，jg。根据分支指令的类型和条件代码的设置来选择分支。
- 有6个条件传送指令，`cmovle`,`cmovl`,`cmove`,`cmovne`,`cmovge`,`cmovq`.这些指令的格式与寄存器一寄存器传送指令`rrmovq`一样,但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。
- c`all`指令将返回地址人栈，然后跳到目的地址。`ret`指令从这样的调用中返回。
- `pushq`和`popq`指令实现了人栈和出栈，就像在x86-64中一样。
- `halt`指令停止指令的执行。x86-64中有一个与之相当的指令`hlt`。x86-64的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于Y86-64来说，执行`halt`指令会导致处理器停止，并将状态码设置为`HLT`
![[Pasted image 20230117164338.png]]

### 指令编码
- 每条指令需要1~10个字节不等，这取决于需要哪些字段。
- 每条指令的**第一个字节表明指令的类型**。这个字节分为两个部分，每部分4位：高4位是*代码部分*，低4位是*功能部分。* 功能值只有在一组相关指令共用一个代码时才有用。
![[Pasted image 20230117164537.png]]

- 如果指令使用到寄存器，可能有附加的**寄存器指示符字节**(4个位)，指定一个或者两个寄存器。(1字节)
![[Pasted image 20230117164746.png]]
>从指令的汇编代码表示中可以看到，根据指令类型，指令可以指定用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。没有寄存器操作数的指令就没有寄存器指示符字节。如果只需要一个指令，另一个寄存器指示符设为0xF。（这就是15个寄存器的原因）

- 有些指令需要一个附加的4字节常数字，这个字能作为`irmovq`的立即数数据，rmmovq和mrmovq的地址指示符的偏移量，以及分支指令和调用指令的地址。
>注意，分支指令和调用指令的目的是一个绝对地址.

#### 例子
- 汇编
![[Pasted image 20230117165700.png]]

- 编码：40 42 cd ab 89 67 45 23 01 00.
	- `rmmovq`的编码为40
	- 寄存器编码为0x42
	- 偏移量占8字节，该偏移量补零，由于是[[#小端法]]存储，即存储顺序为cd ab 89 67 45 23 01 00.
![[Pasted image 20230117164746.png]]
![[Pasted image 20230117170022.png]]


### Y86-64异常
对Y86-64来说，程序员可见的状态包括状态码`Stat`，它描述程序执行的总体状态。
![[Pasted image 20230117170556.png]]
- 代码值1，程序正常执行
- 代码值2，表示处理器执行了一条停止指令(halt)
- 代码值3，表示程序正试图从非法地址读取数据或者向非法地址写入数据。表示处理器试图从一个非法内存地址读或者向一个非法内存地址写，可能是当取指令的时候，也可能是当读或者写数据的时候。
- 代码值4，表示程序遇到了非法指令

对于Y86-64当遇到这些异常的时候，我们就简单地让处理器停止执行指令。在更完整的设计中，处理器通常会调用一个**异常处理程序**，这个过程被指定用来处理遇到的某种类型的异常。

## 逻辑设计和硬件控制语言HCL
介绍硬件电路实现，看书吧P256

## Y86-64的顺序实现
我们描述一个称为**SEQ(顺序的)的处理器**，每个时钟周期上，SEQ执行处理一条完整指令所需的所有步骤。不过，这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。

### 将处理组织成阶段
指令的各个阶段：
- **取指令**：取指阶段从内存读取指令字节，地址为程序计数器（PC）的值。从指令中抽取出指令指示符字节的两个四位部分，称为icode（指令代码）和ifun（指令功能）
- **译码**：译码阶段从寄存器文件读人最多两个操作数。
- **执行**：在执行阶段，算术/逻辑单元（ALU）要么执行指令指明的操作（根据指令功能判断），计算内存引用的有效地址，要么增加或减少栈指针。也可能在此阶段设置条件码，
	- 对于条件传送指令：在此阶段回检验条件码和传送条件(由ifun给出)。
	- 对于跳转指令：这个阶段回决定是不是应该选择分支
- **访存**：访存阶段可以将数据写人内存，或者从内存读出数据。
- **写回**：写回阶段最多可以写两个结果到寄存器文件。
- **更新**：将PC设置成下一条指令的地址。

![[Pasted image 20230118155753.png]]
![[Pasted image 20230118162108.png]]

- 对于`opq`：包含整数操作指令(`addq`,`subq`,`andq`,`xorq`)，这些操作都有相同的指令代码值(`icode`)ALU根据指令功能(`ifun`)执行具体的操作。在执行阶段除了输出运算结果，还会根据结果来设置条件码寄存器(`set CC`)
- 对于`irmovq`：因为是长指令格式，对于`irmovq`，程序计数器必须加10。ALU的输出端口与寄存器的写入端口相连。
![[Pasted image 20230118160923.png]]
- 对于`rmmovq`：
	- `rmmovq %rsp,100(%rbx)`
	- `%rbc`是基址寄存器，100是偏移量，实际地址是100+R[%rbc]，这个过程由ALU进行计算。
	- ![[Pasted image 20230118161444.png]]

![[Pasted image 20230118162156.png]]
- `pushq`：
	- 译码阶段要读`%rsp`的值，因为`pushq`要将rA的值保存在栈(内存上)，获取`%rsp`之后就可以通过-8操作获取新栈顶的地址。
	- 访存阶段是将rA的值放在栈顶的位置。
	- 写回阶段：因为栈顶发生变化，所以要将栈顶地址返回给`%rsp`，更新寄存器的值域
- `popq`：
	- 译码阶段要读两次栈指针，目的是为了使得后面流程与`pushq`更相似
	- 执行阶段用ALU给栈指针加8，获取新栈顶地址，再用没加过8的原栈顶地址作为内存操作地址。
	- 在写回阶段用+8的栈顶地址更新栈指针寄存器，然后在内存操作地址上取值更新rA。

**ALU的作用**：
	- 执行算术操作和逻辑操作
	- 计算内存引用地址。(基址变址等)
	- 计算栈指针

![[Pasted image 20230118163645.png]]
除了不需要一个寄存器指示符字节以外，**跳转指令**在取指和译码阶段都和前面讲的其他指令类似。
- 在执行阶段：检查*条件码*和*跳转条件*来确定是否要选择分支，产生一个一位信号`cnd`
- 在更新阶段，检查这个标志，如果这个标志为1，就将设为`va1C`(跳转目标），如果为0，就设为`va1P`（下一条指令的地址）。
![[Pasted image 20230118164024.png]]

- `call`和`ret`指令：与`pushq`和`popq`类似
	- `call`指令：
		- 译码阶段从栈指针寄存器中取出栈顶的地址
		- 执行阶段，因为要压入下一跳地址，所以要计算出入栈后栈顶的值。
		- 访存阶段：将`call`指令后紧跟着的那条指令的地址压入栈中。
		- 写回阶段：这更新栈指针寄存器中栈顶的值。
		- 更新阶段将PC设为`va1C`，也就是调用的目的地。
	- `ret`指令：
		- 译码阶段：从栈指针寄存器中取出栈顶的地址作为访问内存的地址
		- 执行阶段：计算出出栈之后栈顶的新地址
		- 访存阶段：用访问内存地址，从内存中读取值
		- 写回阶段：更新栈指针的值
		- 更新PC阶段：从栈中取出的值，赋值给PC。

### SEQ硬件结构
![[Pasted image 20230122201340.png]]
![[Pasted image 20230128172630.png]]
硬件单元与各个处理阶段相关联。

#### 取指令
- **取指令：** 将程序计数器寄存器作为地址，指令内存读取指令的字节。PC增加器计算valP，即增加了程序计数器。
![[Pasted image 20230122203404.png]]
>取10字节是因为，Y86-64中一条指令最长为10字节。

- `icode`能判断当前指令是否合法，是否有常数，是否需要寄存器。通过icode可以获得当前指令的长度。
- `icode`设置`Need valC`或`Need regids`。如果为1则表示需要常数或寄存器。再从align中取出寄存器字段或常数字段。如果指令中不含寄存器，则寄存器操作符设置为0xF。

#### 译码
- **译码：** 寄存器文件有两个读端口A和B，从这两个端口同时读寄存器值va1A、vaIB。
![[Pasted image 20230122203756.png]]
某些指令需要用到栈指针寄存器`%rsp`所以需要指令代码`icode`读取寄存器数据
>如`pushq`,`popq``,call`,`ret`在译码阶段需要读取寄存器`%rsp`。

#### 执行
- **执行：** 执行阶段会根据指令的类型，将算术／逻辑单元（ALU）用于不同的目的。对整数操作，它要执行指令所指定的运算。对其他指令，它会作为一个加法器来计算增加或减少栈指针，或者计算有效地址，或者只是简单地加0，将一个输入传递到输出。
	- ALU负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。同样，当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号cnd。

![[Pasted image 20230122204338.png]]
- ALU每次运行时，都会产生三个与**条件码**相关的信号——零、符号、溢出。
- ALU在执行算数逻辑指令时才会设置条件吗。
- Set_CC会根据指令代码`icode`来控制是否要更新条件码寄存器。
- 对于跳转指令，
	- cnd=1，跳转
	- cnd=0，不执行跳转

#### 访存
- **访存：** 在执行访存操作时，数据内存读出或写人一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。
 ![[Pasted image 20230122204512.png]]
 访存阶段会根`instr_valid,imem_erroe,dmem_error`计算状态码`Stat`

#### 写回
- **写回：** 寄存器文件有两个写端口。
	- *端口E*用来写ALU计算出来的值，
	- *端口M*用来写从数据内存中读出的值。
![[Pasted image 20230122204657.png]]
- 当执行条件传送指令(`cmov`)时，写入操作需要根据执行阶段计算出的cnd信号。
	- cnd=0，不满足条件时，可以将目的寄存器设置为0xF来禁止写入寄存器文件。

#### 更新PC值
- **PC更新：** 程序计数器的新值选择自：
	- valP，下一条指令的地址,即当前PC的值加上当前指令的长度。
	- valC，调用指令或跳转指令指定的目标地址，即指令的常数字段(`call`,`jxx`)
	- valM，从内存读取的返回地址。(`ret`)



### SEQ的时序
SEQ的实现包括**组合逻辑**和两种存储器设备：
- 两种存储设备：
	- 时钟寄存器。(程序计数器和条件码寄存器)、
	- 随机访问存储器(寄存器文件、指令内存、数据内存)
- 组合逻辑不需要任何时序或控制，只要输入变化，值就通过逻辑门网络传播。

每个时钟周期，程序计数器都会装载新的指令地址。
	- 对于条件码；只有在执行整数运算指令时，才会装载条件码寄存器。
	- 对于数据内存：只有在执行`rmmovq`、`pushq`、`call`指令时，才会写数据内存

当时钟上升开始时，会更新**程序计数器**、**寄存器文件**和**条件码寄存器**。

### SEQ的的缺点
SEQ唯一的问题就是它**太慢**了。时钟必须非常慢，以使信号能在一个周期内传播所
有的阶段。


## 流水线的通用原理

### 计算流水线
**延迟：** 从头到尾执行一条指令所需的时间。

![[Pasted image 20230122214818.png]]
在现代逻辑设计中，电路延迟以微微秒或皮秒，也就是$2^{12}$。
- **吞吐量**量为：
![[Pasted image 20230122215051.png]]
![[Pasted image 20230122215901.png]]
**GIPS：** 表示每秒千兆条指令，也就是每秒十亿条指令。
- 延迟为：320
>![[Pasted image 20230122215225.png]]


**引入三阶段流水线(理想流水线)**，假设每个阶段需要$100ps$.
![[Pasted image 20230122215358.png]]
将时钟周期设置为120ps。
- **吞吐量**为：$1s/120ps≈8.33GIPS$
- **延迟**为：$3*120=360ps$
- **结论：** 吞吐量提高到原来的2.67倍，代价是增加了硬件，以及延迟的少量增加(360/320)=1.12

### 流水线操作的详细说明
当**时钟上升**时，这些输人被加载到流水线寄存器中，成为寄存器的输出。

- **如果始终运行的太快：** 可能会来不及通过组合逻辑，因此当时钟上升时，寄存器的输人还不是合法的值。

随着时钟周而复始地上升和下降，不同的指令就会通过流水线的各个阶段，不会相互干扰。

### 流水线的局限性
![[Pasted image 20230122220712.png]]
![[Pasted image 20230122220732.png]]

#### 不一致的划分
理想的流水线是划分的每个阶段的时间都相等。
如果各个阶段所需时间不同，那么需要使得各个阶段执行的时间和最长的时间相等，以保证长阶段能够顺利执行。
![[Pasted image 20230122220939.png]]
通常，处理器中的某些硬件单元，如ALU和内存，是不能被划分成多个延迟较小的单元的。这就使得创建一组平衡的阶段非常困难。

#### 流水线过深，收益反而下降
![[Pasted image 20230122221527.png]]
六级流水线的吞吐量是14.29比理想化三级流水线提升了1.71倍。

**过深的流水线会导致系统性能的下降。**


### 带反馈的流水线系统

实际上，相邻指令可能是相关的，下一条指令的操作数可能需要上一条指令得到。

- **数据相关**

![[Pasted image 20230122221953.png]]
以上三条指令，相邻指令之间都有**数据相关**。

- **顺序相关**
![[Pasted image 20230122222103.png]]
以上指令是由控制流造成的**顺序相关**，执行`jne`指令之后根据条件测试结果，下一条指令可能是第七行的指令也可能是第四行的指令。

**SEQ**中的**解决方案**：
通过反馈路径，将更新了的寄存器值向下传到寄存器文件，将心的PC值向下传送到PC寄存器。
![[Pasted image 20230122222438.png]]
**对于以上利用反馈改变系统的行为其实是不可接受的。**


## 4.5 Y86-64的流水线实现
Y86-64流水线的实现需要对SEQ处理器进行一点小的改动：
- 将PC的计算挪到取指阶段。
- 在各个阶段之间，之间加上流水线寄存器。

### 4.5.1 SEQ+：重新安排计算阶段
- SEQ+：更新PC阶段在一个时钟周期开始时执行，而不是结束时才执行。

发生在不同阶段计算PC的操作：
- 当PC计算发生在时钟周期结束时：根据当前时钟周期内计算出的信号值来计算PC寄存器的新值。
![[Pasted image 20230128173708.png]]
- **当PC计算发生在时钟周期开始时：** 创建状态寄存器来保存在一条指令执行过程中计算出的信号，当一个新时钟开始时，这些信号通过同样的逻辑来计算当前指令的PC。(它们保存的是前一个周期中产生的信号)
![[Pasted image 20230128173845.png]]
- 一条指令执行过程如下图：
![[Pasted image 20230128172828.png]]

- **电路重定时**：重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段之间的延迟。PC阶段的改变称为电路重定时。

### 4.5.2 插入流水线寄存器

![[Pasted image 20230128175415.png]]

![[Pasted image 20230128173117.png]]

**流水线寄存器可以存放多个字节和字。**
以下介绍的流水结构存在一些缺陷**即一条指令执行的各个阶段。**

#### 插入流水线：取指
![[取指令阶段.gif]]
- 寄存器F：保存**程序计数器的预测值**。
- 取指令：与顺序结构的[[#取指令]]类似。
- Predict PC：PC增加器计算出的valP和取出的指令中得到的valC中进行选择。
- Select PC：从三个值中选择一个作为指令内存的地址：
	- 预测的PC
	- 对于到达流水线寄存器M的的选择分支的指令来说是valP的值。(存储在寄存器M_valA中)。
	- 当ret指令到达流水线寄存器W(存储在w_valM)时的返回地址的值。


#### 插入流水线：译码
![[译码阶段.gif]]
- D：位于取指和译码阶段之间。它**保存关于最新取出的指令的信息**，即将由译码阶段进行处理。
>例如，指令代码、指令功能、寄存器指示符等。

#### 插入流水线：执行
![[执行阶段.gif]]
- E：位于译码和执行阶段之间。它保存关于**最新译码的指令和从寄存器文件读出的值的信息**，即将由执行阶段进行处理。
- **Select A**：这个块会从来自流水线寄存器D的valP或从寄存器文件端口A中读出的值中选择一个，作为流水线寄存器E的值ValA
	- 作用：减少要携带给流水线寄存器E和M的状态数量。只有在跳转指令的阶段需要valP的值而跳转指令又不需要从寄存器文件中读出值，因此合并则两个信号从而可以**减少流水线寄存器的状态数量。**

在硬件设计中，过合并信号来减少寄存器状态和线路的数量，是很常见的。

#### 插入流水线：访存
![[执行阶段阶段.gif]]
- M：位于执行和访存阶段之间。它保存最新执行的指令的结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。

#### 插入流水线：写回
![[访存阶段.gif]]
- W：位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成ret指令时，它还要向PC选择逻辑提供返回地址。

#### 指令的执行情况
![[Pasted image 20230128201200.png]]
- **横着看**：流水线一行是一条指令，第一行执行第一条指令的五个阶段，第二行执行第二条指令的五个阶段，以此类推。
- **竖着看**：一列是一个时钟周期，同一时刻，不同指令的不同阶段。周期5，流水线中执行者五条指令的五个阶段。所有流水线寄存器都被使用。每一个周期都有一条指令进入流水线。

### 4.5.3 对信号进行重新排序和标号
在系统中存在多条指令进行流水线操作时，同一时刻进行着多条指令的不同阶段，因此在不同阶段的流水线寄存器保存着相同信号的不同版本的值。
例如，在下图中 D、E、M、W中均有stat信号，它们可能保存着4条不同指令的状态码。
![[Pasted image 20230128195524.png]]

**为了避免将一条指令计算出的结果存放到错误的寄存器中。我们采用命名机制：**
- 流水线寄存器M的状态码字段：在信号名前面加上大写的流水线寄存器名字作为前缀。即D_stat、E_stat、M_stat、W_stat。
- 在一个阶段内刚计算出来的信号表示为：f_stat、e_stat、m_stat、w_stat

- destE和destM指明值ValE和valM的目的寄存器。
- srcA和srcB指明读取的寄存器编号。


### 4.5.4 预测下一个PC
每个时钟周期都有一条新指令进人执行阶段并最终完成。要是达到这个目的也就意味着吞吐量是每个时钟周期一条指令。
- 对于除了转移指令和ret指令之外，根据取自阶段中上一条指令产生的信号可以确定下一条指令的地址。
- 对于条件转移指令和ret指令：要到几个周期后，也就是指令通过执行阶段之后，我们才能知道是否要选择分支；对于ret指令要到指令通过访存阶段，才能确定返回地址。
	- 对于`call`和`jmp`(无条件转移)来说，下一条指令是指令中的参数字段ValC，而对于其他指令来说就是valP

- **分支预测**：猜测分支方向并根据猜测开始取指的技术称为分支预测。
>在SEQ设计中，我们总是预测选择了条件分支，因而预测PC的新值为va1C。
>分支预测错误会极大地降低程序的性能，因此这就促使我们在可能的时候，要使用条件数据传送而不是条件控制转移。


### 4.5.5 流水线冒险
当相邻指令间存在相关时会导致出现问题。这些相关有两种形式：
- **数据相关：** 下一条指令会用到这一条指令计算出的结果。
>判断数据相关：译码阶段的指令在读取寄存器的ID与不同指令的各个阶段执行指令的目的寄存器进行对比。存在ID相同，则说明存在数据相关。
- **控制相关：** 一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时。

#### 数据冒险
如果一条指令的操作数被它前面三条指令中的任意一条改变的话，都会出现数据冒险之所以会出现这些冒险，是因为我们的流水线化的处理器是在译码阶段从寄存器文件中读取指令的操作数，而寄存器文件的更新需要经过协会阶段，也就是说下一条指令在取值的时候上一条指令还没更新寄存器。

##### 避免数据冒险：使用暂停
暂停是避免冒险的一种常用技术。
暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足。**让一条指令停顿在译码阶段**，直到产生它的源操作数的指令通过了写回阶段，这样我们的处理器就能避免数据冒险。

- **暂停方法：** 插入气泡。气泡就像一个自动产生的`nop`指令——它不会改变寄存器、内存、条件码或程序状态。
![[Pasted image 20230128213734.png]]
>插入气泡，使得`addq`指令在前条指令写回之后，才开始译码。

- **暂停的缺点：** 一条指令要使用上一条指令的执行结果是常见的，对所有指令都进行暂停会严重降低流水线整体的吞吐量。

##### 避免数据冒险：使用转发
**数据转发：** 结果值直接从一个流水线阶段传到较早阶段的技术，也叫**旁路**。

![[Pasted image 20230128220638.png]]
![[旁路技术.gif]]
- Sel+FwdA：是Select A块功能与转发逻辑的结合。允许流水线寄存器E的va1A为已增加的程序计数器值valP、从寄存器文件A端口读出的值，或者某个转发过来的值。
- Fwd B：实现的是源操作数va1B的转发逻辑。

>在每除了译码和取指的每一个阶段产生的数据都有一条通路，连接到Fwd B，使得某条指令在译码阶段就能获取其他指令在其他阶段对寄存器的改变。

##### 避免数据冒险：使用暂停+转发
- 加载/使用数据冒险：
![[Pasted image 20230128221837.png]]
- 在周期8读内存之前，下一条指令就需要周期8 M阶段的读取结果，该问题不能使用单纯的转发或者暂停来解决。


- **解决方法：** 我们可以将**暂停**+**转发**结合起来，避免加载/使用数据冒险。
![[Pasted image 20230128222233.png]]
- 将`addq`指令暂停一个周期，`addq`的D阶段与上一条指令的取自阶段处于同一周期，再使用旁路技术，获取上一条指令访存后的值。


#### 控制冒险
- 当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险
- 控制冒险只会发生在 **`ret`指令和跳转指令。**
	- `ret`指令，下一条指令必须在上一条指令栈中返回之后才可以获取下一条指令的地址，也就是需要上一条指令经过访存和写回阶段，才可以获取下一条指令的地址。
	- 跳转指令`jxx`：跳转指令，每次我们采取的策略都是走跳转的指令。当预测错误后，我们就需要采取相应的处理。

- `ret`指令例子：
![[Pasted image 20230129170941.png]]
![[Pasted image 20230129170932.png]]
执行无条件跳转指令之后，将执行`ret`指令再执行`irmovq`指令。但是在`ret`指令还没写回前，我们无法获取`irmovq`指令的地址，持续就需要**插入气泡**暂停流水线，等`ret`指令到达写回阶段，PC选择逻辑就会将程序计数器设为返回地址，然后取指阶段就会取出位于返回点的`irmovq`指令。


- 分支预测错误例子：
![[Pasted image 20230129171347.png]]
![[Pasted image 20230129171709.png]]
在周期3，预测跳转指令会选择分支进行跳转，所以周期3中取出位于跳转目标初的指令。
在周期4，会取出该指令后的那条指令。而分支逻辑发现不应该选择分支之前，已经取出了两条指令，它们不应该继续执行下去了。这两条错误执行的指令还没进入到执行阶段，不会改变程序员可见状态，条件码还未改变。我们只需要阻断这两条指令的继续执行即可。
在周期5给，两条错误的指令执行气泡，开始执行跳转指令后面的指令。

**缺点：** 浪费了两个时钟周期。正确指令因为预测错误晚了两个周期才执行。


### 4.5.6 异常处理
我们的指令集体系结构包括三种不同的内部产生的异常：
1. `halt`指令
2. 有非法指令和功能码组合的指令。
3. 取指或数据读写视图访问一个非法地址。

**异常指令：** 致异常的指令。

当流水线系统中多条指令发生异常时，**由流水线中最深的指令引起的异常优先级最高。**

在一个流水化系统中可能出现的异常处理问题的细节：’
1. 取之后发生了一个异常，但是后面由于分支预测错误该指令取消。
2. 流水线化的处理器会在不同的阶段更新系统状态的不同。后面的指令在异常指令完成之前就改变了流水线寄存器的部分状态。

**处理异常的简单机制：** 流水线寄存器中携带状态码`stat`。如果一条指令在其处理中于某个阶段产生了一个异常，这个状态字段就被设置成指示异常的种类。异常状态和该指令的其他信息一起沿着流水线传播，直到它**到达写回阶段**。在此，流水线控制逻辑发现
出现了异常，并**停止执行**。
- 根据异常值stat，可以使得在异常发生之后的指令不得改变程序员可见状态(条件寄存器和内存)
- 如果取出了某条指令，过后又取消了，那么所有关于这条指令的异常状态信息也都会被取消。


### 4.5.7 PIPE各阶段的实现

设计HCL看书去吧P308

### 4.5.8 流水线控制逻辑

