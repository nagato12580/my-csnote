# 初识CPP

## 初始输入输出

C++并未定义任何输入输出（IO）语句，取而代之，包含了一个全面的**标准库**（standardlibrary）来**提供IO机制**（以及很多其他设施）。
/
### iostream库

- iostram库包含**2个基础类型**。分别是istream和ostream。
	- **istream：** 输入流
	- **ostream：** 输出流

* iostream定义**4个IO对象**。
	* cin：标准输入
	* cout：标准输出
	* cerr：输出警告和错误信息
	* clog：输出程序运行时的一般信息

#### 向流写入数据

- <<：输出运算符。接收两个运算对象：**左侧**运算对象必须是一个**ostream对象**。**右侧**运算对象是要**打印的值**。此运算符将给定的值写到给定的ostream对象中。**输出运算符的计算结果就是其左侧运算对象。** 即，计算结果就是我们写入给定值的那个对象ostream对象。
```c++
std::cout<<"hello,world!"<<std::endl;
/*
	使用了两次<<运算符，第一个<<运算符返回ostream对象，作为第二个<<运算符的左侧ostream对象。
*/
//等价于
(std::cout<<"hello,world!")<<std::endl;
//等价于
std::cout<<"hello,world!";
std::cout<<std::endl;
```

==**endl:** 是一个被称为操纵符(manipulator)的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。==

- >>：输入运算符。接收两个运算对象：**左侧**运算对象必须是一个**istream对象**。接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。与输出运算符类似，输入运算符返回其左侧运算对象作为其计算结果。因
```c++
int v1,v2;
std::cin>>v1>>v2;
/*
	使用了两次>>运算符，读入两个值，第一个值存于v1第二个存于v2
*/
//等价于
std::cout>>v1;
std::cout>>v2;
```


## 注释简介

- 单行注释：//
- 多行注释：/*   * */

==注释界定符不能嵌套==
界定符对形式的注释是以[/*]开始，以[*/]结束的。因此，一个注释不能嵌套在另一个注释之内。编译器对这类问题所给出的错误信息可能是难以理解、令人迷惑的.

## 控制流

### while语句
```c++
#include<iostream>
int main()
{
	int v = 50;
	int sum = 0;
	while (v <= 100) {
		sum += v;
		v++;
	}
	std::cout << "sum is :" << sum << std::endl;
	retun 0;
}
```

### for语句
```c++
#include<iostream>
int main()
{
	int sum = 0;
	for (int i = 50; i <= 100; i++) {
		sum += i;
	}
	std::cout << "sum is :" << sum << std::endl;
	return 0;
}
```

### 读取数量不定的输入数据

读取数据到文件末尾，计算所有读入的值的和
```c++
#include<iostream>
int main()
{
	int sum = 0, value = 0;
	while (std::cin >> value) {
		sum += value;
	}
	std::cout << "sum is :" << sum << std::endl;
	return 0;
}
```

**std::cin >> value：** 此表达式从标准输入读取下一个数，保存在value中。输入运算符返回其左侧运算对象，在本例中是`std::cin`。因此，此循环条件实际上检测的是`std::cin`。

当我们使用一个**istream对象作为条件**时，其效果是**检测流的状态**。如果流是有效的，即流未遇到错误，那么检测成功。当遇到**文件结束符**（end-of-file），或遇到一个**无效输入**时（例如读入的值不是一个整数），**istream对象的状态会变为无效**。**处于无效状态的istream对象会使条件变为假**。

==因此，我们的while循环会一直执行直至遇到文件结束符（或输入错误）。==

### if语句
我们可以用`if`语句写一个程序，来统计在输入中每个值连续出现了多少次：
```c++
#include<iostream>
int main()
{
	int currVal=0, value = 0;//currVal是当前正在统计的数，value是实时读入的数值
	if (std::cin >> currVal) {
		int count = 1;//保证我们正在处理的当前值的个数
		while (std::cin >> value) {//读取剩余的数
			if (currVal == value) {//值相同，count+1
				++count;
			}
			else {
				//值不同，打印当前统计值的个数
				std::cout << currVal << "is " << count << std::endl;
				//记住新统计值
				currVal = value;
				//重置计数器
				count = 1;
			}
		}
		//记住打印文件中最后一个值的个数
		std::cout << currVal << "is" << count << std::endl;
	}
	return 0;
}
```


### 类简介

在C++中，我们通过定义一个**类(class)** 来定义自己的**数据结构**。一个类定义了一个**类型**，以及与其关联的**一组操作**。类机制是cc++最重要的特性之一。实际上，c++最初的一个设计住点就是能定义使用上像内置类型一样自然的类类型（classtype）。

自定义类别一般写在头文件中，头文件根据其中定义的类的名称来明明。通常为.h后缀。

#### Sales_item类

**作用：** 表示一本书的总销售额、售出册数和平均售价。

每一个类实际上都是一个新的类型，其类名就是类型名，Sales_item类定义了一个名为Sales_item的类型。
```c++
//创建一个Sales_item类对象
Sales_item item;
```

除了可以定义Sales_item类型的对象之外，我们还可以：
- 调用一个名为isbn的函数从一个sales对象中提取ISBN书号。
- 用输入运算符（>>）和输出运算符（<<）读、写sales_item类型的对象。
- 用赋值运算符（=）将一个sales_item对象的值赋予另一个sales_item对象。
- 用加法运算符（+）将两个sales_item对象相加。两个对象必须表示同一本书（相同的ISBN)。加法结果是一个新的Sa1esitem对象，其ISBN与两个运算对象相同，而其总销售额和售出册数则是两个运算对象的对应值之和。
- 使用复合赋值运算符（+=）将一个sales_item对象加到另一个对象上。

==对于不属于标准库的头文件，采用双引号引用,，放置于工作目录中==

##### 成员函数

```c++
item1.isbn()
```
调用名为isbn的成员函数（memberfunction）。成员函数是定义为类的一部分的函数，有时也被称为方法（method）。


##### . 运算符
使用点运算符 **(.)** 来表达我们需要“名为iteml的对象的isbn成员”。点运算符**只能用于类类型的对象**。其**左侧**运算对象必须是一个**类类型的对象**，**右侧**运算对象必须是该类型的一个**成员名**，运算结果为右侧运算对象指定的成员。


# C++基础：变量和基本类型

## 基本内置类型

C++定义了一套包括算术类型（arithmetictype）和空类型（void）。

- **算数类型：** 字符、整型、布尔值、浮点数
- **空类型：** 不对应具体的值，仅用于特殊场合。（函数返回类型）

### 算术类型

分为两类，**整型** （包含整型、字符、布尔类型）和**浮点型** 。

![[../T_Box/附件/Pasted image 20221213114338.png]]

**其中，基本字符类型是char** ，一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，的大小和一个机器字节一样。

>除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。c++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。其中，数据类型long long是在C++11中新定义的。

大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节（byte）"，==存储的基本单元称为“[[CSAPP#字|字]]”，它通常由几个字节组成。
在C++语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，**字则由32或64比特构成，也就是4或8字节。**

#### 有符号类型和无符号类型

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号的（signed）** 和**无符号的（unsigned)** 两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。

字符类型被分为三种：**char**、**signed char** 、**unsigned char**
==类型char和类型signed char并不一样。==类型char实际上会表现为上述其他两种形式中的一种，具体是哪种由编译器决定。

- **无符号类型：** 中所有比特都用来存储值，例如，8比特的unsigned char可以表示0至255区间内的值。
-  **有符号类型：** 8比特的signed char理论上应该可以表示一127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。


### 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被人多数类型支持，就是将对象从一种给定的类型转换（convert）为另一种相关类型。

#### 自动类型转换
当在程序中使用一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。
```c++
bool b = 42; // b 为真

int i = b; // i 的值为1

i = 3.14; // i 的值为3

double pi = i; // pi 的值为 3.0

unsigned char c = -1; // 假设 char 占8bit， c 的值为255

signed char c2 = 256; // 假设 char 占8bit, c2 的值是为未定义的
```

- 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。（223行）
- 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。（225行）
- **当我们赋给无符号类型一个超出它表示范围的值时，** ，即将[[CSAPP#^7beffc|有符号数转换为无符号数]]。例如，8比特大小的*unsignedchar可以表示0至255区间* 内的值，如果我们赋了一个区间以外的值如-1，则**需要把该数转无符号数**因此，把-1赋给8比特大小的unsignedchar所得的结果是255（-1+256）。（227行） ^f688b2
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。（229行）

##### 含有无符号类型的表达式

```c++
unsigned u=10;
int i=-42;
std::cout<<i+i<<std::endl;//输出84
std::cout<<u+i<<std::endl;//如果int占32位，则输出4294967264
```
 **分析：** 
 int和无符号数相加时，int值会转换成无符号数，也就是把int赋值给一个无符号数变量。
 在本题中假设-42被赋值给无符号int，一个int占32位，则无符号数表示范围为0~4,294,967,296，根据[[#^f688b2|有符号数转换为无符号数的方法]] ，则-42+4,294,967,296，结果为4,294,967,254，与u相加，输出结果4294967264。


```c++
unsigned u1=42，u2=10;
std::<<u1-u2<<std::endl;//输出32
std::<<u2-u1<<std::endl;//输出取模之后的结果，因为无符号数无法表示负数，输出-32对4,294,967,296取模的结果，即4,294,967,264
```


### 字面值常量

#### 定义
一个形如42的值被称作字面值常量（literal)。

#### 整型和浮点型的字面值

*例子：* 20的十进制数、八进制数、十六进制数分别为。
| 十进制 | 八进制 | 十六进制 |
| ------ | ------ | -------- |
| 20     | 024    | 0x14         |

**注意：** 默认情况下，十进制字面值是带符号数，*八进制和十六进制数* 值既可能是带符号的也*可能是无符号* 的。

>十进制字面值的类型是int、long和long long中尺寸最小的那个。
>八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中尺寸最小者。
>如果一个字面值与之关联的最大的数据类型都放不下将产生错误。
>short没有对应的字面值。

*如果我们使用了一个形如-42的十进制字面值，那么这个符号并不在字面值之内，它的作用仅仅是对字面值取负值而已。*


#### 字符和字符串的字面值

- *char型字面值：*  单引号括起来的**一个字符**
- *字符串型字面值：*  双引号括起来的**零个或多个字符** 。字符串字面值的类型实际上是由**常量字符构成的数组**(array)
```c++
'a'//字符字面值
"hello,worl!"//字符串字面值
```

>编译器在每个字符串的结尾处添加一个空字符@\00因此，字符串字面值的实际长度要比它的内容多1。例如，字面值'A'表示的就是单独的字符A，而**字符串"A"** 则代表了一个字符的数组，该数组**包含两个字符**：一个是字母A、另一个是空字符。


#### 指定字面值类型
![[../T_Box/附件/Pasted image 20221215160532.png]]
```c++
L'a' // 宽字符型字面值，类型是 wchar_t 
u8"hi!" // utf-8 字符串字面值 
42ULL // 无符号整型字面值，类型是 unsigned long long 
1E-3F // 单精度浮点型字面值，类型是 float 
3.14159L // 扩展精度浮点类型字面值，类型是 long double
```

>以u十六进制数都将从unsigned int、unsigned long和unsigned longlong中选择能匹配的空间最小的一个作为其数据类型。如果后缀中有L，则字面值的类型至少是long；
>如果后缀中有LL，则字面值的类型将是longlong和unsignedlonglong中的一种。
显然我们可以将U与或合在一起使用。例如，以UL为后缀的字面值的数据类型将根据具体数值情况或者unsigned long，或者取unsigned long long。


#### 布尔字面值和指针字面值

**true和false** 是布尔类型的字面值。
**nullptr**是指针字面值。



## 变量

**变量提供一个具名的、可供程序操作的存储空间。**


### 变量定义
变量定义的基本形式是：首先是**类型说明符**（typespecifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。

>`string` 在命名空间`std`中定义，是一种表示可变长字符序列的数据类型。

### 变量初始化
**变量初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。**
```c++
int val = 1; 
int val = {0}; 
int val{0}; 
int val(0);
```

#### 列表初始化

*使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。*
```c++
int val = {0}; 
int val{0}; 
long double ld=3.1415926536;
int a{ld},b={ld};//报错，转换未执行，因为存在信息丢失的危险（double转int，精度变小）
int c{ld},d=ld;//正确，//转换正确，ld使用=转换成int类型，丢失精度，再用列表初始化
```


#### 默认初始化

定义变量时没有初始化变量的值，则变量会被默认初始化。默认初始化的值取决于变量定义的类型。**定义在函数体内的局部变量和类中的成员属性是不会被初始化的** （不同编译器的实现可能会不同）， 所以不用试图使用任何方式去访问这些变量。


### 变量声明和变量定义的关系

**声明：** 声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。*一条声明语句由一个基本数据类型（basetype）和紧随其后的一个声明符（declarator）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关。  ^31450e

**定义：** 负责创建与名字关联的实体。

**定义还申请存储空间，也可能会为变量赋一个初始值。**

**变量能且只能被定义一次，但是可以被多次声明。**

#### 关键字 extern
声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量。

```c++
extern int i;//声明i而非定义i（没有申请空间）
int j;//声明并且定义j
```
**在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。**


### 标识符

C++的标识符(ldentifier)由字母、数字和下画线组成，其中必须以字母或下画线开头，但是对大小写字母敏感。

### 变量命名规范

普通的局部变量和函数参数名使用小驼峰（第一个单词首字母小写，其他单词首字母大写）， 例： userName  

- 全局变量前加 g_, 后面的按小驼峰规则 ， g_userName  
- 静态变量前加 s_ , 后面按小驼峰规则， s_userName  
- 类名使用大驼峰，所有单词的首字母大写 ,  UserManage  
- 类属性（成员变量）前面加 m_ ,后面按小驼峰规则  ， m_userName  
- 常量全部使用大写，多个单词用_ 分割， MAX_NUMBER

### c++中的关键字

![[../T_Box/附件/Pasted image 20221215171951.png]]


### 变量名的作用域

作用域（scope）是程序的一部分，在其中名字有其特定的含义。c++语言中大多数作用域都以花括号分隔。

**局部变量不能和全局的变量重名，嵌套的块，内部的不要和外部的重名。重名的变量采取就近原则。**



## 复合类型

复合类型（compoundtype）是指**基于其他类型定义**的类型。C++语言有几种复合类型，**引用和指针。**

### 引用

引用(reference)为对象**起别名**，引用类型引用（refers(o)另外一种类型。必须以&开头。引用一旦定义指向对象不能更改是顶层`const`。

```c++
int ival=1024;
int &refVal = ival;//refVal指向ival（是iVal的别名，指向同一个数据）
```

**引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。**

*注意：*
1. 引用必须初始化，且不能改变  
2. `&` 符号可以紧靠基本类型(`int`), 也可以紧靠变量名  
3. 引用绑定的对象类型必须和引用类型是一致的


### 指针

指针（pointer）是“**指向（pointto）”** 另外一种类型的复合类型。
*指针本身就是一个对象，允许对指针进行赋值和拷贝，且在其生命周期内可以向后指向不同的对象，在初始化时可以不必赋初值。*

#### 定义指针


```c++
//定义指针
int *ip1,*ip2；//指向int类型的指针。
double dp,*dp2;//dp2是指double类型的指针，dp是double对象。
```

**指针以对象地址赋值**

#### 获取对象地址
```c++
//获取某个对象的地址
int ival=42;
int *p=&ival;//p存放变量ival的地址，或者所p是指向变量val的指针。
```

**指针的类型必须和指向对象的类型相同**

#### 指针的值

*指针的值（即地址）应属下列4种状态之一：*
1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。*没有指向具体对象，对其操作后后果无法预计*
3. 空指针，意味着指针没有指向任何对象。*没有指向具体对象，对其操作后后果无法预计*
4. 无效指针，也就是上述情况之外的其他值。*试图拷贝或以其他方式访问无效指针的值都将引发错误。*

#### 利用指针（解引用符）访问对象

在指针已经有指向对象时，使用解引用符 **（操作符`*`）** 来访问该对象。
```c++
int ival = 42; 
int * p = &ival; 
cout << *p; // 由符号 * 得到指针p所指向的对象，输出 42 


*p = 0; // 由符号 * 得到指针p所指向的对象即变量ival，即可经由p为变量ival赋值 
cout << *p; // 输出0
```
**为* p 赋值实际上是为P所指的对象赋值。**

**解引用操作仅适用于那些确实指向了某个对象的有效指针。**


#### 空指针

空指针(nullpointer)不指向任何对象，**在试图使用一个指针之前代码可以首先检查是否为空。** 

*生成空指针的方法*
```c++
int *p1=nullptr;   //等价于 int *p1=0;
int *p2=0;      //直接将p2初始化为字面常量0

// 需要首先 #include <cstdlib>
int *p3 = NULL; // 等价于 int *p3 = 0;
//NULL在头文件cstdlib中定义，它的值就是0。

```
**空指针最直接的办法就是用字面值nullptr来初始化指针。** 
>nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。

>预处理器运行于编译过程之前的一段程序。预处理变量不属于命名空间`std`，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前曲加上`std::`。当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用`NULL`初始化指针和用0初始化指针是一样的。

**注意：** 把`int`变量直接赋给指针是错误的操作，即使`int`变量的值恰好等于0也不行。

**指针必须初始化，尽量等确定了指向的对象之后再定义指针，或者直接初始化为nullptr**


#### 指针和赋值
```c++
int i = 42;

int *pi = 0; // pi被初始化，但没有指向任何对象

int *pi2 = &i; // pi2 被初始化，存有i的地址

int *pi3; // 如果 pi3 定义于块内，则pi3的值是无法确定的

  

pi3 = pi2; // pi3和pi2指向同一个对象

pi2 = 0; // 现在pi2不执行任何对象,指针对象改变。
```

**给 `*pi`赋值代表改变指针指向对象的值，给`pi`赋值代表改变指针指向的对象。**


##### 改变指向对象
```c++
pi=&ival;//pi的值被改变，现在pi指向对象ival
```

##### 指针赋值
```c++
*pi=0;//指针指向的对象ival被改变，指针pi并没有改变，还是指向ival
```


#### 其他指针操作

对于两个类型相同的合法指针，可以用相等操作符（`=`）或不相等操作符（`!=`）来比较。
```c++
int ival = 1024; 
int *pi = 0; // pi 合法，是一个空指针 
int *pi2 = &ival; // pi2是一个合法的指针，存放着ival的地址 
if (pi) // pi 的值是0，条件的值为false 
// ... 
if (pi2) // pi2 指向ival，它的值不为0， 条件的值是true 
// ...
```


#### void* 指针

**void* 是一种特殊的指针类型，可用于存放任意对象的地址。**
它所存放的地址就仅仅是内存空间的一个地址，因为没有指定具体对象的类型，所以无法用 void* 指针访问所指向的地址。

```c++
double obj = 3.14, *pd = &obj; 
// 正确： void* 能存放任意类型对象的地址 
void *pv = &obj; // obj 可以是任意类型的对象 
pv = pd; // pv 可以存放任意类型的指针
```

### &和 * 的多重含义

&和* 操作符，可以是表达式的运算符，也可以是变量声明的一部分，根据上下文判断。

```c++
int i=42;
int &r=i;//&紧随类型名出现，因此是声明的一部分，r是一个引用
int *p;//* 紧随类型名出现，因此是声明的一部分，p是一个指针
p=&i;//&出现在表达式中，是一个取地址符
*p=i;//*出现在表达式中，是一个解引用符
int &r2=*p;//&是声明的一部分，*是一个解引用符
```



### 指针和引用的区别和联系


#### 联系
1. 均是对其他对象的间接访问

#### 区别
1. 指针本身就是一个对象，允许对指针进行赋值和拷贝，且在其生命周期内可以先后指向不同的对象。引用的对象不能改变。
2. 指针无需在定义时赋初值，引用必须在定义时指向一个变量。
3. 指针在作用域内，如果没有被初始化将会拥有一个不确定的值域。


### 理解复合类型的声明

一条定义语句可能定义出不同类型的变量。
```c++
//i是一个int类型的数，p是一个int类型指针，r是一个int型引用
int i=1024，*p=&i，&r=i;

```
* * 和&是[[#^31450e|声明符]]（变量名)的一部分 
* * 仅仅是修饰了变量名而己


#### 定义多个变量

```c++
int *pi,*p2,p3;
//pi和p2都是指向int修饰符的指针，p3是int类型变量
```

#### 指向指针的的指针
指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。
**指向指针的指针实质上就是指针中保存了另一个指针的地址。**

*通过 * 的个数可以区分指针的级别。也就是说 ** 表示指向指针的指针， *** 表示指向指针的指针的指针，以此类推*
```c++
int ival=1024;
int *pi=&ival;//指向ival的指针
int **ppi=&pi;//指向pi的指针，pi是一个int型指针。
```
![[../T_Box/附件/Pasted image 20221215193000.png]]
解引用int型指针会得到一个int型的数（利用操作符*），同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用：
```c++
/*解引用示例*/

*pi //得到ival的值
*ppi //得到pi指针（由于ppi保存的是指针pi的地址）

//由于*ppi是指针pi，所以还可以继续解引用，获取到指针pi指向的对象ival
**ppi=*(*ppi)
```


#### 指向指针的引用

[[#引用]]本身不是一个对象（只是一个对象的别名），因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用（给指针起别名）。

```c++
int i = 42;

int *p; //p是int型的指针

int *&r = p; //r是一个对指针p的引用
//创建引用的类型必须与被引用对象的类型相同，被引用类型是指针，那么创建一个引用的类型也应该是指针,所以r前面加了*号，&号则是定义引用必须的修饰符。


//改变指向对象。
r = &i; //r是一个指针引用，是指针p的别名，因此给r赋值&i就是令p指向i

//改变指向对象的值
*r = 0; //解引用r,就是解引用指针p,将p指向的变量i的值改为0
```

>Tip: 面对一条比较复杂的指针或引用的声明语句时，从右向左读有助于弄清楚它的真实含义。


## const限定符

const对象一旦创建后其**值就不能再改变**，所以const对象必须初始化。也可以用于初始化其他对象。

```c++
const int bufSize = 512; //输入缓冲区大小
bufSize=512;//错误，const修饰的变量不能修改
cont int i = get_size(); //用函数返回值初始化， 运行时初始化 
int j = 10; cont int k = j; //用其他变量初始化
```

**默认情况下，const对象被设定为仅在文件内有效。** 多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

对const变量不管是声明还是定义都**添加extern关键字**，实现在多个文件中共享。
```c++
//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问。
extern const int bufSize=fcn();
//file_1.h头文件
extern const bufSize;//与上面的bufSize是同一个。
```


### const的引用

把引用绑定到const对象上，称之为**对常量的引用。**
>引用的类型也必须是const修饰

**与普通应用的区别：** 对常量的引用不能被用作修改它所绑定的对象；
>给常量起别名，但是不能通过这个别名修改引用的对象。

```c++
const int ci = 1024;

const int &r1 = ci; //正确，引用r1和ci都是常量

r1 = 42; //错误， r1 是对常量的引用

int &r2 = ci; //错误，不能让一个非常量引用指向一个常量对象
```

**总结：常量可以被引用，但是引用类型也必须是常量，不可修改。**



####  初始化和对const的引用

*常量引用：* const修饰的引用。只要和引用类型相同就可以引用*引用是名词*
*引用常量：* 引用对象是一个const修饰的对象。只能使用const修饰的引用类型进行引用，因为引用对象是一个常量不可变！*引用是动词*
```C++
const int c1 = 1024;
int c2 = 1024;
//常量引用
const int &r1=1024;
const int &r2=1024*111;
const int &r3=c2;//引用类型是常量，不允许通过这个引用改变c2的值。

//引用常量
const int &r4=c1;//正确
int &r4=c1;//错误，因为c1是常量，只能用const修饰的引用
int &r5=r3*2;//错误，因为等式右边会生成一个常量临时量来保存，此时该引用绑定了一个临时对象，r5引用不能改变被引用对象r3的值，于是这种操作是非法的。
```

####  指针和const

指向常量的指针（pointertoconst）不能用于改变其所指对象的值。
>即**不可以**用解引用符改变指向常量的值。底层const

|              | int i | const int i |
| ------------ | ----- | ----------- |
| int * p      | √     | ×           |
| cont int * p | √     | √            |

**想要存放常量的地址，只能使用常量的指针。用非常量指针指向常量会报错**

**常量的指针（const修饰的指针）仅仅要求不能通过该指针改变对象的值，指向对象没有限制是否是常量**
```C++
const double pi = 3.14;//一个常量
double *ptr = &pi;//错误，普通指针不能指向常量
const double *cptr=&pi;//指向常量的指针，必须用const修饰，注意不同于const指针
double dval = 3.14;
cptr = &dval;//指向常量的指针的值向可以改变。
```


####  const指针

const指针必须初始化，初始化完成之后指向**对象（存放在指针中的地址）不能修改。** 顶层const
```c++
int errNumb = 0;

int *const curErr = &errNumb; //curErr将一直指向errNumb,不可以改变指向

const double pi = 3.14;

cont double *const pip = &pi; //pip是一个指向常量对象的常量指针
```

如果const指针指向的对象
- **指向常量：** 指针指向对象不能更改，对象的值不能更改。
- **指向非常量**：指针指向对象不能更改，但是对象的值可以修改。

####  指针和const指针小总结

|      |          |const类型 | 常量               | 非常量                     |   指向对象  | 
| ---- | --------- |------| ------------------ | -------------------------- | --- |
| 指针 | 常量指针  |底层const| 可以指向，不可以修改常量的值 | 可以指向，不能修改对象的值 |   可以更改  |
|      | const指针 |顶层const|      可以指向，不可以修改常量的值              |  可以指向，可以修改对象值                          |   不能更改  |


###  顶层const
- **顶层const :** 表示对象本身是常量，不可以改变  
  
- **底层const:** 表示指针指向的变量（对象）是一个常量. ^a6cfdd

```c++
int i = 0;
int *const p1 = &i; //p1是指针，p1的指向不能改变，顶层
const int ci = 42; //ci是普通变量，ci的值不能改变，顶层
const int *p2 = &ci; //p2是一个指针,但是本身的指向可以改变，底层
const int *const p3 = p2; //靠右的const是顶层const，靠左的是底层const
const int &r = ci; //用于声明引用的const都是底层
```

**引用类型的变量自带顶层const** 即引用一旦赋值（指向某个变量）就不可以在变化（指向另一个变量）

==非常量可以转换成常量，反之则不行.==

###  constexpr和常量表达式
**常量表达式（constexpression）** 是指值不会改变并且在编译过程就能得到计算结果的表达式。

一个对象的**数据类型是const修饰**,且**初始值**是字面值的就是一个常量表达式.

####  constexpr变量
**constexpr类型变量一定是一个常量,且必须用常量表达式初始化.**
```c++
constexpr int mf = 20;//20是常量表达式
constexpr int limit = mf+1;//mf+1是常量表达式
constexpr int sz = size();
//只有当size是一个constexpr函数时候,才是一条正确的语句.
```
**如果一个变量是常量表达式,那么就把它声明为constexpr**

####  字面值类型

- **字面值类型:** 算术类型、引用、指针.
>自定义类型,IO库,是`string`类型不属于字面值类型,不能被定义成`constexpr`

**一个`constexpr`指针的初始值必须是`nullptr`或者是`0`,或者存储与一个固定地址的对象.**

####  指针和constexpr

**constexpr定义的指针,只对指针有效,与指针所指对象无关,即是一个常量指针,对指向类型不做要求,但是指针是一个常量.**
>constexpr把它所定义的对象置为[[#顶层const]]
```c++
const int *p = nullptr;//p是一个指向整型常量的指针
constexpr int *q = nullptr;//q是一个指向整数的常量指针,
int *const t  = nullptr;//t是const指针，不能改变指向
```

**constexpr指针与常量指针类似,可以指向常量,也可以指向非常量,只是不能更改指向对象**


## 处理类型

### 类型别名

**类型别名（typealias）是一个名字，** 它是某种类型的同义词,即给一个类起一个好记的名字。

#### 定义类型别名方法:关键字typedef

```c++
typedef double wages;//wages是double的同义词
typedef wages base,*p;
//base是ouble的同义词,p是double*的同义词

//使用别名进行变量声明
wages hourly,weekly;//声明类型为double的两个变量
```


#### 定义类型别名方法:使用别名声名

```c++
using SI = Sales_item;//SI是Sales_item别名

//使用别名进行变量声明
SI item;//声明一个Sales_item类型的变量
```

#### 指针,常量和类型别名

```C++
typedef char *pstring;//pastring是char指针的别名
const pstring cstr=;//const修饰的是char指针,即是一个常量指针,指向char.
const char *cstr=;//const修饰的是char,即基础数据类型是const char,指针指向const char.

```
**const pstring 中 const 是对 pstring 的修饰，而 pstring 是一个 char指针，因此 const pstring 是指向 char的 常量指针，而并不是指向常量字符的指针.**

### auto类型说明符

**作用:** 在变量声明时无需指定类型,而是让编译器替我们去分析表达式所属的类型.

**auto定义的变量必须有初始值**
```c++
auto item = val1+val2;
//有val1和val2相加的结果推断出item的类型
```

**在同一行使用auto声明多个变量时,数据类型必须是一样**

#### 复合类型,常量和auto

**编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。**
```c++
int i=0,&r=i;
auto a=r;//a是一个整数,因为r是int的引用
```

**auto一般会忽略[[#顶层const]],而底层const则会保留.**
```c++
const int ci = i, &cr = ci;//顶层const和底层const

auto b = ci; //int b = ci;

auto c = cr; //int c = cr; cr是ci的别名，ci本身是一个顶层const

auto d = &i; //int *d = &i;

auto e = &ci; //const int *e = &ci; 对常量对象取地址是一种底层const
```

**如果需要推断出的auto类型是一个顶层const,则需要明确指出:**
```c++
const auto f=ci;//ci的推演类型是int,而f是const int

auto &g=ci;//ci的类型是一个常量引用
auto &h = 42;//错误,auto一般会忽略顶层const,所以该初始化引用类型是int引用,不能为非常量引用绑定字面值.

const auto &j = 42;///显式声明为顶层const,即类型为常量引用,可以绑定字面值.
```

>auto 使用建议：  
  使用auto声明变量一定要做到心里有数，你知道编译器会推断出的什么样的类型  
  通常使用auto是对于一些类型名比较复杂的变量，使用auto写起来更方便


### decltype类型指示符

**作用:** 是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值.
```c++
decltype(f()) sum = x;//sum的类型就是函数f的返回类型.
```
>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。
>换句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的那个类型。

```c++
const int ci = 0, &cj = ci;

decltype(ci) x = 0; //const int x = 0,x的类型是const int

decltype(cj) y = x; //const int &y = x,y的类型是const int&,y绑定变量x

decltype(cj) z; //错误， const int &z,z的类型是const int&,引用必须初始化
```
**引用从来都作为其所指对象的同义词出现，用在decltype处,表示变量声明为引用类型**

#### decltype和引用

```c++
int i = 42, *p = &i, &r = i;

decltype(r + 0) b; //加法的结果是int,所以是int b;

decltype(*p) c; //错误， c的类型是int &; 引用需要初始化

```
>r 是引用 ,decltype(r) 是引用，但是 r + 0 是一个int型数据  
如果表达式的内容是**解引用**操作，则decltype将**得到引用类型**。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&，而非int

**变量加上(),得到的结果是引用类型**
```c++
decltype((i)) d; //错误， int& d; 引用类型需要初始化

decltype(i) e; // 正确,e是一个未初始化的int类型;
```
>切记：decltype（(variable)）（注意是双层括号）的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用

##### 使用decltype得到引用类型的几种情况
1. **表达式是解引用操作**,所得类型不是所指向对象类型,而是一个引用类型
2. **表达式中加了括号()**,结果是引用类型

## 自定义数据结构

这里的自定义数据结构就是指**类类型**的数据，在C++中定义类的关键字有```class``` 和 ```struct```.

### 示例类：Sales_data
```C++
struct Sales_data{
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
```

#### 类数据成员
在[[#示例类：Sales_data]]中，数据成员有：
- bookNo,类型为string
- units_sold,类型为unsigned
- revenue，类型为double

**每个Sales_data对象都包含这三个数据成员**

**类内初始值：** 创建类对象时，类内初始值将用于初始化数据成员。



### 注意事项
1. **类内部定义的名字必须唯一,但是可以与类外部定义的名字重复.**
2. 类体右侧的表示结束的花括号后必须写一个分号.
	>这是因为类体后曲可以紧跟变量名以示对该类型对象的定义，所以分号必不可少,分号表示声明符（通常为空）的结束。
3. 类通常定义在**头文件**中。**头文件所在名字应该与类的名字保持一致**。


### 编写自己的头文件

头文件通常包含那些只能被定义一次的实体，如类、[[#const限定符|const]]和[[#constexpr变量]]

#### 预处理器概述

**作用：** 确保头文件多次包含仍然能够安全工作。

- 预处理器是在编译之前执行的一段程序，可以**部分地改变我们所明的程序**。
>	当预处理器看到#include标记时,就会用指定的头文件的内容代替#include。

- **头文件保护符：** 依赖于预处理变量。
>**预处理变量：** 在头文件中定义，包含已定义和未定义两种状态。


##### 指令的作用
- ```#define``` :把一个名字设定为预处理变量。
- ```#ifdef``` :．检查某个指定的预处理变量是否已经定义，当预处理变量**已经定义时，为真。**
-  ```#ifndef``` :．查某个指定的预处理变量是否已经定义，当预处理变量**未定义时，为真。**

**一旦检查结果为真，则执行后续操作直到遇到```#endif``` 为止**

```c++
#idndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data{
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
#endif
```
第一次包含Sales_data.h时，因为Sales_data未定义，#ifndef的检查结果为真，预处理器将顺序执行后面的操作直至遇到#endif为止。
此时，预处理变量SALES_DATA_H的值将变为已定义，而且Sales_data.h也会被拷贝到我们的程序中来。后面如果再一次包含Sales_data.h，
则#ifndef的检查结果将为假，编译器将忽略#ifndef到#endif之间的部分。

>整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。


```C++
class ClassName{
//属性
//方法
};

struct ClassName{
//属性
//方法
};
```

# C++基础：字符串、向量和数组

## 命名空间的using声明

```c++
std::cin
```
表示使用明明空间中的`cin`。

- **using 的作用：** 无须专门的前缀（形如命名空间：：）也能使用所需的名字了。

- **在程序中使用到的命名空间成员我们都需要声明。**

- 实际更常见的做法是使用` using namespace std`; 把整个命名空间都引入，这样std命名空间下的成员都可以使用了。  
  
>注意：头文件中尽量不要引入整个命名空间，因为当在其他文件包含头文件实际是将这个头文件中的内容拷贝到该文件中，这样可能会和自己写的一些类名冲突。


### 声明
```c++
using namespace::name;//声明语句
```

### 使用
```c++
using std::cin;
int main()
{
	int i;
	cin >> i;//正确因为已经声明。
	cout << i; //错误，只声明了 cin
	std::cout << i;
	return 0;
}
```


## 标准库类型string

`string`的使用需要包含一个**头文件和命名空间.**
```c++
#include <string>
using namespace std;
```

### 定义和初始化string对象

```c++
string s1; //默认初始化， s1是一个空串
string s2(s1); //s2是s1的副本
string s2 = s1; //等价于s2(s1),s2是s1的副本
string s3("value"); //s3是字面值 "value" 的副本，不包含最后的空字符
string s3 = "value"; //同上
string s4(n, 'c'); //n个'c'拼成的串
```

#### 直接初始化和拷贝初始化
```c++
string s5 = "hello";//拷贝初始化
string s6("hello");//直接初始化
string s7(10,'c');//直接初始化，s7的内容是cccccccccc
```
- 直接初始化：使用`()`运算符
- 拷贝初始化：使用`=`运算符

### string对象上的操作
```c++
os << s; //将s写道输出流os中，返回os
is >> s; //从is中读取字符串赋给s,字符串以空包分隔，返回is
getline(is, s); //从is中读取一行赋给s,返回is
s.empty(); //s为空返回true，否则返回false
s.size(); //返回s中字符的个数
s[n]; //返回s中第n个字符的引用，位置从0开始
s1 + s2; //返回s1和s2连接后的结果
s1 = s2; //用s2的副本代替s1中原来的字符
s1 == s2; //判断是否一致
s1 != s2; //判断是否不一样
< , <=, >, >= //通过字典中的顺序比较，对字母大小写敏感
```

#### 读写string对象
- **写**
	写string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。

```C++
int main(){
	string s;
	cin>>s;//将string对象会自动忽略开头的空白，遇到空白会停止。
	cout<<s<<endl;//输出s
	return 0;
}
```

- **读**
```C++
string s1,s2;
cin>>s1>>s2;//第一个输入写s1，第二个写s2
cout<<s1<<s2<<endl;//读
```


#### 读取未知数量的string对象
```c++
int main(){
	string word;
	while(cin>>word)//反复读取，直到至文件末尾
		cout<<word<<endl;//逐个输出单词，每个单词后面紧跟一个换行
	return 0;
}
```

#### 使用getline读取一整行
**使得读取字符串中包含空白符。**

 `getline`函数的参数是一个**输入流**和一个 **`string`对象**，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把**所读的内容存入到那个string对象中去（注意不存换行符）**。*getline只要一遇到换行符就结束读取操作并返回结果*，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。
 ```c++
 int maiin(){
	 string line;
	 while(getline(cin,line))
		 cout<<line<<endl;//让它一次输出一整行，而不再是每行输出一个词了，endl结束当前行并刷新显示缓冲区。
	 return 0;
 }
```

**触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。**


#### string::size_type类型
- `string.size()`返回的是**string::size_type类型**的值。
- `stnng::size_type`类型是一个**无符号类型**的值，能够放下任何`string`对象的大小。
- c++11新标准允许编译器通过[[#auto类型说明符]]或者[[#decltype类型指示符]]推断变量类型
```c++
auto len = line.size();//类型是stnng::size_type
```
>`size()`函数不要和`int`混用，一个是有符号数，一个是无符号数。


#### 比较string对象
相等性运算符（`==` 和`!=`）分别检验两个`string`对象相等或不相等。
**相等：长度相同而且所包含的字符也全都相同。**

**比较运算符述都依照（大小写敏感的）字典顺序：**
1. 长度不同，短string对象每个字符都与较长string对应位置相同，则短string小于较长string。
2. 如果两个string对象在某些位置不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

#### 为string对象赋值
```c++
string st1(10,'c'),st2;
st1 = st2;//用st2的副本替换st1的内容，替换之后，两个都是空字符串。
```

#### 两个string对象相加
两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。也就是说，对string对象使用加法运算符（+）的**结果**是一个**新的string对象**

#### 字面值和string对象相加
标准库允许把字符字而值和字符串字面值转换成string对象。

**字符串字面值与string是不同类型。每个加法运算符都有一个运算对象是string，才可以相加**


### 处理string对象中的字符
在头文件 `cctype `中定义了一组相关的函数。
![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221227214751.png)

`cctype` 是c++的头文件，和`ctype.h`内容一样，命名规范更符合c++语言的要求。
>在cname头文件中定义的名字属于命名空间std，在.h中的不属于。
在c++中包含c的头文件有两种形式  ：
- `#include <ctype.h>  `和c语言一样  。不推荐
- `#include <cctype> `不加 .h 后缀而是在前面加一个 c。**建议使用。**

#### 处理每个字符：使用基于范围的for语句
>我觉得类似于`for each`

**范围for语句**
```c++
for(declaration:expression)
	statement
	//expression部分是一个对象，用于表示一个序列。
	//declaration是一个变量，访问序列中的基础元素。
	//每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。


//示例
string str = "helloWorld";
for (auto s : str) //使用aotu自动类型推导
{
	cout << s << endl;
}

//如果需要改变str中字符，用引用
//引用只是给一个对象起别名，当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。

//转换为大学
for (auto &c : str)
{
	c = toupper(c); //c是引用
}
cout << str << endl;
```
**基于范围的for，只适用于可迭代的对象**

#### 处理部分字符：使用下标访问或迭代器

##### 使用下标
**下标运算符：** 接收的输入参数是[[#string::size_type类型]]的值。表示要访问的**字符的位置**；返回值是该位置上**字符的引用**。

- 下标从0开始，`s[s.size()-1]`是最后一个字符.

- **利用下标访问必须确认在那个位置上确实有值。如果该位置为空，则结果将是未定义的。**

- **只要字符串不是常量，就能利用下标访问并赋值。**

```c++
//使用下标迭代,将字符串转换成大写
for(decltype(s.size()) index = 0;index!=s.size()&&!isspace(s[index]);++index)
	s[index] = toupper(s[index]);
```
>C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。

##### 使用迭代器

## 标准库类型vector

使用vector需要包含下面的头文件和声明命名空间。
```c++
#include <vector>
using std::vector; //或者 using namespace std; 引入std命名空间所有的成员
```

`vector` 类似于数组，但是比数组用于更多的操作。`vetorc `是一个类模板。对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。 ^575c7a
>模板可以认为是编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化（instantiation），当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

```C++
vector<int> ivec; //ivec保存int类型的对象
vector<Sales_item> Sales_vec; //Sales_vec是Sales_item类型的对象集合
vector<vector<string>> file; //该向量的元素是vector对象
```
**引用类型不是对象所以不存在包含引用的`vector`**

```c++
vector<vector<string>> file;//c++11
vector<vector<string> > file;//c++11之前
```


### 定义和初始化vector对象

定义vector对象的常用方法
![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221231151215.png)
```C++
vector<int> v1(10);//v1有10个元素，每个值都是0
vector<int> v2{10};//v2有1个元素，值是10

vector<int> v3{10,1};//v3有10个元素，每个值都是1
vector<int> v4(10,1);//v4有2个元素，值是10和1
```
- 如果用的是**圆括号**，可以说提供的值是用来构造vector对象的(值初始化)。例如，v1的初始值说明了vector对象的容量：v3的两个初始值则分别说明了vector对象的容量和元素的初值。 ^815e05
- 如果用的是**花括号**，可以表述成我们想**列表初始化**该vector对象。也就是说，初始化过程会尽可能地把**花括号内的值当成是元素初始值的列表来处理**，只有在无法执行列表初始化时才会考虑其他初始化方式。在上例中，给v2和v4提供的初始值都能作为元素的值，所以它们都会执行列表初始化，vector对象v2包含一个元素而vector对象v4包含两个元素。
	- 如果初始化时使用了花括号，但是无法用花括号里面的值进行列表初始化，则编译器会尝试使用默认值初始化方法。
```C++
vertor<string> v5{"hello"};//列表初始化，v5有一个元素
vertor<string> v6("hello");//错误，不能使用字符串字面值构建vector对象
vertor<string> v7{10};//类型不符，无法使用列表初始化，使用默认初始化，v7有10个默认初始化的元素
vertor<string> v8{10,"hello"};//类型不符，无法使用列表初始化，使用默认初始化，v8有10个值为“hello”的元素
```


### vector操作

#### 添加元素
`push_back`负责把一个值当成`vector`对象的尾元素“压到（push）”`vector`对象的“尾端（back）”。

**范围for语句体内不应改变其所遍历序列的大小**

#### 其他操作
![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221231154814.png)
**size返回值类型为vector定义的size_type类型。**
```C++
vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9};
for (auto &i : v) //使用引用可以改变v中的值，
{
	i *= i; //计算平方
}
for (auto i : v) //普通
{
	cout << i << " ";
}
```
**vector不能使用下标添加元素。只能对已经存在的元素执行下标操作。**


## 迭代器介绍

迭代器可以理解成一种特殊的指针，他有指针类似的操作，除此之外还有自己独特的一些操作。
**所有标准库容器都可以使用迭代器，** 但是其中只有少数几种才同时支持下标运算符。

### 使用迭代器
通常是使用 being 和 end 方法获取迭代器，begin 返回第一个元素，end 返回最后元素的下一个位置，所以end 返回的迭代器叫做尾后迭代器。
**特殊情况下如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。**

```C++
auto b = v.begin(), e = v.end(); //b和e类型一样，具体类型后面有说明
```
*一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么。*


#### 迭代器运算符
![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221231180438.png)
```C++
string s("some string");
for (auto it = s.begin(); it != s.end() &&!isspace(*it); ++it)
{
	*it = toupper(*it); //将当前字符改成大写形式
}
```

**养成使用迭代器和!=的习惯，就不用太在意用的到底是哪种容器类型。**

#### 迭代器类型

**一般来说我们也不知道（其实是无须知道）迭代器的精确类型。**

拥有迭代器的标准库类型使用`iterator`和`const_iterator`表示迭代器的类型。后者和指针常量产不多，能够读取但是不能修改所指元素的值。`iterator`的对象可读可写。
- `vector`或 `string`对象是常量，只能使用`const_iterator`
- 不是常量，则两者都可以。
```C++
vector<int>::iterator it1;//it1乜能读写vector<int>的元素
string::iterator it2;//it2能读写string对象中的字符

vector<int>::const_iterator it3;//it3只能读元素，不能写元素
string::const_iterator it4;//it4只能读字符，不能写字符
```

#### begin和end运算符

- `vector`或 `string`对象如果是常量，则返回`const_iterator`，如果不是常量，则返回`iterator`
- **如果对象只需读操作而无须写操作的话最好使用常量类型**

```c++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); //it1的类型是vector<int>::itrerator
auto it2 = cv.begin(); //it2的类型是vector<int>::const_iterator
```

c++11新特性：
引入了两个新函数，分别是`cbegin`和`cend`：无论`vector`或 `string`对象是否是常量，返回值都是`const_iterator`。用法与`begin`和`end`相同。

#### 结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。
```c++
//it是vector对象的迭代器
(*it).empty(); //解引用it,得到vector对象，调用vector的empty方法
*it.empty(); //错误，这里是访问it中empty的方法，而it中并没有这个方法
it->empty(); //使用箭头运算符和 (*it).empty();一样
```

#### 某些对vector对象的操作会使迭代器失效

任何一种可能改变vector对象容量的操作，比`push_back`，都会使该vector对象的迭代器失效。
>类似于java中，在添加元素前定义`iteractor`迭代器，之后插入变量，之前顶的迭代器将失效。


### 迭代器运算

`vector` 和 `string` 迭代器支持的运算
![image.png](https://cdn.jsdelivr.net/gh/nagato12580/pictrue/img/20221231205658.png)

#### 迭代器的算术运算

- **只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，** 所得结果是两个迭代器的距离。
- 所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为的带符号整型数。`string`和`vector`都定义了`difference_type`，因为这个距离可正可负，所以`difference_type`**是带符号类型的。**

#### 使用迭代器运算：二分搜索

```c++
//text必须是有序的
//beg和end表示我们搜索的范围
auto beg = text.begin(),end = text.end();
auto mid = text.begin()+(end-beg)/2;//初始状态下的中间点
//当还有元素尚未检查并且我们还没有找到sought时执行循环
while(mid!=end&& *mid !=sought){
	if(sought<*mid)//我们要找的元素在前半部分吗?
		end = mid;//如果是，调整搜索范围使得忽略掉后半部分
	else//我们要找的元素在后半部分
		beg = mid+1;//在mid之后寻找
	mid = beg+(end-beg)/2;／/新的中间点
}
```



## 数组

### 定义和初始化内置数组
```c++
unsigned cnt = 42;
constexpr unsigned sz = 42;//常量表达式
int arr[10];//含有十个整数的数组
int *parr[sz]; //42个整型指针的数组
string bad[cnt]; //错误，cnt不是常量表达式
string strs[get_size()]; //get_size是constexpr时正确；否则错误
```
>[!note]
>**定义数组的时候必须指定数组的类型，** 不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。


#### 显式初始化数组元素
*利用列表初始化时，可以忽略数组的维度*
```c++
const unsigned sz = 3;
int ial[sz] = {0,1,2};//含有3个元素的数组，元素值分别是0，1，2
int a2[] = {0，1，2}; //维度是3的数组
int a3[5] = {0，1，2};//等价于a3[] = {0，1，2，0，0}
string a4[3] = {"hi","bye"}; //等价于a4 = {"hi","bye",""}
int a5[2] = {0,1,2};//错误，初始值过多
```

#### 字符数组的特殊性
```c++
char a1[] = {'C','+','+'};//列表初始化，没有空字符
char a2[] = {'C','+','+','\0'};//列表初始化，含有显式的空字符
char a3[] = "C++";//自动添加表示字符串结束的空字符
const char a4[6] = "Daniel";//错误：没有空间可存放空字符！
```

#### 不允许拷贝和赋值
**不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。**
>![[Pasted image 20230105220453.png]]


#### 理解复杂的数组声明
```c++
int *ptrs[10]; //可存放10个 int* 类型
int &refs[10] = /* ? */ ; //错误，不存在引用的数组
int (*Parray)[10] = &arr; //Parray是一个指向 int[10] 类型的指针
int (&arrRef)[10] = arr; //arrRef是一个int[10]类型的引用
int *(&arry)[10] = ptrs; //arry是一个引用，指向的是 含有10个int*的数组
```
==对于上面这些声明，使用从内至外的方法读比较合适。==


### 访问数组元素：下标访问
- 在使用数组下标的时候，通常将其定义为`sizet_t`类型。在`cstddef`头文件中定义了`sizet_t`类型，这个文件是C标准库`stddef.h`头文件的C++语言版本。


### 指针和数组
```c++
int arr[10];
//p1和p2是等价的
int *p1 = arr;//在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：
int *p2 = &arr[0];

```

**数组的操作实际就是指针的操作。**
```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素
//上面等价于
auto ia2(&ia[0])//显然ia2的类型是int **
ia2 = 42;//错误：ia2是一个指针，不能用int值给指针赋值

//当使用decltype关键字时上述转换不发生！！！！
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};//ia3是一个含有10个整数的数组
```

#### 指针也是迭代器
```c++
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr;//p指向arr第一个元素
++p;//p指向arr[1]
```

#### 标准库函数begin和end
C++11新标准引入了两个名为begin和end的函数。
与容器中两个同名成员功能类似，但是不是成员函数，**正确的使用形式是将数组作为它们的参数**：
```c++
int ai[] = {0, 1, 2, 3, 4, 5, 6, 7};
int *beg = begin(ia); //指向ia首元素的指针
int *last = end(ia); //指向ia尾元素的下一个位置的指针
```

#### 下标和指针
如前所述，在很多情况下**使用数组的名字其实用的是一个指向数组首元素的指针。**
```c++
int ia[] = {0,2,4,6,8};
int i = ia[2];//ia转换成指向数组首元素的指针，ia[2]得到(ia+2)所指的元素
int *p = ia;//指向ia的首元素，也就是ia[0]
i = *(p+2);//等价于i=ia[2]

```

只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：
```c++
int *p = &ia[2];//p指向索引为2的元素
int j = p[1];//p[1]等价于*(p+1），就是ia[3]表示的那个元素
int k = p[-2];//p[-2]是ia[0]表示的那个元素

```



### C风格字符串
在c语言中通常是 `const char*` 表示字符串，并且以空字符 `\0` 为结尾。**CPP中不建议使用。**
```c++
const char* str = "heo\0ll"; //定义一个c风格的字符串，并且在中间加入一个结束符
//因为结束符的原因，c的函数库一些操作会出现意想不到的结果
strlen(str); //计算str的长度，结果是3，计算方式是遇到空字符结束
```
![[Pasted image 20230108201011.png]]

#### 比较字符串
**`string`对象可以直接比较，而C语言风格字符串比较比较的是指针而非字符串本身。**
```c++
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (ca1<ca2)//未定义的：试图比较两个指针，指针保存的是两个无关的地址。
```
**比较两个C风格字符串需要调用`strcmp`函数，此时比较的就不再是指针了。**
- 字符串相等，`strcmp`返回值为0.
- 前者大于后者，`strcmp`返回值为正，反之为负。


#### 目标字符串大小由调用者指定
`string`对象可以字节利用`+`连接，而C风格字符串则需要使用`strcat`和`strcpy`函数，同时必须提供一个能够容纳结果字符串和末尾空字符的数组。
```c++
//string对象连接
string largeStr = s1+""+s2;
//c风格字符串连接
strcpy(largeStr,ca1);//把ca1拷贝给largeStr
strcat(largeStr," ");//largeStr的末尾加上一个空格
strcat(largeStr,ca2);//把ca2连接到largeStr后面
```
>一个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，而且largeStr所存的内容一旦改变，就必须重新检查其空间是否足够。不幸的是，这样的代码到处都是，程序员根本没法照顾周全。这类代码充满了风险而且经常导致严重的安全泄漏。


### 与旧代码的接口

#### 混用string对象和C风格字符串
- 利用`c_str`,将`strig`对象初始化为C风格字符串
```c++
string s("hello world");
const char *str = s.c_str();
```
**s的值改变返回的c_str可能会失去效用，最好重新拷贝一份。**


#### 使用数组初始化vector对象
**`vector`对象不能初始化数组，但是数组可以初始化`vector`对象。**
```c++
int int_arr[] = {0,1,2,3,4,5};
vetor<int> ivec(begin(int_arr),end(int_arr));
//第二个指针应指向拷贝区域尾元素的下一位置。即不包含最后指针的元素。
```


## 多维数组
**通常所说的多维数组其实是数组的数组。**

### 多维数组初始化
```c++
int ia[3][4] = {
{0,1,2,3},
{4,5,6,7},
{8,9,10,11}
};
int ia[3][4]= {0,1,2,3,4,5,6,7,8,9,10,11};

```

### 多维数组的下标引用
```c++
int (&row)[4] = ia[1];//row是含有4个整数的数组引用，把row绑定到ia的第二个元素数组上。
```

### 使用范围for循环处理多维数组
**要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。**
```c++
size_t cnt = 0;
for(auto &row:ia)//对外层数组的每一个元素
	for(auto &col:row){//对于内层数组的每一个元素
		col = cnt;
		++cnt;
	}
```

### 指针和多维数组
```c++
int *ip[4];//指针数组，整型指针的数组
int *(ip)[4];//一个指针，指向含有4个整数的数组
```
![[Pasted image 20230109202416.png]]

### 类型别名简化多维数组的指针
![[Pasted image 20230109202535.png]]



# C++基础：表达式

## 表达式基础

### 基本概念
#### 重载运算符
给与基本运算符不同的含义和运算方式，像之前使用的 `<<` 和 `>>` 用于`cout`和`cin`，这两个运算符本来是**移位运算符，** 这里通过重载实现其他的运算。

#### 左值和右值
- 当一个对象被用作右值的时候，用的是**对象的值**（内容）
- 当对象被用作左值的时候，用的是**对象的身份**（在内存中的位置）。

```c++
decltype(*p) //得到结果是int&
decltype(&p)//得到结果是int**
```

#### 复合表达式
复合表达式（compoundexpression）是指含有两个或多个运算符的表达式。

### 优先级和结合律
基本的运算优先级和数学中的优先级一样。  

括号无视优先级，**在不确定默认的优先级时可以使用括号。**

### 求值顺序
**始终运算符明确规定了运算对象的求值顺序**
1. 逻辑与运算符(`&&`)，规定先求左侧运算对象的值，只有当左侧运算对象的值为真时，才继续求右侧运算对象的值。
2. 逻辑或(`||`)
3. 条件运算符(`?:`)
4. 逗号运算符(`,`)
#### 求值顺序、优先级、结合律
`f()+g()*h()+j()`
- 优先级规定，`g()`的返回值和`h()`的返回值相乘。
- 结合律规定，`f()`的返回值先与`g()`和`h()`的乘积相加，所得结果再与`j()`的返回值相加。
- 对于这些**函数的调用顺序没有明确规定。**
>`*++iter`不会出现问题，因为递增运算必须先求值，然后再进行解引用操作。



## 算术运算符

### 常用算数运算符

![[Pasted image 20230110171111.png]]
- **按照运算符的优先级将其分组。**
- 一元运算符的优先级最高，接下来是乘法和除法，优先级最低的是加法和减法。
- 优先级高的运算符比优先级低的运算符组合得更紧密。上面的所有运算符都满足左结合律，意味着当优先级相同时按照从左向右的顺序进行组合。

## 逻辑和关系运算符
![[Pasted image 20230110193156.png]]
**短路求值：**
- 对于**逻辑与**运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值  
- 对于**逻辑或**运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值

## 赋值运算符
**因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。**

**赋值和初始化不同**
```c++
int i = 10, k = 0; //这里是初始化，不是赋值操作
int j; //声明定义一个变量
j = 1; //赋值操作
```

### 赋值运算符满足右结合律
```c++
int ival,jval;
ival = jval = 0;

```

### 复合赋值运算符
![[Pasted image 20230110194051.png]]


## 递增和递减运算符
递增（递减）运算符有前置（++i）和后置（i++）  
  
这两种的使用**区别**是：
- 前置的是先对变量执行加一的操作，再使用变量的值；
- 后置的是先使用变量的值，在执行加一的操作

>前置的是加一返回对象，**后置**的是加一返回原始的**对象的副本**  
 
 **如果没有特别的需求，建议使用前置的版本**

### 使用后置递增的情况
复合表达式中既将变量加1或减1又能使用它原来的值时，使用后置递增。

**后置递增运算符的优先级高于解引用运算符**
```c++
auto pbeg = v.begin();
while(pbeg !=v.end()&& *beg>=0){
cout<<*pbeg++<<endl;//输出当前值并将pbeg向前移动一个元素
}

```


## 成员访问运算符
成员运算符有**点运算符** 和 **箭头运算符**
```c++
//这两个表达式是等价的
ptr->mem;
(*ptr).mem; //* 优先级低于 . 所以要加括号
```

## 条件运算符
条件运算符 `?:` 是一个三元运算符，格式：
```c++
cond ? expr1 : expr2;
//等价形式
if (cond)
expr1;
else
expr2;
```

### 嵌套条件运算符
```c++
finalgrade = (grade>90)?"high pass":(grade<60)?"fail":"pass"
```

**条件运算符满足右结合律，** 意味着运算对象（一般）按照从右向左的顺序组合。因此靠右边的条件运算（比较成绩是否小于60）构成了靠左边的条件运算的`：`分支。

>嵌套最好别超过两到三层

## 位运算符
位运算符是在**二进制的层面**对数据操作，以下是常用的位运算符。
>如果运算对象是符号数负数，那么位运算符如何处理运算对象的“符号位”依赖于机器。建议将位运算符用于处理无符号类型。

![[Pasted image 20230110195524.png]]

### 移位运算符
二进制位或者向左移（`<<`）或者向右移（`>>`），移出边界之外的位就被舍弃掉了。

- 左移运算符（<<）在右侧插入值为0的二进制位。
- 右移运算符（>>）的行为则依赖于其左侧运算对象的类型：
	- 如果该运算对象是无符号类型，在左侧插入值为0的二进制位；
	- 如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。

>对应[[CSAPP#^b16ae3|逻辑右移]]与算术右移。

#### 移位运算符优先级
移位运算符的优先级不高不低，介于中间：
- 比[[#常用算数运算符|算术运算符]]的优先级低，
- 比[[#逻辑和关系运算符|关系运算符]]、[[#赋值运算符]]和[[#条件运算符]]的优先级高。

因此在一次使用多个运算符时，有必要在适当的地方加上括号使其满足我们的要求。

## sizeof运算符
`sizeof` 运算符**返回一条表达式**或一个类型名字所占的**字节数**。该运算符有两种形式：
```c++
sizeof(type);

sizeof expr;//返回的是表达式结果类型的大小。不实际计算其运算对象的值：
```

sizeof运算符的结果部分地依赖于其作用的类型：  
  
- 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得1  
- 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小。
- 对指针执行`sizeof`运算得到指针本身所占空间的大小  
- 对解引用指针执行`sizeof`运算得到指针指向的对象所占空间的大小，指针不需有效  
- 对数组执行`sizeof`运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次`sizeof`运算并将所得结果求和，**注意`sizeof`运算不会把数组转换成指针来处理**  
>因为执行`sizeof`运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数.
- 对`string`对象或`vector`对象执行`sizeof`运算只能返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。


## 逗号运算符
**逗号运算符**（commaoperator）含有两个运算对象，按照从左向右的顺序依次求值。

对于逗号运算符来说，按照**从左到右**的顺序求值。首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。
```c++
vector<int>::size_type cnt = ivec.size();
//将把从size到1的值赋给ivec的元素
for(vector<int>::size_type ix = 0;
ix != ivec.size; ++ix, --cnt)
ivec[ix] = cnt;
```

## 类型转换

### 隐式转换
隐式转换型转换是**自动执行**的，无须程序员的介入，有时甚至不需要程序员了解。
```c++
int ival = 3.541+3;//ival初始化为6，损失精度。
```

#### 何时发生？
- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型：在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。


### 算数转换
算术转换的含义是：把一种算术类型转换成另外一种算术类型。**其中运算符的运算对象将转换成最宽的类型。** 

#### 整型提升
整型提升：负责把小整数类型转换成较大的整数类型。

#### 无符号类型的运算对象
- 整型提升：运算对象类型相同，小类型的转为较大类型。
- 无符号和有符号类型：
	- 无符号不小于带符号类型：带符号类型转换为无符号类型。
	- 带符号类型大于无符号类型：转换结果依赖于机器。如果无符号类型所有值能存在带符号类型中，则无符号对象转为带符号对象，放之，带符号对象转换为无符号对象。


### 其他隐式类型转换
除了**算术转换之外还有几种隐式类型转换**，包括如．下几种：
- 数组转换成指针。
```c++
int ia[10];
int *ip = ia;//ia转换成指向数组首元素的指针。
```
![[Pasted image 20230110211018.png]]

- 指针的转换：
	- 常量整数值0或者字面值`nullptr`能转换成任意指针类型。
	- 指向任意非常量的指针能转换成`void*`。
	- 指向任意对象的指针能转换成 `const void *`

- 转换成布尔类型：如果指针或算术类型的值为0，转换结果是`false`：否则转换结果是`true`。

- 转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针。
```c++
int i;
const int &j = i;//非常量转换成const int的引用
const int *p = &i;//非常量的地址转换成const的地址
int &r = j,*q = p;//错误：不允许const转换成非常量
```

- 类类型定义的转换：类类型能定义山编译器自动执行的转换，不过编译器每次只能执行一种类型的转换。例如，字符串字面值转换成`string`类型。
![[Pasted image 20230110224237.png]]

### 显式转换
**显示转换：** 显式地将对象**强制转换**成另外一种类型。

**建议：避免强制类型转换**

#### 命名的强制类型转换
一个命名的强制类型转换具有如下形式：
```c++
cast-name<type>(expression);
```

- `type`是转换的目标类型而`expression`是要转换的值。**如果`type`是引用类型，则结果是左值。**
- cast-name 是 `static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`中的一种，制定了执行的是哪种转换。
	- `dynamic_cast`支持运行时类型识别

##### static_cast
任何具有明确定义的类型转换，只要不包含底层`const`，都可以使用`static_cast`
```c++
//进行强制类型转换以便执行浮点数除法， j, i是int
double slope = static_cast<double>(j) / i;
```

- 当需要把一个**较大的算术类型赋值给较小的类型**时，`static_cast`非常有用。
- `static_cast`对于编译器无法自动执行的类型转换也非常有用。例如，将void* 指针转换成初始的指针类型。

##### const_cast
`const_cast`**只能**改变运算对象的[[#^a6cfdd|底层const]]，不能该改变类型。
```c++
const char *pc;
char *p = const_cast<char*>(pc);//正确：将常量对象转换成非常量对象。但是通过p写值是未定义的行为,
```

- **去掉`const`性质：** 将常量对象转换成非常量对象。
- 只有 `const_cast`能改变表达式的常量属性。
- 不能用`const_cast`改变表达式的类型。

##### reinterpret_cast
`reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释 。
```c++
int *ip ;
char *pc = reinterpret_cast<char*>(ip);

string str(pc);
//这里使用reinterpret_cast将一个int类型指针转化成字符类型指针。实际上pc仍然是int类型指针，然而经过显示转换编译器认为pc是char指针。用于初始化string对象时，由于是int指针，所以该初始化结果没有实际意义。
```

##### 旧式的强制类型转换
包含两种形式：
```c++
type (expr); //函数形式的强制类型转换

(type) expr; //c语言风格的强制类型转换

char *pc = (char*) ip;//ip是指向整数的指针，效果与使用reinterpret_cast一样。
```


## 运算符优先级表
![[Pasted image 20230110230503.png]]
![[Pasted image 20230110230514.png]]



# C++基础：语句

## 简单语句

### 表达式语句
- 形式：表达式+`；`
- 作用：执行表达式并去弃掉求值结果：
```c++
ival + 5; //一条没有实际作用的表达式语句
cout << ival; //一条有用的表达式语句
```

### 空语句
- 形式：一个分号 `;` 
- 作用：程序的某个地方，**语法**上需要**一条**语句但是**逻辑上不需要**，此时应该使用空语句
```c++
; //空语句
ival = v1 + v2;; //第二分号是空语句，没有影响
while (iter != svec.end()) ; //分号是空语句，导致下面的语句不会出现在循环中执行
++iter; //不属于循环体的一部分
```
>使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。

**别漏写分号，也别多写分号**

### 复合语句(块)
复合语句也被称作**块**(block).一个块就是一个**作用域**。

- 形式：老括号括起来的（可能为空的）语句和声明的序列。
- 作用：在程序的某个地方，语法上需要一条语句，但是**逻辑**上需要**多条**语句。

```c++
while (val < 10) {
	sum += val;
	
	++val;
}
```
- **块不以分号作为结束。**
- **块内没有任何语句，称为空块，等价于空语句**
- 声明定义类时`{}` 后要加 `;`

## 条件语句
c++语言提供了两种按条件执行的语句。
- `if`语句：根据条件决定控制流
- `switch`语句：计算整型表达式的值，根据值从路径中选择一条。

### if语句
```c++
if (condition)

statement

//if else 语句

if (condition)

statement

else

statement2
```

**使用注意：** 记得添加`{}`

### switch语句
[[CSAPP#switch语句|switch的底层实现]]
```c++
switch(lables) {
	case lable1:
	statement;
	break;
	
	case lable1:
	statement;
	break;
	...
	default:
	statement;
	break;
}
```

- **case标签:** 
	- 必须是整型常量表达式
	- 不能相同
	- 最好加`default`,表示默认情况.
	- 省略`break`,使得多个标签对应同一组操作.

**变量要定义在块内,且不能跨标签使用**

## 迭代语句
迭代语句就是我们所说的循环语句.

### while语句
**使用场景**:
- 不确定迭代多少次时使用.
- 循环结束后访问控制变量.
```c++
while (condition)
	statement
```

### do-while语句
**执行一次之后再判断条件**
```c++
do
	statement
while (condition);
```

### 传统for语句

```c++
for (init-statement; condition;expression)
	statement
```
**expression中的语句是在最后执行的**

### 范围for语句
C++11标准中引入.可以**遍历容器或其他序列**的所有元素.
```c++
for (declaration : expression)
	statement
```

## 跳转语句
作用:跳转语句**中断**当前的执行过程。

### break语句
`break` 负责终止离它**最近**的 `while`、`do while`、`for`、或`switch`语句

### continue语句
作用:终止最近的循环中的当前迭代并立即开始下一次迭代

### goto语句
作用:从语句**无条件跳转**到同一函数内的另一条语句。
```c++
goto label;
```

**带标签语句:** 在它之前有一个标示符以及一个冒号.标识符独立于变量或其他标识符的名字
```c++
end:return //带标签语句,可以作为goto语句的目标
```

>[!waring]
>- 跳转后的语句中如果变量未声明将报错.
>- 跳转之后,如果回到变量定义之前,那么该变量将被销毁


## try语句和异常处理语句
- **异常:** 指存在．于运行时的反常行为，这些行为超出了函数正常功能的范围。
>典型异常包括失去数据库连接以及遇到意外输入等。

### throw表达式
- **定义**: `throw`+表达式.
- **作用:** `throw`用于抛出异常
```c++
if(item1.isbn() != item2.isbn())
	throw runtime_error("Data must refer to same ISBN")；
```

### try语句块
- **定义:** `try`开始,以一个或多个`catch`子语句结束.
```c++
try{
	program-satements;
} catch (exception-declaration) {
handler-statements;
} catch (exception-declaration) {
	handler-statements;
}// ...
```
- `exception-declaration`: 是异常声明
- `program-satements`: 可以有包括声明在内的任意C++语句。

如果一段程序没有`try`语句块发生了异常，系统会调用`terminate`函数并终止当前程序的执行。
>`terminate`是标准库函数,执行该函数将导致程序非正常退出。

### 标准异常
c++标准库定义了一组类，用于报告标准库函数遇到的问题，它们分别定义在4个头文件中
- `exception` 头文件定义了最通用的异常类 ,它只报告异常的发生，不提供任何额外信息  
- `stdexcept` 头文件定义几种常用的异常类，详细见下表  
- `new` 头文件定义了 `bad_alloc`异常类型  
- `type_info` 头文件定义了`bad_cast`异常类型
![[Pasted image 20230111155542.png]]

异常类型只定义了一个名为`what`的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的`const char*`.该字符串的目的是提供关一于异常的一些文本信息。


# C++基础: 函数

**重载:** 几个不同的函数可以使用同一个名字.

## 函数基础
一个典型的函数定义包括以下部分：
- 返回类型 
- 函数名
- 形参列表 

### 编写和调用函数
```c++
//val的阶乘 val*(val-1)*(val-2)...*1
int fact(int val)
{
	int ret = 1;
	while (val > 1)
	ret *= val--;
	return ret;
}

//调用函数
int main()
{
	int j = fact(5);
	cout << "5! is " << j << endl;
	return 0;
}
```

**函数的调用:** 完成两项工作
1. 用实参初始化函数对应的形参
	>隐式定义并初始化形参,调用时创建一个形参变量,然后用实参5初始化它.
	
	
2. 将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。

### 实参和形参
**实参:** 实参是形参的初始值。实参的类型比喻与形参一致,或者是可以[[#类型转换]]的.

### 函数返回类型
- `void`: 函数不返回任何值
- 返回值不能是数组或者函数,但是可以是指向数组或者函数的指针


### 局部对象
在c++语言中，名字有**作用域**，对象有**生命周期**
- 名字的作用域是程序文本的一部分，名字在其中可见  
- 对象的生命周期是程序执行过程中该对象存在的一段时间

**局部变量:** 形参和函数体内部定义的变量,局部变量会被隐藏在外层作用域中同名的其他所有声明中.
函数体之外定义的对象,在程序启动时被创建，直到程序结束才会销毁。

#### 自动对象

**自动对象：**  只存在于块执行期间的对象。
>当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。

**形式参数是一种自动对象。** 函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，函数一旦终止，形式参数也就销毁。

#### 局部静态对象
**局部静态对象：** 在**程序的**执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。使用`static`关键字定义。
```c++
size_t count_calls()
{
	static size_t ctr = 0;//调用结束后，这个值仍然有效
	
	return ++ctr;
}

int main()
{
	for (size_t i = 0; i != 10; ++i)
	{
		cout << count_calls() << endl;
	}
	return 0;
}
```

**如果没有显示初始化值，将进行**[[#默认初始化]]


### 函数声明
- **函数必须在使用前进行声明**
- 函数只能定义一次，但是可以声明多次，如果一个函数永远不会用到，那么可以只声明不定义，即使用[[#关键字 extern]]。
- 函数的声明无需函数体，形参也可无需名字。
- 函数定义建议在头文件中，在源文件中包含该头文件。

### 分离式编译
分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是，obj的文件，后缀名的含义是该文件包含对象代码。编译器负责把对象文件链接在一起形成可执行文件。

## 参数传递
- 当参数的类型是**引用类型**时，它将绑定在对应的实参上，即在函数中对形参的修改实际是对实参的修改。即引用形参是实参的别名。
- 当参数类型是非引用时，实参值被拷贝给形参时，形参和实参是两个相互独立的对象。称为实参的**值传递**

### 传值参数
当初始化一个非引用类型的变量时，初始值被拷**贝**给变量，在函数体内改变的是实参的副本，**不会对实参有影响**。
```c++
//val的阶乘 val*(val-1)*(val-2)...*1
int fact(int val)
{
	int ret = 1;
	while (val > 1)
	ret *= val--;
	return ret;
}

//调用函数
int main()
{
	int j = 5;
	cout << "5! is " << fact(j) << endl;
	cout << "5! is " << j << endl; //j的值没有变化
	return 0;
}

```

#### 指针形参
==指针形参也是值传递的一种方式，==传入的指针是实参的副本（一个拷贝出来的指针），同样在函数体中改变指针的值（指向的地址）不会影响实参的值。
```c++
void reset(int *ip)
{
	*ip = 0; //改变指针ip所指对象的值
	ip = 0; //改变ip所指向的地址，但是只改变局部变量，实参未被改变
}
```


### 传引用参数
- **通过引用形参，可以改变实参的值**
- 由于没有拷贝，所以避免了拷贝操作带来的性能损耗
```c++
//这个函数，调用之后会实参的值会变成0
void reset(int &i)
{
	i = 0;
}

int main()
{
	int j = 42;
	reset(j);
	cout << "j = " << j << endl; //j的值是0
	return 0;
}

```
- 建议使用引用传参， 对于不需要改变引用形参的值，可以将其声明为**常量引用**

### const形参和实参
- **用实参初始化形参是会忽略[[#顶层const]]**，也就是说对于一个含有顶层`const`的形参，可以给它传递常量和非常量对象。
- 我们可以使用非常量初始化一个底层const对象，但是反过来不行。
```c++
int i = 42;
const int *cp = &i; //正确，使用非常量对象初始化底层cost变量
const int &r = i; //正确，使用非常量对象初始化底层cost变量， 引用不存在顶层const
const int &r2 = 42; //正确
int *p = cp; //错误，将一个含有底层const的变量赋值给普通变量
int &r3 = r; //错误， r3的类型和r的类型不匹配
int &r4 = 42; //错误，不能用字面值初始化一个非常量引用
```
将变量的初始化规则应用到参数传递：
```c++
//函数原型: int reset(int &i); 和 int reset(int *ip);
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i); //调用形参类型为 int* 的 reset
reset(&ci); //错误，int *ip = ci;
reset(i); //调用形参类型为 int& 的 reset
reset(ci); //错误， int &ip = ci;
reset(42); //错误 int &i = 42;
reset(ctr); //错误, 类型不匹配

```

**尽量使用常量引用**  
  
- 把一个不需要改变的形参定义成非常量引用的话，会给人误导 
- 使用引用而非常量引用也会极人地限制函数所能接受的实参类型。例如 形参`string`类型的引用，实参不能传递字符串字面值常量。
- 定义成常量引用的形参，调用者可以传递常量和非常量实参。

### 数组形参

- **数组的两个特殊性质：**
	- 不允许拷贝数组
	- 使用数组时会将其转换成指针。

**数组形参实际上传递的是指向数组首元素的指针。**

#### 传参方式
```c++
//传入的都是 const int*
void print(const int*);
void print(const int[]);
void print(const int[10]); //这里的维度是希望传入含有10个元素的数组的指针，实际不一定
```
**指针的值是地址**
>[[CSAPP#^c1ebd4|指针]]

#### 数组长度
数组是以指针的形式传递给函数的，函数一开始不知道数组的确切尺寸。

##### 使用标记指定数组长度
**指定一个结束的标记**，使用这种方法的典型示例是[[#C风格字符串]]，它是以 `\0` 为结束标志，通常只要读取到 `\0`  就是读取到一个完整的字符串
```c++
void print(const char *cp)
{
	if(cp)
	while(*cp)
	cout << *cp++; //输出当前字符指针向前移动一个位置
}
```
>适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。

##### 使用标准库规范
给函数**传递指向数组首元素和尾后元素的指针**，这种方法受到了标准库技术的启发。
>也就是传递元素的起始和结束地址。
```c++
void print(const int *beg, const int* end)
{
	while(beg != end)
	cout << *beg++ << endl;
}
```

##### 显式传递一个表示数组大小的形参
```c++
void print(const int ia[], size_t size) //size 是数组的大小
{
	for (size_t i = 0; i != size; ++i) {
		cout << ia[i] << endl;
	}
}
```


#### 数组形参和const
如果函数中需要对数组执行写操作，则传入非常量指针，不需要则传入常量指针。
>对于普通变量也是，如果需要改变变量的值则传入非常量引用，不需要改变传入常量引用。

#### 数组引用形参
c++允许将变量定义成数组的引用([[#理解复杂的数组声明]])，同样形参也可以是数组的引用。
```c++
//形参是数组的引用，维度是类型的一部分
//形参是指引用，引用类型是int类型的数组
void print(int (&arr)[10])
{
	for (auto elem : arr)
		cout << elem << endl;
}
```
>形参是数组的引用限制了实参的种类，实参只能是数组，且大小要与形参保持一致。

#### 传递多维数组

```c++
void print(int (*martrix)[10], int rowSize) { /*...*/}
```
上述语句将matrix声明成指向含有10个整数的数组的指针， *matrix 两端的括号不可少*
```c++
int *matrix[10]; //10个整型指针组成的数组， 这是个数组变量，先看[],再看*
int (*matrix)[10]; //指向含有10个整型的数组的指针， 这是个指针变量
```
>[!note]
>注意区分[[#数组形参]]传递和多维数组传递的区别


### main：处理命令行选项
- `main` 函数是可以带参数的，我们在命令输入的命令就是传递到`main`函数中。
- 假设`main`函数位于可执行文件 `prog` 之内，我们可以向程序传递下面的选项：
```shell
$ prog -d -o ofile data0
```
>这些命令可以通过两个形参传递给main函数

```c++
//main函数带形参的两种形式，这两种形式是等价的
int main(int argc, char *argv[]) { ... }
int main(int argc, char **argv) { ... }
```
>- 第一形参argc是数组中的字符串数量
>- 第二形参argv是一个数组，它的元素是指向[[#C风格字符串]]的指针。


`prog -d -o ofile data0` 命令， `argc=5`， argv内容为：  
	`argv[0] = "prog ";`  
	  
	`argv[1] = "-d";`  
	  
	`argv[2] = "-o";`  
	  
	`argv[3] = "ofile";`  
	  
	`argv[4] = "data0";`

**argv[0]保存的是程序的名字，不是用户输入。**


### 含有可变形参的函数
- 无法提前预知传递多少个实参数。

- C++11中提供几种方法：
	- 省略符形参
	- initializer_list 形参
	- 编写可变参数模板

#### 省略符形参
==一般只用于与C函数交互的接口程序，==大多数类类型的对象在传递给省略符形参时都无法正确拷贝。

```c++
void foo(parm_list, ...);
void foo(...);
```
>第一种形式指定了 foo 函数的部分形参的类型，这些形参和正常的形参一样。省略符形参所对应的传入的实参无须类型检查。在第一种形式中，形参声明后的逗号是可选的。


#### initializer_list 形参
- 如果函数的实参**数量未知**但是全部实参的**类型都相同**，我们可以使用`initializer_list`类型的形参。

- `initializer_list`是一种标准库类型，用于表示某种特定类型的值的数组。

- `initializer_list`提供的操作
![[Pasted image 20230113110551.png]]

- `initializer_list`与`vector`一样都是模板类型，定义时必须指明列表中所含元素的类型。并且所含元素永远是常量值，无法改变。
```c++
void error_msg( initializer_list<string> il)
{
	for (auto beg = il.begin(); beg != il.end(); ++beg)
		cout << *beg << " ";
	cout << endl;
}
```
**除了`initializer_list` 之外，函数也可以有其他的形参**

## 返回类型和return语句
`return` 语句终止当前正在执行的函数并控制返回到调用该函数的地方。`return`语句有两种形式:
```C++
return; //用于无返回值的函数
return expression; //用于有返回值的函数
```

>作用类似于[[CSAPP#call指令和ret指令|ret指令]]。

### 无返回值函数
- 没有返回值的`return`语句只能用在返回类型是`void`的函数中。
- 返回`void`的函数会隐式执行return不一定非要有`return`
- 函数中间可以使用`return`提前退出
```c++
void swap(int &v1, int &v2)
{
	if(v1 == v2)
		return;
	int tmp = v2;
	v2 = v1;
	v1 = tmp;
	//此处无须显示的return语句
}
```

### 有返回值函数
- `return`语句返回值的类型必须与函数的返回类型相同，或者可以隐式转换成函数的返回类型。
```c++
bool str_subrange(const string &str1, const string &str2)
{
	if(str1.size() == str2.size())
		return str1 == str2;
	auto size = (str1.size() < str2.size())
	? str1.size() : str2.size();
	for(decltype(size) != 0; i != size; ++i) {
		if(str1[i] != str2[i])
			return; //error1
}

//errro2

}
```
>error1，要求返回`bool`类型  
>error2，前面的两个`return`可能不会执行，导致最后没有`return`语句


- 不能返回局部对象的引用或者指针，因为在函数调用结束后，临时对象所占用的空间将被释放。
```c++
const string &manip()

{
	string ret;
	
	if (!ret.empty())
		return ret; //错误：返回局部对象的引用！
	else

		return "Empty"; //错误： "Empty"是一个局部临时对象
}
```

- 调用运算符有优先级和结合律。
	- 优先级与点运算符和箭头运算符相同。
	- 满足左结合律


- 返回非常量引用类型可以做左值，可被赋值
```c++
char &get_val(string &str, string::size_type ix)
{
	return str[ix];
}
int main()
{
	string s("a value");
	cout << s << endl;
	get_val(s, 0) = 'A'; //等价于 s[0] = 'A';
	cout << s << endl;
	return 0;
}
```

- 列表初始化返回值
C++11新标准规定，函数可以返回花括号包围的值的列表。
```c++
vector<string> process()
{
	//...
	//expected 和 actual是string对象
	if(expected.empty())
		return {};
	else if(expected == actual)
		return {"functionX", "okay"};
	else
		return {"functionX", expected, actual};
}
```

- 主函数`main`的返回值：允许main没有`return`语句。
>`cstdlib`头文件中定义了两个预处理变量，用于表示执行成功或者失败。预处理变量使用时不需要加上`std::` ，也不需要[[#命名空间的using声明|using声明]]。

- 递归：函数直接或间接的调用自身。
**在递归函数中，一定有某条路径是不包含递归调用的，否则将一直不断调用自己。**
```c++
int factorial(int val)
{
	if (val > 1)
		return factorial(val-1)*val;
	return 1;
}
```
**main函数不能调用它自己**


### 返回数组指针
因为**数组不能被拷贝**，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。
```c++
typedef int arrT[10]; //arrT 是一个类型别名，他表示的类型是含有10个整数的数组
using arrT = int[10]; //和上面的等价
arrT* func(int i); //返回一个指向含有10个整数的数组的指针
```

#### 声明一个返回数组指针的函数
```c++
int arr[10];
int *p1[10];//p1是一个数组，含有10个指针类型元素
int (*p2)[10] = &arr;//p2是一个指针，指向一个10元素数组
```

- **返回数组指针的函数定义形式：**
```c++
Type (*function(parameter_lis)) [dimension]

int (*func(int i)) [10];
```

- `func(int i )`：表示调用`func`函数时需要一个`int`类型的实参。
- `(* func(int i ))`：意味着我们可以对函数调用的结果执行解引用操作。
- `(* func(int i ))[10]`：表示解引用`func`的调用将得到一个大小是10的数组。
- `int (* func(int i ))[10]`：表示数组中的元素是int类型。

#### 使用尾置返回类型
C++11  新标准提供了一种简便的方式定义这样的函数，就是使用 **尾置返回类型** 。
```c++
auto func(int i) -> int(*)[10];
//返回一个指针，该指针指向含有10个整数的数组
```
>任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。

#### 使用decltype
如果我们知道函数返回的指针将指向哪个数组，可以使用 `decltype` 关键做声明返回类型。
```c++
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i) //decltype(odd) 后需要加 * 表示对应的指针类型
{
	return (i % 2) ? &odd : &even; //返回一个指向数组的指针
}
```
>`arrPtr`使用关键字`decltype`表示它的返回类型是个指针，并且该指针所指的对象与`odd`的类型一致。因为`odd`是数组，所以`arrPtr`返回一个指向含有5个整数的数组的指针。
>**`decltype`并不负责把数组类型转换成对应的指针，所以要使用`decltype`返回数组指针时候要在函数名加上`*`。**


## 函数重载
如果同一作用域内的几个函数**名字相同**但**形参列表不同**，我们称之为重载函数。
```c++
void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);
//函数调用时，编译器会根据传入的参数类型调用不同的函数
int j[2] = {0, 1};
print("Hello world"); //调用 print(const char*)
print(j, end(j) - beging(j)); //调用print(const int*, size_t)
print(begin(j), end(j)); //
```
**main函数不能重载**

- 定义重载函数：定义重载函数应该在形参的数量或者类型上有所不同。
==只有返回类型不同的函数不是重载函数==

### 重载和const形参

顶层const不影响传入函数的对象，无法区分形参 ，所以顶层cosnt形参无法实现重载。
```c++
int print(int);
int print(const int); //和上面声明等价，重复声明int print(int);

int print(int*);
int print(int *const); //和上面声明等价，重复声明int print(int*);
```
>注意区分[[#const指针]]和常量指针。
>`const`指针是顶层`const`，自身是`const`
>常量指针是底层`const`，指向是`const`

**形参是指针或引用，** 则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层const：
```c++
int print(int&); //函数作用于int的引用
int print(const int&); //重载函数，作用于常量引用

  
int print(int*); //作用于int类型的指向
int print(const int*); //重载函数，作用于指向常量的指针
```
>底层`const`和没有`const`是不同类型的形参。
>非常量可以转换成`const`，所以上面四个函数都能作用于非常量对象或者指向非常量对象的指针。但是当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。

### const_cast和重载

```c++
const string &sorterString(const string &s1,const string &s2){
	return s1.size()<=s2.size()?s1:s2;
}

string &sorterString(string &s1,string &s2){
	aoto &r = sorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
	return const_cast<string&>(r)
}
```
- 第一个函数传入const引用作为参数，返回类型也是const引用
- 第二个函数传入引用作为参数，返回类型也是引用，其中调用第一个函数将非const引用转换成const引用，获取返回值是const引用，再使用[[#const_cast]]将底层const性质去掉。
>引用只存在底层const
>引用本身不能改变引用的对象，是默认的顶层const


### 调用重载函数
当调用重载函数时有三种可能的结果：
- 编译器找到一个与**实参最佳匹配**的函数，并生成调用改函数的代码。  
- 找不到任何一个函数与调用的参数匹配，此时编译器发出**无匹配**的错误信息。  
- 有多于函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用。**

### 重载与作用域
```c++
string read();
void print(const string&);
void print(double);
void fooBar(int val)
{
	bool read = false;
	string s = read(); //错误，此时的 read 是bool变量
	void print(int); //新作用域,隐藏了之前的print
	print("vlaue: "); //错误，void print(const string&);被隐藏了
	print(ival); //正确，调用 void print(int);
	print(3.14); //正确，调用 void print(int); void print(double);被隐藏了
}
```
在C++语言中，**名字查找发生在类型检查之前**，一旦查找到同名的函数或者变量，则会忽略完成同名的函数或者变量的定义。
**最好不要在某个语句块（函数体）的内部声明和外部名字一样的变量和函数**

## 特殊用途语言特性

### 默认实参
**默认实参：** 在函数的很多次调用中它们都被赋予一个相同的值。 ^e7485a
>调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。
**一旦某个形参被赋予了，默认值，它后曲的所有形参都必须有默认值。**
尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。
```c++
//一个创建窗口的函数，窗口的默认高80，宽180
string screen(string name, int h = 80, int w = 180);
//调用
screen("window1"); //不传入h和w，使用默认值
screen("window2", 100); //只传入h, w使用默认值
```
-   默认形参必须定义在形参列表的最后  
- **实参是按位置解析的，** 比如需要改变 `w` 的值，那么`h`的值也必须传入
-  使用默认实参调用函数：调用函数的时候省略该实参就可以了。


- 默认实参声明：函数声明一般写在头文件中，并且只声明一次，但是也是可以多次声明，多次声明时已经有默认值的形参的默认值不能修改，没有默认值的形参可以加上。
**通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。**

### 内联函数和constexpr函数

- 内联函数和constexpr函数可以在程序中多次定义。
>编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者`constexpr`函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和`constexpr`函数通常定义在头文件中。

#### 内联函数
- **内联函数：** 通常就是将它在每个调用点上“内联地”展开。
```c++
int main()
{
	string s1 = "hello";
	string s2 = "world";
	cout << shorterString(s1, s2) << endl; //等价 cout<< s1.size() <= s2.size() ? s1 : s2 << endl
	return 0;
}
```

- **用法**：在函数返回类型前面加上关键字`inline`
```c++
inline const string &
shorterString(const string &s1, const string &s2)
{
	return s1.size() <= s2.size() ? s1 : s2;
}

```

- 作用：普通函数的调用包含一系列工作，如调用前保存寄存器调用后恢复、拷贝实参、程序转向一个新位置继续执行。**使用内联函数可以避免函数调用的开销。**

- 用途：内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。

#### constexpr
- `constexpr`函数：能用于[[#constexpr和常量表达式|常量表达式]]的函数。
>执行该初始化任务时，编译器把对`constexpr`函数的调用替换成其结果值。为了能在编译过程中随时展开，`constexpr`函数被隐式地指定为内联函数。

- **用法：**
```c++
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz(); //用constexpr函数的返回值初始化一个constexpr变量
```
>[!note]
>- 函数的返回类型及所有形参的类型都得是[[#字面值类型]]，而且函数体中必须有且只有一条return语句。
>- `constexpr`函数不一定返回常量表达式。

### 调试帮助
程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG

#### assert预处理宏
>类似于py中的断言


- 定义：`assert`是一种预处理宏，所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达作为它的条件：
```c++
assert(expr);
```
首先对 `expr` 求值，如果表达式为假（即0），`assert`输出信息并终止程序的执行。如果表达式为真（即非0），`assert`什么也不做。

- `assert`宏定义在`cassert`头文件中。如我们所知，预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无须提供`using`声明。
>也就是说，我们应该使用`assert`而不是`std::assert`，也不需要为`assert`提供`using`声明。

- 和预处理变量一样，宏名字在程序内必须唯一。含有`cassert`头文件的程序不能再定义名为`assert`的变量、函数或者其他实体。

- 作用：**常用于检查“不能发生”的条件。**
```c++
assert(word.size() > threshold);
```

#### NDEBUG预处理变量
`assert`的行为依赖于一个名为 `NDEBUG` 的预处理变量的状态。如果定义了 `NDEBUG`，则`assert`什么也不做。默认状态下没有定义`NEDBUG`。

**使用NDEBUG可以关闭调试状态。**

- 定义NDEBUG既可以在程序中定义，如下
```c++
#define NDEBUG
```

- 可以在编译是加上`NDEBUG`这个参数
```shell
$ CC -D NDEBUG main.c #等价于 #define NDEBUG
```

除了`assert`之外，我们也可以使用`NDEBUG`编写自己的条件调试代码。
```c++
void print(const int ia[], size_t size)
{
	#ifndef NDEBUG
	//__func__是编译器定义的一个局部静态变量，用于存放函数的名字
	cerr << __func__ << ": array size is " << size << endl;
	#endif
//如果NDEBUG未定义将执行以上代码，如果已经定义则忽略。
}
```

#### 程序调试时可以使用的字面值

- `__func__`：编译器为每个函数都定义了，它是一个const char静态数组，用于存放函数的名字。

预处理器定义：
- `__FILE__` 存放文件名的字符串字面值  
- `__LINE__` 存放当前行号的整型字面值  
- `__TIME__`  存放文件编译时间的字符串字面值  
- `__DATE__` 存放文件编译日期的字符串字面值

可以使用这些常量在错误消息中提供更多信息。


## 函数匹配
重载函数的匹配，在形参数量不同的情况下，我们可以很容易确定调用的是那个函数，但是当重载函数的参数数量一样，只是类型不同的情况下，这就变得有点困难了。
>因为虽然形参类型不同但是一些可以进行自动类型转换。


### 确定候选函数和可行函数
```c++
void f();
void f(int);
void f(int , int);
void f(double, double = 3.14);
f(5.6); //调用 void f(double, double)
```

- 函数匹配的步骤：
1. 确定**候选函数**。在以上代码中有四个`f`候选函数
	- **候选函数：** 与被调用的函数同名且声明在调用点可见调用点可见。

2. 考察本次函数调用提供的实参。然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数**。在这个例子中`f(int)`和`f(double, double )`是可行的。
	- **可行函数：** 其形参数量与本次调用提供的实参数量相等，每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。
	>如果函数含有[[#默认实参]]，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。

3. **寻找最佳匹配**：从可行函数中选择与本次调用最匹配的函数。逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。**精确匹配比需要类型转换的匹配更好**，于是编译器会选择`f(double, double )`
	- 基本思想：实参类型与形参类型越接近，它们匹配得越好。

#### 含有多个形参的函数匹配
最佳匹配成功条件：
- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。
- 至少有一个实参的匹配优于其他可行函数提供的匹配。

如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告**二义性调用**的信息。

>调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

### 实参类型转换
确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级：
1. 精确匹配，包括以下情况：  
	- 实参类型和形参类型相同  
	- 实参从数组类型或函数类型转换成对应的指针类型（函数指针下小节会讲）  
	- 向实参添加顶层`const`或者从实参中删除顶层`const`  
2. 通过`const`转换实现的匹配  [[#其他隐式类型转换]]
3. 通过类型提升实现的匹配 [[#算数转换]]
4. 通过[[#算数转换]]或指针转换([[#其他隐式类型转换]])实现的匹配  
5. 通过类类型转换实现的匹配.

## 函数指针
**函数指针是指针，它指向的是函数。** 函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：
```c++
bool lengthCompare(const string &, const string &);
//上面函数的类型是
bool(const string&, const string&)
//声明一个对应的函数指针
bool (*pf)(const string&, const string&); //指针pf是函数指针，未初始化
```
==(* pf)两端的括号不能少,==如果不写这对括号，则`pf`是一个返回值为`bool`指针的函数

### 使用函数指针
函数名和数组名一样，直接使用名字（不用取地址符）会自动地转换为指针，例如
```c++
pf = lengthCompare; //pf 指向名为lengthCompare的函数

pf = &lengthCompare; //和上面的等价，取地址符是可选的
```

此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针：
```c++
bool b1 = pf("hello", "wolrd"); //调用lengthCompare函数
bool b1 = (*pf)("hello", "wolrd"); //等价的调用
bool b3 = lengthCompare("hello", "wolrd"); //另一个等价的调用
```

函数指针也可以赋予 `nullptr` , 函数指针赋值要和定义的类型一致才可以赋值。

### 函数指针形参
和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针
```c++
//第三个参数是函数类型，它会自动转换成函数的指针
void useBigger(const string &s1, const string &s2,
bool pf(const string&, const string&))；

//等价声明:显式地将形参定又成指向函数的指针
void useBigger(const string &s1, const string &s2,
bool (*pf)(const string&, const string&))；

//函数调用
useBigger(s1, s2, lengthCompare); //函数名lengthCompare自动转换为函数指针
```

使用别名简化写法
```c++
//Func和Func2是函数类型
typedef bool Func(const string&, const string&);
typedef decltype(lengthCompare) Func2; //等价类型
//FuncP 和FuncP2是指向函数的指针
typedef bool(*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2; //等价的类型

//使用上面的别名声明带函数指针形参的函数
void useBigger(const string&, const string&, Func);
void useBigger(const string&, const string&, FuncP2);
```
- 我们使用`typedef`定义自己的类型。`Func`和`Func2`是函数类型，而`FuncP`和`FuncP2`是指针类型。
- `decltype`返回函数类型，此时不会将函数类型自动转换成指针类型。因为decltype的结果是函数类型，所以只有在结果前面加上`*` 才能得到指针。

### 返回指向函数的指针
- 和数组类似，我们不能返回函数，但是可以返回函数指针。
- 我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。
```c++
//定义别名，简化写法
using F = int(int*, int); //F是函数类型，不是指针
using PF = int(*)(int*, int); //PF是函数指针类型

//声明返回函数指针的函数
PF f1(int); //正确， PF是指针函数，f1返回指向函数的指针
F f1(int); //错误，F是函数类型，不能返回函数
F *f1(int); //正确，显示地指定返回类型是指向函数的指针

//原始的不使用别名声明方式
int (*f1(int))(int*, int);

//使用尾置返回类型
auto f1(int) -> int(*)(int*, int);
```

### 将auto和decltype用于函数指针类型
我们明确知道返回的函数是哪一个，就能使用`decltype`简化书写函数指针返使用返回类型的过程。
```c++
string::size_type sumLength(const string&, const string&);
string::size_type largerLength(const string&, const string&);

//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength的指针
decltype(sumLength) *getFcn(const string&);
```

**`decltype`作用于函数时返回的时函数类型，所以需要显示地加上 `*` 声明为指针**


# C++基础：类
- **成员变量**， 也叫类的属性 ，就是类中声明定义的变量，可以是基本类型变量或是类类型变量  
- **成员函数**，也叫方法，就是类中声明的函数  
- **实例对象**，通过类类型创建的变量
```c++
//使用struct关键字
struct ClassName{
	//类属性
	//...
	//方法
	//...
};

//使用class关键字
class ClassName{
	//类属性
	//...
	//方法
	//...
};
```


## 定义抽象数据类型

### 设计Sales_data类

- `Sales_data`的接口应包含以下操作：
	- 一个 `isbn` 成员函数，用于返回对象的ISBN编号  
	- 一个 `combine` 成员函数，用于将一个 `Sales_data` 对象加到另一个对象上  。
	- 一个 `avg_price`成员函数，用于返回售出数书籍的平均价格  
	- 一个名为 `add` 的函数，指向两个`Sales_data` 对象的加法  
	- 一个 `read` 函数，将数据从 `istream` 读入到 `Sales_data` 对象中  
	- 一个 `print` 函数，将`Sales_data` 对象的值输出到 `ostream`



### 定义改进的Sale_data类
-  `Sales_data`的成员变量
	-   `bookNo` 表示 ISBN编号，`string`类型  
	-   `units_sold` 表示某本数的销量， `unsigned`  
	-   `revenue` 表示这本书的总销售收入。

```c++
//Sales_data.h
struct Sales_data{
	//成员函数
	std::string isbn() const { return bookNo; }
	Sales_data& combine(const Sales_data&);
	dobule avg_price() const;
	//成员变量
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};

//Sales_data的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```
- 成员函数的声明必须在类的内部，定义可以在类的内部也可以在外部。
- 非成员函数的定义和声明都在类的外部。
- **定义在类内部的函数是隐式的[[#内联函数]]**

定义一个`Sales_data`类对象
```c++
Sales_data total; //total 是一个类对象
```

#### 引入this
成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化`this`。
```c++
total.isbn()
```
>`total`是一个`Sales_data`类对象
>则编译器负责把`total`的地址传递给`isbn`的隐式形参`this`，可以等价地认为编译器将该调用重写成了如下的形式：`Sale_data::isbn(&total)`

- `this` 是一个常量指针，指向的是当前调用该函数的对象的地址。`this`中保存的地址不可以更改，顶层const。
- 每个成员函数都会一个隐式的形参`this`，实际可以在函数体内部使用this
>`std::string isbn() const { return this->bookNo;}`

#### 引入const成员函数（常量成员函数）
跟在成员函数参数列表后面的`const`关键字，这种形式的成员函数叫做 **常量成员函数** （简称 常函数）
```c++
std::string isbn() const { return bookNo; }
```

- 作用：修改隐式`this`指针的类型。

常量成员函数的本质实际上是对 `this` 指针的限制，使得不能使用`this`改变指向对象的值。
前面说到 `this` 是一个常量指针，类型是 `Sales_dat *const` ，这是只有顶层`const`，而常量成员函数又加上了底层`const`，`this`指针变成了 `const Sales_data *const` 类型。isbn 函数真正的原型为：
```c++
std::string isbn(const Sales_data *const this) { return bookNo; }
//this是一个隐式形参，实际代码不能把这个形参写出来
```
>因为在isbn中不会改变this所指向的对象，所以定义成指向常量的指针（底层`const`）。而this在成员函数中都是指向调用对象，指向不改变，是顶层`const`。
>`isbn`可以读取调用它的对象的数据成员，但是不能写入新值。

**常量对象，以及常量对象的引用或指针都只能调用常量成员函数。**
>常量对象是顶层`const`，本身值不能改变。而非常量成员函数中`this`没有定义成底层`const`（不能改变指向对象得值域），即在非常量成员函数中`this`所指向对象的值可以被改变，所以常量成员对象不能调用非常量成员函数。



#### 类作用域和成员函数
在 `isbn()` 函数中使用了 `bookNo` 成员变量，而这个变量的声明式在函数的后面。按照之前关于作用域的知识，变量使用前必须声明，这里和编译器的处理方式有关。编译器对类的处理分两步：首先编译成员的声明，然后才轮到成员函数。因此，**成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。**

#### 在类的外部定义成员函数
`Sales_data` 类的成员函数只有 `isbn()`有定义，其他的成员函数都是只有声明。关于成员函数，它是支持类内声明，类外定义的。**类外定义函数需要包含所属的类名**，具体形式如下
```c++
//avg_price() 的类外定义
double Sales_data::avg_price() const {
	if(units_sold)
		return revenue / units_sold;
	else
		return 0;
}
```
>成员函数类外定义和普通函数的定义没有什么区别，只是成员函数需要在函数名的前面加上对应的类名。

类内定义的成员函数默认是`inline`函数(内联函数)，定义在类外的要成为内联函数，需要显显式的指定，在函数定义的前面加 `inline`关键字。

#### 定义一个返回this对象的函数
函数 `combine` 的设计初衷类似于复合赋值运算符 `+=` , 调用该函数传入的是一个 `Sales_data`对象，返回的还是该对象本身，这里我们可以使用 `this` 指针实现。
```c++
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
	//把rhs的成员加到this对象成员上
	units_sold += rhs.units_sold;
	revenue += rhs.revenue;
	return *this; //this 是调用该函数的对象的指针，对其解引用得到的就是该对象
}
```

### 定义类相关的非成员函数
`add` ，`read`，`print` 不是类的成员函数，但是它们出和该类相关的接口函数，所以把它们和类定义在同一个文件中，以下是这三个函数的定义
```c++
istream &read(istream &is, Sales_data &item)
{
	double price = 0;
	is >> item.bookNo >> item.units_sold >> price;
	item.revenue = price * item.units_sold;
	return is;
}

ostream &print(ostream &os, const Sales_data &item)
{
	os << item.isbn() << " " << item.units_sold << " "
	<< item.revenue << " " << item.avg_price();
	return os;
}

Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
	Sales_data sum = lhs;
	sum.combine(rhs);
	return sum;
}
```
- IO类对象不能被拷贝，所以只能定义成引用类型。因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。

### 构造函数
C++11  新标准允许在类属性定义时初始化，比如`Sales_data` 类中`units_sold` 和 `revenue` 都被初始化为0.但是并不是所有的属性都需要在类内初始化的，有些可能需要类的使用者自定义的初始化。这个时候我们就需要要到类的 构造函数 。

- **构造函数的形式：类名就是函数名，没有返回值。** 
- **作用：**类内初始化成员变量。

类可能包含多个构造函数，和其他[[#调用重载函数|重载函数]]差不多。
```c++
struct Entity{
	double x, y;
	
	//构造函数
	Entity()
	{
		x = 0;
		y = 0;
	}
	
	void print()
	{
		cout << x << "," << y << endl;
	}
}

int main()
{
	Entity e; //等价 Entity e; e.Entity(); 两个语句
	e.print();
	return 0;
}
```

构造函数不能被声明成`const`。
常量成员函数不能更改对象的值，而构造函数是需要改变对象的值的。

#### 合成默认的构造函数
**默认构造函数**：无需任何实参，控制对象默认初始化过程。编译器会隐式地定义一个默认地构造函数

**合成地默认构造函数：** 编译器创建的构造函数。编译器只有在发现类不包含任何构造函数的情况下才会替我们生成默认的构造函数。**一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。**
	初始化规则：
	- 如果存在类内的初始值，用它来初始化成员。
	- 否则，默认初始化改成员。

>[!warning]
>某些类不能依赖于合成的默认构造函数。例如某些类地成员包含其他类地成员，且这个成员地类型没有默认的构造函数，那么编译器将无法初始化该成员。

#### 定义Sales_data的构造函数
```c++
struct Sa1es_data{
	//新增的构造函数
	Sales_data()=default;
	Sa1es_data(const std::string&S):bookNo(s){}
	Sa1es_data(const std::string&S,unsigned n，double p):
			bookNo(s)，units_sold(n)，revenue(p*n){}
	Sales_data(std::istream &);
	//之前已有的其他成员
	std::string isbn() const{return bookNo；}
	Sa1es_data& combine(const Sa1es_data&)；
	double avg_price() const;
	std::string bookNo;
	unsigned units_sold=0；
	double revenue=0.0;
```
- `default`：让编译器生成默认的构造函数。
- （形参）：方法（形参），是用形参初始化成员函数。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。

#### 在类的外部定义构造函数
```c++
//其他的构造已经在类内定义了
inline Sales_data::Sales_data(std::istream &is)
{
	read(is,*this);
}
```
- 显式指定为内联函数。
- 没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。

#### 构造函数的调用
构造函数不需要我们手动的调用，也没有提供给我调用的语法，构造函数的调用是编译器根据我们初始化实例对象的方式调用不同的构造函数。
```c++
//1.调用无参构造
Sales_data total;
//使用括号调用无参构造
Sales_data(); //会创建一个临时的对象，如果需要使用这个对象就要变量接收
Sales_data total = Sales_data(); //用total接收临时变量
Sales_data total(); //错误，这不不调用无参构造创建实例对象，而是声明一个返回类型为Sales_data的函数

//2. 调用有参构造
Sales_data total("654323"); //调用 Sales_data(const std::string &s)构造函数创建实例
```

构造函数：  
1. 构造函数，没有返回值也不写void  
2. 函数名称与类名相同  
3. 构造函数可以有参数，因此可以发生重载  
4. **程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次**

### 拷贝、赋值、和析构

c++编译器至少给一个类添加4个函数 ：
1. 默认构造函数（无参，函数体为空）  
2. 默认析构函数（无参，函数体为空）  
3. 默认拷贝构造函数，对属性进行值拷贝  
4. 赋值运算符 `operator=`，对属性进行值拷贝

尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是,
对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。
>如果类包含`vector`或者`string`成员，则其拷贝、赋值和销毁的合成版本能够正常工作。当我们对含有`vector`成员的对象执行拷贝或者赋值操作时，`vector`类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁`vector`对象，也就是依次销毁`vector`中的每一个元素。这一点与`string`是非常类似的。


#### 拷贝
在变量定义的时候用一个存在对象进行初始化就是拷贝，定义之后再赋值就不是拷贝。
```c++
//拷贝
//trans 是一个已经定义的 Sales_data 对象
Sales_data total(trans); //1
Sales_data total = trans; //2
//等价于
//1 和 2等价的语句
total.bookNO = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;


//下面的语句不是调用拷贝构造
Sales_data total;
total = trans; //调用的是赋值操作

```


#### 析构函数
默认构造函数前面已经提过了，**析构函数** 也是由编译器调用的，**它的调用时机是在对象销毁的时候被调用**，**析构函数的作用一般是用来释放内存空间**（主要是堆上的内存空间），它语法形式如下
```c++
//Sales_data的析构函数
struct Sales_data {
//..
//析构函数
~Sales_data()
{
//...
}
};
```

  
**析构函数语法 ：** `~类名() {}`  
1. 析构函数，没有返回值也不写`void`  
2. 函数名称与类名相同,在名称前加上符号 `~`  
3. 析构函数不可以有参数，因此不可以发生重载  
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

#### 赋值
赋值操作是通过重载赋值运算符来实现的,  `operator=`
```c++
Sales_data total;//调用默认构造函数生成对象
total = trans; //调用的是赋值操作
```

**编译器提供的默认赋值运算和默认拷贝构造操作是一样的，就是对属性值进行值拷贝。**


## 访问控制和封装
使用访问说明符加强类的封装性：
- `public`：之后的成员在整个程序内可被访问，`public`成员定义类的接口
- `private`：之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，`private`部分封装了（即隐藏了）类的实现细节。

```c++
class Sa1es_data{
public:
	//新增的构造函数
	Sales_data()=default;
	Sa1es_data(const std::string&S):bookNo(s){}
	Sa1es_data(const std::string&S,unsigned n，double p):
			bookNo(s)，units_sold(n)，revenue(p*n){}
	Sales_data(std::istream &);
	//之前已有的其他成员
	std::string isbn() const{return bookNo；}
	Sa1es_data& combine(const Sa1es_data&);
private:
	double avg_price() const;
	std::string bookNo;
	unsigned units_sold=0；
	double revenue=0.0;
```
- 构造函数和部分成员函数紧跟在`public`之后
- 数据成员和作为实现部分的函数则跟在`private`说明符后面。
- 每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

### 使用class或struct关键字
`class`与`struct`都可以定义类，**唯一的区别是默认访问权限不同。**

类可以在第一个访问说明符之前定义成员，对于这种成员的访问权限依赖于类定义的方式。
- `struct`关键字：定义在第一个访问说明符之前的成员是`public`的
- `class`关键字：定义在第一个访问说明符之前的成员是`private`的

### 友元
友元的**作用**：定义A类(或函数)为另一个B类的友元，则A类(或函数)可以访问B类的非公有成员。

用法：如果类想把一个函数作为它的友元，只需要增加一条以`friend`关键字开始的函数声明语句即可：
```c++
class Sa1es_data{
//为Sales_data的非成员函数所做的友元声明。
friend Sa1es_data add(const Sa1es_data&,const Sa1es_data&);
friend std::istream &read(std::istream&,Sales_data&);
friend std::ostream &prient(std::ostream,const Sales_data&);
public:
	//新增的构造函数
	Sales_data()=default;
	Sa1es_data(const std::string&S):bookNo(s){}
	Sa1es_data(const std::string&S,unsigned n，double p):
			bookNo(s)，units_sold(n)，revenue(p*n){}
	Sales_data(std::istream &);
	//之前已有的其他成员
	std::string isbn() const{return bookNo；}
	Sa1es_data& combine(const Sa1es_data&);
private:
	double avg_price() const;
	std::string bookNo;
	unsigned units_sold=0；
	double revenue=0.0;
}

//Sa1es_data接口的非成员组成部分的声明
Sa1es_data add(const Sa1es_data&,const Sa1es_data&);
std::istream &read(std::istream&,Sales_data&);
std::ostream &prient(std::ostream,const Sales_data&);
```
>[!tip]
>- 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。
>- 友元不是类的成员也不受它所在区域访问控制级别的约束。
>- 一般来说，最好在类定义开始或结束前的位置集中声明友元。

#### 友元的声明
- 友元的声明**仅仅指定了访问的权限**，而非一个通常意义上的函数声明。
- 类用户要使用友元函数，除了友元声明外还需要函数的普通声明。
- 为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。
- 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明

## 类的其他特性
- 类型成员
- 类的成员的类内初始值
- 可变数据成员
- 内联函数成员
- 从成员函数返回`* this`
- 定义并且使用类类型及友元类

### 类成员再探
```c++
class Screen {
public:
	typedef std::string::size_type pos; //1
	//与1等价
	using pos = std::string::size_type;
	Screen() = default; //2
	Screen(pos ht, pos wd, char c)
	: height(ht), width(wd), contents(ht * wd, c) {}

char get() const //读取光标处的字符
{ return contents[cursor]; } //隐式内联

inline char get(pos ht, pos wd) const; //显式内联

Screen &move(pos r, pos c); //能在之后被设为内联

private:
pos cursor = 0;
pos height = 0, width = 0;
std:string contents;
};
```
>[!note]
>1. 1处在类中自定义某种类型在类中的别名。有访问限制。必须先定义后使用
>2. 2处因为定义了有参构造函数，编译器不会再提供默认的构造，而我们需要一个默认的构造，用这行代码告诉编译器提供一个默认的构造函数。

- `Screen`类的成员函数与普通函数一样可以重载。
	- 只要函数之间在参数的数量和或类型上有所区别就行。


- 令成员作为[[#内联函数]]：
	- 定义在类内部的成员函数是自动`inline`的。`Screen`构造函数和`get`函数默认是内联函数。
	- 可以在类的内部把`inline`作为声明的一部分显式地声明成员函数。也可以在类外部用`inline`修饰函数的定义。
	- 无须在声明和定义的地方同时说明`inline`，最好只在类外部定义的地方说明`inline`
![[Pasted image 20230116104411.png]]


### 可变数据成员
一般情况下，[[#引入const成员函数（常量成员函数）|常函数]]内不可以修改调用者(`this`)的数据成员的值。
```c++
class Person {
public:
	int m_A;
	int m_B;

public:
	void func() const
	{
	m_A = 100; //错误 cosnt函数不可以修改属性的值
	std::cout << m_A << std::endl; //正确，可以读取
	}
};
```

`mutable`关键字：**允许在类内修改某个数据成员**，即使是在一个const成员函数内。
```c++
class Person {
public:
	mutable int m_A = 42;

public:
void func() const
{
	m_A = 100; //正确 m_A 有mutable修饰
	std::cout << m_A << std::endl; //正确，可以读取
}
};
```

### 类内数据成员的初始值
```c++
class Window_mgr{
private:
//这个Window_mgr追踪的Screen
//默认情况下，一个window_mgr包含一个标准尺寸的空白Screen
std::vector<Screen> screens{Screen(24,80,'')}//使用了列表初始化
```
- screen的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。
- 当我们提供一个类内初始值时，必须以符号：或者花括号表示。

### 返回* this 的成员函数
```c++
class Screen {
public:
	Screen &set(char);
	Screen &set(pos,pos,char);
};

line Screen &Screen::set(char c)
{
	contents[cursor]=c;//设置当前光标所在位置的新值
	return *this//将this对象作为左值返回
}

line Screen &Screen::set(pos r,pos col ,char ch)
{
	contents[r*width+col]=ch;//设置给定位置的新值
	return *this//将this对象作为左值返回
}
```
- 返回值是引用：使用[[#引入this|this]]关键字，返回的是调用该函数的对象的引用。
- 返回值不是引用：返回的是`* this`对象的副本。

#### 从`const`成员函数返回`this`
[[#引入const成员函数（常量成员函数）|const成员函数]]中`this`将是一个指向`const`的指针，而`*this`是`const`对象。

如果`const`成员函数以**引用的形式**返回`*this`，则返回的类型应该是常量引用，即不可以通过该引用修改值。则不利于该返回值调用其他动作函数。

 **重载`const`成员函数**，使得常量对象调用常量成员函数，非常量对象调用非成员函数。
 >常量对象只能调用常量成员函数，非常量对象可以调用常量版本或非常量版本，但是调用非常量版本是一个更好的匹配。
 
### 类类型
每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。例如：
```c++
struct A {
	int memi;
	int getMem();
};

struct B {
	int memi;
	int getMem();
};

A a;
B b = a; //错误 A，B是不同的类，不能赋值
```

#### 类声明
类和函数一样也可声明和定义分开，我们也能仅仅声明类而暂时不定义它：
```c++
class Screen; //screen类的声明
```
>这种声明有时被称作**前向声明**，它向程序中引入了名字`screen`并且指明`screen`是一种类类型。对于类型`screen`来说，在它声明之后定义之前是一个**不完全类型**，也就是说，此时我们己知`screen`是一个类类型，但是不清楚它到底包含哪些成员。

**类允许包含指向它自身类型的引用或指针：**
```c++
class Link_screen{
	Screen_window;
	Link_screen *next;
	Link_screen *prev;
}
```


### 友元再探
类还可以把其他的类定义成友元，也可以把其他类（之前己定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

#### 类之间的友元关系
**每个类负责控制自己的友元类或友元函数。**

一个类作为另一个类的友元：
```c++
class Screen {

	// Window_mgr作为友元，Window_mgr的成员可以访问Screen类的私有部分
	friend class Window_mgr;
//...
};
```
- `Window_mgr`作为`Screen`的友元，友元类的成员函数可以访问此类`Screen`包括非公有成员在内的所有成员。


令类中某个函数作为另一个类的友元：
```c++
class Screen {

	//Window_mgr类的clear函数做友元，必须在Screen类之前被声明。
	friend void Window_mgr::clear(ScreenIndex);
//...
};
```
该例的程序设计顺序：
1. 首先定义`Window_mgr`类，其中**声明**`clear`函数，但是**不能定义它**。在`clear`使用`Screen`的成员之前必须先声明`Screen`。
2. 接下来定义`Screen`，包括对于`clear`的友元声明。
3. 最后定义`clear`,此时它才可以使用`Screen`的成员。
**要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。**
==友元声明不能代替函数声明==

#### 重载和友元
尽管重载函数的名字相同，但它们仍然是不同的函数。
因此，如果一个类想把一组重载函数声明成它的**友元**，它需要对这组函数中的每一个**分别声明**。

#### 友元声明和作用域
- 类和非成员函数的声明不是必须在它们的友元声明之前。
- 当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。友元本身不一定声明在当前作用域中。
- **调用友元函数时，该函数必须是被声明过的**
```c++
struct X {
	friend void f() { /* 友元函数可以定义在类的内部 */ }
	X() { f(); } //错误： f还没有被声明
	void g();//成员函数声明
	void h();//成员函数声明
};

//成员函数定义
void X::g() { return f(); } //错误： f还没有被声明
void f(); //声明那个定义在X中的函数
void X::h() { return f(); } //正确，现在f的声明在作用域中了
```
**友元声明的作用是影响访问权限，它本身并非普通意义上的声明。** ==友元声明不能做函数声明！！！==
友元声明的时候可以定义函数，但是不是声明！！！要调用该函数必须声明。


## 类的作用域
**当函数声明在类内，定义在类外的时候，定义需要加上类名表示该函数是该类的成员。**
```c++
void Window_mgr::clear(ScreenIndex i)
{
	Screen &s = screens[i];
	s.contents = string(s.height * s.width, '');
}
```
 - 编译器在处理参数列表之前己经明确了我们当前正位于`Window_mgr`类的作用域中，所以不必再专门说明`ScreenIndex`是`Window_mgr`类定义的。
 - 编译器也能知道函数体中用到的`screens`也是在`Window_mgr`类中定义的。

![[Pasted image 20230116120621.png]]
![[Pasted image 20230116120631.png]]
- 因为返回类型出现在类名之前，所以事实上它是位于`Window_mgr`类的作用域之外的。在这种情况下，要想使用`ScreenIndex`作为返回类型，我们必须明确指定哪个类定义了它。

### 名字查找与类的作用域

**名字查找**的过程：
- 首先，在名字所在的块中寻找其声明语句，只考虑在**名字的使用之前**出现的声明。
- 如果没找到，继续查找外层作用域。
- 如果最终没有找到匹配的声明，则程序报错。
>对于定义在类内部的**成员函数**来说，解析其中名字的方式与上述的查找规则有所区别。


**类的定义**分两步处理：
- 编译成员的声明。
- 直到类全部可见后才编译函数体。
**编译器处理类中的全部声明后才会处理成员函数的定义。** 所以类中的成员变量可以定义在类内的任何位置，**成员函数也可以使用类中定义的任何名字。**

#### 用于类成员声明的名字查找
```c++
typedef double Money;
string bal;
class Account {
public:
	Money balance() { return bal; }
private:
	Money bal;
//...
}
```

当编译器看到 `balance` 函数的**声明**时(这是上述编译成员声明的阶段)，首先会在 `Account` 内找 `Money`。**此时只考虑`Account`内使用`Money`前出现的声明**，很显然没有。于是就会在`Account`外层寻找，找到 `typedef double Money;` 。  

另一方面 `balance` 函数体在整个类可见后才被处理，所以`return` 返回的时类内成员 `bal` 而并不是 `string` 对象。

>[!note]
>- 在声明时候遇到的变量会在该声明之前查找，找不到则到外部查找
>- 全部声明都编译后才进行函数体的编译，所以函数体中可以使用任何类内的声明。


#### 类名要特殊处理
如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字：
```c++
typedef double Money;
class Account {
public:
	//使用外层作用域的Money
	Money balance() { return bal; 
	}
private:
	//错误：不能重新定义Money,即使该定义与外层一致
	typedef double Money;
	Money bal;
//...
}
```
>类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

#### 成员定义中的普通块作用域的名字查找
成员函数中使用的名字按照如下方式解析：
1. 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用**之前**出现的声明才被考虑。
2. 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。
3. 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。

>[!note]
>1. 不建议使用其他成员的名字作为某个成员函数的参数。
>2. 类的成员被隐藏时，类中可以使用类的名字或显式地使用`this`指针来强制访问成员。

- 类作用域之后，在外围的作用域中查找中，遇到同名的变量，在类中可以使用`::`使用全局的那个。例如，`::height`，不过一般不要同名。

![[Pasted image 20230116125451.png]]

## 构造函数再探

### 构造函数初始值列表
`const`成员和引用类型的成员必须被初始化。即需要显式的使用构造函数初始化引用和`const`成员。

**如果成员是`const`、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。**

#### 成员初始化的顺序
- 构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。[[#默认实参|函数中的参数是按形参顺序解析的]]
- 成员初始化顺序与它们在类定义中的出现顺序一致。
- **最好令构造函数初始值的顺序与成员声明的顺序保持一致**。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

###  委托构造函数
- C++11 在一个类中，不同的构造函数中可能存在冗余的语句，这时我们可以使用**委托构造函数。**
- **委托构造函数**使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。
```c++
class Sales_data {
public:
	//非委托构造函数使用对应的实参初始化成员
	Sales_data(std::string s, unsigned cnt, double price):
	bookNo(s), units_sold(cnt), revenue(cnt*price) { }

	//其余构造函数全都委托给另一个构造函数
	Sales_data() : Sales_data("", 0, 0) { }
	Sales_data(std::string s) : Sales_data(s, 0, 0) { }
	Sales_data(std::istream &is) : Sales_data() { read(is, *this); }
};
```
**需要注意的是 先完成委托再执行自身函数体内容。**
受委托的构造函数的初始值列表和函数体被依次执行。

### 默认构造函数的作用
当对象被**默认初始化**或**值初始化**时自动执行默认构造函数。

**默认初始化**在以下情况下发生：
- 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
- 当类类型的成员没有在构造函数初始值列表中显式地初始化时。

**值初始化**在以下情况发生： ^2c0f71
- 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时
- 当我们不使用初始值定义一个局部静态变量时。
- 当我们通过书写形如`T()`的表达式显式地请求值初始化时，其中T是类型名。

**类必须包含一个默认构造函数以便在上述情况下使用**，其中的大多数情况非常容易判断。

**在实际中，如果定义了其他构造函数，那么最后也提供一个默认发构造函数**

#### 使用默认构造函数
```c++
Sales_data obj(); //错误，声明了一个函数而非对象

Sales_data obj2; //正确，是一个对象不是函数
```


### 隐式的类类型转换
如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的**隐式转换机制**，有时我们把这种构造函数称作**转换构造函数**。
```c++
// 相关成员的原型
Sales_data& combine(const Sales_data&); //combine
Sales_data(const std::string &s); //构造函数1
Sales_data(std::istream &); //构造函数2

//item 是一个 Sales_data的实例，combine是将两个Sales_data实例对象相加
string null_book = "9-999-99999-9";
item.combine(null_book);
```
>编泽器用给定的`string`自动创建了一个`sales_data`对象。新生成的这个（临时）`Sa1es_data`对象被传递给`combine`。

#### 只允许一步类类型转换
```c++
//错误： 需要用户定义的两种转换：
//（1）把 "9-999-99999-9" 转换成string
// (2) 再把这个（临时的）string转换成Sales_data
item.combine("9-999-99999-9");
```

如果我们想完成上述调用，可以显式地把字符串转换成`string`或`sales_data`
对象：
```c++
//正确： 显示地转换成string，隐式地转换成Sales_data
item.combine(string("9-999-99999-9"));

//正确：隐式地转换成string，显示地转换成Sales_data
item.combine(Sales_data("9-999-99999-9"));
```
>说明："9-999-99999-9" 字符串字面值并不是`string` 类型，它的类型应该是 `const char*`，是[[#C风格字符串]]


#### 抑制构造函数定义的隐式转换
有时候我们并不希望发生类类型的隐式转换，我们可以通过将构造函数声明为 `explicit` 加以阻止：
```c++
class Sales_data {
public:
	Sales_data() = default;
	Sales_data(const std::string &s, unsigned n, double p):
	bookNo(s), units_sold(n), revenue(p*n) {}

	explicit Sales_data(const std::string &s) : bookNo(s) { }
	explicit Sales_data(std::istream &);
	//...
};

//此时下面的代码就是错误的，无法通过编译
item.combine(null_book); //错误： string构造函数是explicit的
item.combine(cin); //错误： istream构造函数是explicit的
```
**`explicit`使用注意**  
- `explicit` 只对一个实参的构造函数有效，（多个实参的构造函数也不能用于执行隐式转换）  
- 只能再类内声明构造函数时使用`explicit`关键字，在类外定义时不能重复  
- `explicit` 构造函数**只能用于直接初始化**，不能用于拷贝形式的初始化（使用 `=`）
```c++
Sales_data item1(null_book);//正确直接初始化
//错误：不能将explicit构造函数用于拷贝形式的初始化过程
Sales_data item2 = nu11book;
```

>[!note]
>当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且编译器将不会在自动转换过程中使用该构造函数
（参考[[#定义和初始化string对象]]）

#### 为转换显式地使用构造函数
尽管编译器不会将`explicit`的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数**显式地强制进行转换：**
```c++
//正确：实参是一个显示构造的Sales_data对象
item.combine(Sales_data(null_bokk));

//正确： static_cast 可以使用explicit的构造函数
item.combine(static_cast<Sales_data>(cin));
```
第二个调用中，使用[[#static_cast]]执行了显式的而非隐式的转换。`static_cast`使用`istream`构造函数创建了一个临时的`sales_data`对象。

#### 标准库中含有显式构造函数的类
- 接受一个单参数的`const char*`的`string`构造函数
- 接受一个容量参数的`vector`构造函数是`explicit`的。[[#定义和初始化vector对象]]。


### 聚合类
- **作用：** 使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。

当一个类满足如下条件时，我们就说它是一个聚合类：  
- 所有成员都是public的  
- 没有定义任何构造函数  
- 没有类内初始值  
- 没有基类，也没有 `virtual`函数（15章）。
```c++
struct Data {
	int ival;
	string s;
};
```

聚合类的初始化，使用`{}` ，**值的顺序必须和声明的顺序一致**（这点不同于构造函数的初始化）
```c++
//val1.ival = 0; val1.s = string("Anna")
Data val1 = {0, "Anna"};
```

与[[#定义和初始化内置数组|初始化数组元素]]的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。**初始值列表的元素个数绝对不能超过类的成员数量。**

聚合类显式初始化的三个明显**缺点**：
- 要求类的所有成员都是`public`的。
- 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
- 添加或删除一个成员之后，所有的初始化语句都需要更新。

### 字面值常量类
字面值类型的类可能含有[[#constexpr]]函数成员。这样的成员必须符合`constexpr`函数的所有要求，它们是隐式`const`的。

**字面值常量类**：数据成员都是字面值类型的**聚合类**。如果一个类不是聚合类，但符合以下要求也是**字面值常量类**
- 数据成员都必须是[[#字面值类型]]。
- 类必须至少含有一个`constexpr`构造函数。
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条[[#常量表达式 ]]：或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数。
- 类必须使用[[#析构函数]]的默认定义，该成员负责销毁类的对象。

#### constexpr构造函数
- 构造函数不能是`const`的但是字面值常量类的构造函数可以是`constexpr`
- 一个字面值常量类必须至少提供一个`constexpr`构造函数。

`constexpr`构造函数可以声明成：
- . `=default`
- . 删除函数的形式（13.1.6节）
 - . 既符合构造函数的要求(不能包含返回语句)又符合`constexpr`函数的要求(拥有的唯一可执行语句就是返回语句)。

`constexpr`构造函数体一般来说应该是空的。
通过前置关键字`constexpr`声明`constexpr`构造函数
![[Pasted image 20230116154716.png]]

`constexpr`构造函数必须初始化所有数据成员，初始值或者使用`constexpr`构造函数，或者是一条常量表达式。

`constexpr`构造函数用于生成`constexpr`对象以及`constexpr`函数的参数或返
回类型：
![[Pasted image 20230116154848.png]]


## 类的静态成员
静态的成员（属性，方法）是只有一份的，就是所有的实例对象共享同一个成员。

### 声明静态成员
- 成员的声明之前加上关键字`static`使得其与类关联在一起。
- 静态成员可以是`public`也可以是`private`的。
- 静态数据成员的类型可以是常量、引用、指针、类类型等。
```c++
class Account {
public:
	void calculate() { amount += amount * interestRate; }
	static double rate() { return interestRate; }
	static void rate(double);

private:
	std::string ower;
	double amount;
	static double interestRate;
	static double initRate();
};
```
- 静态成员函数也不与任何对象绑定在一起，它们不包含`this`指针。
- 静态成员函数不能声明成`const`的，而且我们也不能在`static`函数体内使用`this`

### 使用类的静态成员
1. 使用作用域运算符直接访问静态成员： ^6b7f46
```c++
double r;
r = Account::rate;//使用作用域运算符访问静态成员
```
**成员函数不用通过作用域运算符就能直接使用静态成员**

2. 使用类的对象、引用或者指针访问静态成员：
```c++
Account ac1;
Account *ac2 = &ac1;
r = ac1.rate(); //通过Account的对象或引用
r = ac2->rate();//通过指向Account对象的指针

static void rate(double);
```

### 定义静态成员
*通常情况下，类的静态成员不应该在类的内部初始化*。然而，我们可以为静态成员提供`const`整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的`constexpr`。
初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。
```c++
class Account{
public:
	static double rate(){return interestRate}
	static void rate(double);
private:
	static constexpr int period = 30;//period是常量表达式
	double daily_tbl[period];
}
```

即使一个**常量静态数据**成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。
```c++
constexpr int Account::period;//初始值在类的定义内提供
```

### 静态成员能用于某些场景，而普通成员不能
**静态成员独立于任何对象。** 因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常地使用。
![[Pasted image 20230116161032.png]]
>静态数据成员可以是不完个类型，关于不完全类型，参见[[#类类型]]。

静态成员可以作为[[#默认实参]]。

# C++标准库：IO库

## IO类
![[Pasted image 20230117143206.png]]
以为w开头的是宽字符版本，用于操控`wchar_t`类型的数据。宽字符版本的类型和对象在其对应的普通`char`版本的类型定义在同一头文件中。

### IO类型间的关系
类型`ifstream`和`istringstream`都继承自`istream`。则可以像使用`cin`和`cout`一样使用这些对象。

### IO对象无拷贝或赋值
```c++
ofstream out1,out2;
out1 = out2;//错误：不能对流对象赋值
ofstreaem print(ofstream);//错误：不能初始化ofstream参数
out2 = prient(out2);////错误：不能拷贝流对象
```
**由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型**，通常是以引用的方式返回流，且传递和返回的引用不能是`const`

### 条件状态
一个错误IO例子：
```c++
int ival;
cin >> ival;
```
如果我们在标准输出键入 Boo，读操作就会失败。代码中的输入运算符期待读取一个 `int`，但却得到一个字符 B。这样，`cin` 会进入错误状态。一个流一旦发生错误，其后续的IO操作都会失败。

确定流对象的状态：
- 将流当成条件来使用如：`while(cin>>word)`。`while`循环检查>>表达式返回的流的状态，如果输入操作成功，流保持有效状态，则条件为真。
- 利用IO库条件状态判断

#### 查询流的状态
将流作为条件使用，只能告诉我们流是否有效，而无法告诉我们具体发生了什么。IO库定义了一个机器无关的`iostate` 类型，它提供了表达流状态的完整功能。
![[Pasted image 20230117144729.png]]
![[Pasted image 20230117144745.png]]

- `iostate`：供了表达流状态的完整功能。这个类型应作为一个位集合来使用。IO库定义了4个`iostate`类型的`constexpr`值表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符一起使用来一次性检测或设置多个标志位。
- `badbit`：表示系统级错误，如不可恢复的读写错误。通常情况下，一旦`badbit`被置位，流就无法再使用了。在发生可恢复错误后，`failbit`被置位，如期望读取数值却读出一个字符等错误。（例如上例）这种问题同查案是可以修正的，流还可以继续使用。
- 如果到达文件结束位置，`eofbit`和`failbit`都会被置位。
- `goodbit`的值为0，表示流未发生错误。如果`badbit`、`failbit`和`eofbit`任一个被置位，则检测流状态的条件会失败。

标准库定义了一组函数来查询这些标志位的状态。
- `good`操作：在所有错误位均未置位的情况下返回`true`。
- `bad`，`fail`，`eof`：对应错误位被置位时返回`true`。
- 在`badbit`被置位时，`fail`也会返回`true`。
- 使用`good`或`fail`是确定流的总体状态的正确方法。
>[!note]
>实际上，我们将流当作条件使用的代码就等价于`!fail()`。而`eof`和`bad`操作只能表示特定的错误。

#### 管理条件状态
```c++
//rdstate返回一个iostate值，对应当前流状态
auto old_state = cin.rdstate();
//clear无参数版本，清除（复位）所有错误标志位。复位之后调用good为true
cin.clear();
process_input(cin);//使用cin
//setstate作将给定条件位置位，表示发生了对应错误。这里将cin置为原状态
cin.setstate(old_state);

//带参数的clear版本接受一个iostate值，表示流的新状态。用位操作将所需位复位来生成新的状态
cin.clear(cin.rdstate()&~cin.failbit&~cin.badbit)
```


### 管理输出缓冲
每个输出流都管理一个缓冲区，用来保存程序读写的数据，例如：
```c++
os << "please enter a value: ";
```
文本串可能立即打印出来，但也可能被操作系统保存在缓冲区中，随后再打印。缓冲机制可以不用频繁的写设备，使性能有很大的提升。

下面是导致缓冲刷新的原因：
- 程序正常结束，作为 `main` 函数的 `return` 操作的一部分，缓冲刷新被执行。  
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。  
- 我们可以使用操纵符如 `endl` 来显式刷新缓冲区。  
- 在每个输出操作之后，我们可以用操纵符 `unitbuf` 设置流的内部状态，来清空缓冲区。默认情况下，对 `cerr` 是设置 `unitbuf` 的，因此写到 `cerr` 的内部都是立即刷新的。  
- 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，`cin` 和 `cerr` 被关联到 `cout` 。因此读 `cin` 或写 `cerr` 都会导致 `cout` 的缓冲区刷新。

#### 刷新输出缓冲区
除了 `endl` ，IO库中还有两个类似的操纵符用来刷新缓冲区：`flush` 和 `ends`
```c++
cout << "hi!" << endl; // 输出 hi 和一个换行，然后刷新缓冲区
cout << "hi!" << flush; // 输出hi, 然后刷新缓冲区，不附加额外字符
cout << "hi!" << ends; // 输出hi和一个空字符，然后刷新缓冲区
```

- `flush`：刷新缓冲区，但不输出任f可额外的字符
- `ends`：缓冲区插入一个空字符，然后刷新缓冲区：

#### ubitbuf 操纵符
如果想在**每次输出操作后都刷新缓冲区**，我们可以使用 `unitbuf` 操纵符。它告诉流在接下来的操作每次写操作都进行一次 `flush` 操作。而 `nounitbuf` 操纵符则重置流，使其恢复以用正常的系统管理的缓冲区刷新机制：
```c++
cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区
// 任何输出都立即刷新，无缓冲
cout << nounitbuf； // 回到正常的缓冲方式
```
**如果程序崩溃，输出缓冲区不会被刷新**
>当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。

#### 关联输入和输出流
当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。
标准库将cout和cin关联在一起，因此下面语句
```c++
cin >> ival;
```
导致cout的缓冲区被刷新·

**交互式系统通常应该关联输入和输出流。** 这意味着所有输出，包括用户提示信息，都会在读操作之前打印出来。

`tie`函数有两个版本。用于关联流
- 带参数：接受一个指向`ostream`的指针自己关联到此`ostreamo`即，`x.tie(&o)`将流`x`关联到输出流o。
- 不带参数：返回指向输出流的指针。

![[Pasted image 20230117152524.png]]

## 文件输入输出
头文件 `fstream` 定义了三个类型来支持文件IO：
- `ifstream` 从一个给定文件读取数据  
- `ofstream` 向一个给定文件写入数据  
- `fstream` 可以读写给定文件

这些类型提供的操作与 `cin` 和 `cout` 的一样，用IO运算符 （`<<` 和 `>>`） 来读写文件，也可以用`getline`来从一个`ifstream`读取数据
除了继承自`iostream` 类型的行为之外，`fstream` 中定义的类型还增加了一些新的成员来管理与流关联的文件。
![[Pasted image 20230117152738.png]]

### 使用文件流对象
当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。每个文件流类都定义了一个名为`open`的成员函数。
创建文件流对象时，我们可以提供文件名（可选的）。如果提供一个文件名，则 `open` 会自动被调用：
```c++
ifstream in(ifile); // 创建一个 ifstream 流对象 in,并打开给定文件
ofstream out; // 输出文件流对象out,未关联到任何文件
```
文件名`ifile` 是一个 `string` 类型的字符串，在新标准中也可以是 C 风格的字符数组。

#### 用 fstream 代替 iostream&
[[#定义类相关的非成员函数]]中 `read` 和 `print` 的函数原型：
```c++
istream &read(istream &is, Sales_data &item);

ostream &print(ostream &os, const Sales_data &item);
```
在这两个函数中，形参是 `iostream` 类型的引用，我们可以传入其继承类 `fstream` （或 `sstream`) 类型来调用。如果一个函数接受一个 `ostream&` 参数，可以传递给它一个 `ofstream` 对象，对 `istream&`  和 `ifstream` 也是类似的。

在下面的示例中，我们假定输入和输出文件的名字是通过传递给 `main` 函数的参数来指定的：
```c++
ifstream input(argv(1)); // 打开销售记录文件
osftream output(argv[2]); // 打开输出文件
Sales_data total; // 保存销售总额的变量
if (read(input, total)) {
	Sales_data trans;
	while(read(input, trans)) {
		if (total.isbn() == trans.isbn()) {
			total.combine(trans);
		} 
		else {
			print(output, total) << endl;
			total = trans;
		}
	}
	print(output, total) << endl;
} else {
	cerr << "No data?" << endl;
}
```

#### 成员函数open和close
定义一个空文件流对象，调用 `open` 将它与文件关联。
```c++
ifstream in(ifile); // 创建一个iftream 并打开给定文件
ofstream out; // 输出文件流未与任何文件关联
out.open(ifile + ".copy"); // 打开指定文件
```
>如果调用`open`失败，`failbit`会被置位，一般在使用前要检查是否成功打开。
>如果`open`成功，则`open`会设置流的状态，使得`good()`为true。条件检测为true
```c++
if (out) // 检查 open 是否成功
// 成功，可以使用文件
```

一旦一个文件流己经打开，它就保持与对应文件的关联。实际上，对一个己经打开的文件流调用`open`会失败，并会导致`failbit`被置位。
为了将文件流关联到另外一个文件，必须首先关闭己经关联的文件。一旦文件成功关闭，我们可以打开新的文件：
```c++
in.close();//关闭文件
in.open(ifile+"2");//打开另一个文件
```

**当一个`fstream`对象被销毁时，`close`会自动被调用。**

### 文件模式
每个流都有一个关联的**文件模式**，用来指出如何使用文件，如下表
![[Pasted image 20230117154230.png]]
无论用哪种方式打开文件，我们都可以指定文件模式。

指定文件模式的限制：
- 只可以对`ofstream`或`fstream`对象设定`out`模式。
- 只可以对`ifstream`或`fstream`对象设定`in`模式。
- 只有当`out`也被设定时才可设定`trunc`模式。
- 只要`trunc`没被设定，就可以设定`app`模式。在`app`模式下，即使没有显式指定`out`模式，文件也总是以输出方式被打开·
- 默认情况下，即使我们没有指定`trunc`，以`out`模式打开的文件也会被截断。为了保留以`out`模式打开的文件的内容，我们必须同时指定`app`模式，这样只会将数据追加写到文件末尾；或者同时指定`in`模式，即打开文件同时进行读写操作。
- `ate`和`binary`模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。

每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。
- 与`ifstream`关联的文件默认以`in`模式打开
- 与`ofstream`关联的文件默认以`out`模式打开
- 与`fstream`关联的文件默认以`in`和`out`模式打开。

#### 以out模式打开文件会丢弃已有数据
默认情况下，当我们打开一个`ofstream`时，文件的内容会被去弃。
指定app模式，阻止一个`ofstream`清空给定文件内容。
>我的理解是追加写操作。

![[Pasted image 20230117154909.png]]

>[!warning]
>保留被`ofstream`打开的文件中已有数据的唯一方法是显式指定`app`或`in`模式。

#### 每次调用open时都会确定文件模式
对于一个给定流，每当打开文件时，都可以改变其文件模式。
![[Pasted image 20230117155118.png]]
- 第一个`open`调用未显式指定输出模式，文件隐式地以`out`模式打开。通常情况下，`out`模式意味着同时使用`trunc`模式。因此，当前目录下名为`scratchpad`的文件的内容将被清空。
- 当打开名为`precious`的文件时，我们指定了`append`模式。文件中己有的数
据都得以保留，所有写操作都在文件末尾进行。

**在每次打开文件时，都要设置文件模式**，可能是显式地设置，也可能是隐式地设置。当程序未指定模式时，就使用默认值。

## string 流

`sstream`头文件定义了三个类型来支持内存，这些类型可以向`string`写入数据，从`string`读取数据，就像`string`是一个流一样。

- `istringstream`从`string`读取数据。
- `ostringstream`向`string`写数据
- `stringstream`既可以从`string`读数据也可以向`string`写数据。

头文件`sstream`继承自`iostream`，还增加了一些操作。
![[Pasted image 20230118102716.png]]

### 使用isringstream
```c++
struct PersonInfo{
	string name;
	vector<string> phones;
}
string line,word;
vector<PersonInfo> people;
while(getline(cin,line)){
	PersonInfo info;
	istringstream record(line);
	record>>info.name;
	while(record>>word)
		info.phones.push_back(word);
	people.push_back(info);
}
```
- 首先使用`getline`从标准输入读取整条记录。写入`line`
- 创建一个`istringstream`绑定到`line`
- 之后利用`istringstream`循环读取电话号码`word`

### 使用osringstream
```c++
for(const auto &entry:people){
	ostringstream formatted,badNums;
	for(const auto &nums:entry.phones){
		if(!valid(nums)){
			badNums<<""<<nums;
		}else
			formatted<<""<<format(nums);
	}
	if(badNums.str().empty())
		os<<entry.name<<""<<formatted.str()<<endl;
	else
		cerr<<"input error:"<<entry.name<<"invalid number(s)"<<badNums.str()<<endl;
}
```
![[Pasted image 20230118105311.png]]
- `valid`完成电话号码验证
- `formt`改变电话号码格式

# C++标准库：顺序容器
**一个容器就是一些特定类型对象的集合。**

**顺序容器**：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

## 顺序容器概述
标准库中的顺序容器：
![[Pasted image 20230118110324.png]]
- `string`和`vector`：将元素保存在连续的内存空间中。在中间位置添加或者删除元素是非常耗时的。
- `list`和`forward_list`：容器任何位置的添加和删除操作都很快速。但是不支持随机访问，要访问某一元素只能遍历整个容器。
	>与`vector`、`deque`和`array`相比，这两个容器的额外内存开销也很大。
- `deque`：与`string`和`vector`类似，`deque`支持快速的随机访问。与`string`和`vector`一样，在`deque`的中间位置添加或删除元素的代价可能很高，但是在`deque`两端删除或添加元素是很快的。
- `forwardl_ist`和`array`：是新C++标准中添加的类型。
	- `array`：类似于内置数组，不支持添加或者删除元素，以及改变大小。
	- `forwardl_ist`：设计目标是达到与最好的手写的单向链表数据结构相当的性能。没有`size()`操作，保存或者计算大小需要额外的开销，其他容器的`size()`保证是一个快速的常量时间操作。

### 确定使用哪种顺序容器
**通常，使用vector是最好的选择**

选择容器的基本原则：
- 除非你有很好的理由选择其他容器，否则应使用`vector`
- 如果你的程序有**很多小的元素**，且空间的额外开销很重要，则不要使用`list`或`forward_list`。
- 如果程序要求**随机访问**元素，应使用`vector`或`deque`
- 如果程序要求在容器的**中间插入或删除元素**，应使用`list`或`forward_list`
- 如果程序需要在**头尾位置**插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`.
- 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
	- 使用`vector`+`sort`，添加在末尾之后再排序
	- 如果真的必须在中间位置插入则输入阶段使用`list`，输入完成后将内容拷贝到`vector`中。

>如果你不确定应该使用哪种容器，那么可以在程序中只使用`vector`和`list`公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用`vector`或`list`都很方便


## 容器库概览

容器类型的操作：
- 某些操作是所有容器类都提供的。
- 另外一些操作仅针对顺序容器、关联容器或无序容器
- 还有一些操作只适用于一小部分容器

本章主要介绍所有容器都适用的操作和顺序容器的操作。

一般来说，每个容器都定义在一个头文件中，文件与类型名相同。容器均定义为[[#^575c7a|模板类]](必须提供额外信息来生成特定的容器类型。)。
```c++
list<Sales_data> s; // 保存 Sales_data 对象的list
deque<double> d; // 保存 double 的 deque

```

### 对容器可以保存的元素类型的限制
顺序容器几乎**可以保存任意类型的元素。** 
容器元素类型可以是另一个容器：
```c++
vector<vector<string>> lines; // vector 的vector
```

>[!note]
>较旧的编译器可能需要在两个尖括号之间键入空格，
`vector<vector<string> >`。

虽然我们可以在容器中保存几乎任何类型，但某些容器的操作对元素类型有其自己的特殊要求。也就是说我们使用自己定义的类型作为容器元素，容器的有些操作没有在自定义中的类型定义，那么就不能使用这些操作。例如，容器支持 `<` 关系运算，而我们自定义的类型（如 `Sales_data`类）并没有定义 `<` ,这时就不能使用这个运算符（虽然容器支持）。

```c++
// 假定 noDefault 是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); // 正确： 提供了元素初始化器
vector<noDefault> v2(10); // 错误： 调用默认构造函数初始化，但是该类型没有定义默认构造函数
```

- **所有容器共有的操作：**
![[Pasted image 20230118112915.png]]
![[Pasted image 20230118112928.png]] ^fdecfb

### 迭代器
迭代器可以看作是一种特殊的指针.

- 容器迭代器支持的所有操作：
![[Pasted image 20230118113202.png]]
>`forward_list`迭代器不支持递减运算符(`--`)

- 适用于`string`、`vector`、`deque`和`array`的算术运算：[[#迭代器运算]]
![[Pasted image 20230118113412.png]]

#### 迭代器范围
**迭代器范围**：由一对迭代器表示，两个迭代器分别指同一个容器的元素或者尾元素之后的位置，这两个迭代器通常被称为 `begin` 和 `end` 或者`first`和`last`，如下图所示
![[Pasted image 20230118113817.png]]

- `begin` ：指向的是容器的第一个元素，对其解引用操作就可以获取到容器第一个位置元素的值。
- `end` ：指向的是容器最后一个元素的后一个位置 , 对其解引用是无法获取到任何元素的。
这种元素范围被称为左闭区间， 用数学符号描述为:  $[begin,end)$
>第二个迭代器从来都不会指向范围中的最后一个元素，而是指向尾元素之后的位置。
>表示范围自`begin`开始，于`end`之前结束。迭代器`begin`和`end`必须指向相同的容器。`end`可以与`begin`指向相同的位置，但不能指向`begin`之前的位置。

#### 使用左闭合范围蕴含的编程假定
使用左闭合(左闭右开)范围主要是为了方便迭代元素，这种范围具有以下三种性质：
- 如果 `begin` 与 `end` 相等，则范围为空  
- 如果 `begin` 与 `end` 不等，则范围至少包含一个元素，且 `begin` 指向该范围的第一个元素  
- 我们可以对 `begin` 递增若干次， 使得 `begin == end`
```c++
while(begin != end) {
	*begin = val; // 正确： 范围非空， 因此 begin 指向一个元素
	++begin; // 移动迭代器， 获取下一个元素
}
```


### 容器类型成员
下面是容器定义的类型，在这之前我们已经使用过了 `size_type` 、`iterator` 和[[#迭代器类型|const_iterator]]
![[Pasted image 20230118114857.png]]
使用这些类型，我们必须显示说明容器具体的类型
```c++
// iter 是通过 list<string> 定义的一个迭代器类型
list<string>::iterator iter;

// count 是通过 vector<int> 定义的一个 difference_type 类型
vector<int>::difference_type count;
```
通常具体容器的类型别名写起来比较麻烦，一般我们会使用自动类型推断 `auto` 或 `decltype`

### begin和end成员

`begin` 和 `end` 有多个版本：带 `r` 版本返回反向迭代器；以 `c` 开头的版本返回 `const` 迭代器
```c++
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin(); // list<string>::iterator
auto it1 = a.rbegin(); // list<string>::reverse_iterator
auto it1 = a.cbegin(); // list<string>::const_iterator
auto it1 = a.crbegin(); // list<string>::const_reverse_iterator
```
不以 `c` 开头的 函数都是被**重载**过的。也就是说，**实际上有两个名为 begin 的成员**，一个返回常量成员，一个返回非常量成员。
我们对一个非常量对象调用这些成员时，得到的是返回`iterator`的版本。只有在对一个`const`对象调用这些函数时，才会得到一个`const`版本。

当 `auto` 与 `begin` 或 `end` 结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干，如果想使用 `const` 版本可以显示的声明，即使用`cbegin`和`cend`
```c++
auto it = a.being(); // it的类型取决于a的类型
auto it7 = a.begin();//当a是const时，1t7是const_iterator
auto it8 = a.cbegin();//it8是const_iterator
```
当不需要写访问时，应使用 `cbegin` 和 `cend`

### 容器定义和初始化
每个容器类型都定义了一个[[#默认构造函数的作用|默认构造函数]]。**除`array`之外**，其他容器的默认构造函数都会创建一个指定类型的**空容器**，且都可以接受指定容器大小和元素初始值的参数。
![[Pasted image 20230118120510.png]]
>[!warning]
>这些操作适用于大部分的容器，特别注意 `array` 容器的限制比较多。

#### 将一个容器初始化为另一个容器的拷贝
将一个新容器创建为另一个容器的拷贝的方法有两种：
1. 可以直接拷贝整个容器。**要求容器类型和元素类型相同**
2. （`array` 除外）拷贝由一个迭代器对指定的元素范围。**不要求容器类型和元素类型相同**，只要将要拷贝的元素能进行元素转换为要初始化的容器类型即可。
```c++
//每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shalespeare", "Austen"}; // 列表初始化
vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors); // 正确: 拷贝同一类型的整个容器
deque<string> authList(authors); // 错误: 容器类型不匹配

// 正确: 可以将 const char* 元素转换为 string
forward_list<string> words(articles.begin(), articles.end());

// 迭代器it 表示 authors 中的一个元素
deque<string> authList1(authors.begin(), it); // 拷贝元素, 直到(但不包括)it 指向的元素
```
当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

在新标准中，我们可以对一个容器进行**列表初始化**。当这样做时，我们就显式地指定了容器中每个元素的值。对于**除`array`之外**的容器类型，初始化列表还隐含地指定了容器的大小：容器将包含与初始值一样多的元素。

#### 与顺序容器大小相关的构造函数
顺序容器(`array`除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个[[#^815e05|值初始化]]
```c++
vector<int> ivec(10, -1); // 10 个 int 元素，每个都初始化为 -1
list<string> svec(10, "hi！"); // 10 个 string, 每个初始化为 "hi！"
forward_list<int> ivec(10); // 10 个元素， 每个初始化为int默认值 0
deque<string> svec(10); // 10 个元素，每个都是空string
```
如果元素类型是一个类：
	- 具有默认构造函数：可以只提供容器大小
	- 没有默认构造函数：需要参数大小，还需要一个显式的元素初始值。

**只有顺序容器的构造函数才接受大小参数，关联容器并不支持**

#### 标准库array具有固定大小
和内置的数组一样，`array` 必须指定大小，且**不能改变**。
```c++
array<int, 42> // 类型为： 保存42个int的数组 int[42]
array<string, 10> // 类型为： 保存10个string的数组 string[10]
array<string, 10> // 错误， 没有指定容器大小
```
`array` 类型包含两部分：
	- 元素的类型
	- 元素的个数

**`array`的默认构造函数**：使用`array`的默认构造函数生成的`array`是非空的，它包含了与其大小一样多的元素。这些元素都被默认初始化。

如果我们对`array`进行**列表初始化**，初始值的数目必须**等于或小于**`array`的大小。
	- 如果小于则它们被用来初始化`array`中靠前的元素，剩余的元素进行值初始化
	- 如果元素是一个类，那么该类必须要有一个默认的构造函数，以使值初始化能够进行
- 
```c++
array<int , 10> ial; // 10个默认初始化的int
array<int, 10> ia2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 列表初始化
array<int, 10> ia3 = {43}; // ia3[0]为42， 剩余元素为0
```

**对于内置数组不能进行拷贝和对象赋值操作，但 `array` 并没有这种限制**
```c++
int digs[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
itn cpy[10] = digs; // 错误， 内置数组不支持拷贝或赋值
array<int, 10> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
array<int, 10> copy = digits; // 正确，只要数组类型匹配即合法
```
此外，`array` 的赋值和拷贝大小必须要一样，因为大小是 `array` 类型的一部分。

`array`也要求初始值的类型必须与要创建的容器类型相同。


### 赋值和swap
下表中列出的与赋值相关的运算符可用于所有容器：
![[Pasted image 20230118125811.png]]

#### 赋值
赋值操作，会使两个容器大小与右边容器大小相同。
```c++
c1 = c2;//将c1的内容替换为c2中元素的拷贝
c1 = {a,b,c};//赋值后，cl大小为3
```

**array**允许赋值，赋值号左右两边的运算对象必须具有相同的类型：
```c++
array<int, 10> a1 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
array<int, 10> a2 = {0}; // 所有元素均为0
a1 = a2; // 替换a1中的元素
a2 = {0}; // 错误，不能将一个花括号列表赋予数组
```
由于右边运算对象的大小可能与左边运算对象的大小不同，因此 **`array`类型不支持`assign`也不允许用花括号包围的值列表进行赋值。**

#### 使用assign（仅顺序容器）
`assign`运算符：允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。`assign`操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。
```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; // 错误，容器类不匹配， 使用 = 必须两侧类型一样

// 正确： 可以将const char* 转换为 string
names.assign(oldstyle.begin(), oldstyle.end());

//assign也可以接收一个整型值和一个元素值。用指定数目且具有相同给定值的元素替换容器中原有的元素
slit1.assign(10,"Hiya");
//10个元素每个都是“Hiya”
```

#### 使用swap
`swap` 操作交互两个相同类型容器的内容。调用 `swap` 之后，两个容器中的元素将交换。
```c++
vector<string> svec1(10); // 10个元素
vector<string> svec2(24); // 24个元素
swap(svec1, svec2);
```
调用 `swap` 后，`svec1` 将包含24个`string`元素，`svec2`将包含10个`string`， `swap` **只是交互容器的内部数据结构。**

元素不会被移动的事实意味着，除 `string` 外，指向容器的迭代器、引用和指针在 `swap` 操之后都**不会失效**。它们仍指向 `swap` 操作之前所指向的那些元素。但是，在 `swap` 操作之后，这些元素已经属于不同的容器了。例如，假定 `iter` 在 `swap` 之前指向 `svec1[3]` 的 `string`， 那么在 `swap` 之后它指向 `svec[3]` 的元素。

`swap`不对任何元素进行拷贝、删除或插入搡作，因此可以保证在常数时间内完成。

**`array`的`swap`操作**
`swap`两个`array`会真正交换它们的元素。因此，交换两个`array`所需的时间与`array`中元素的数目成正比。
指向容器的迭代器、引用和指针在 `swap` 操之后绑定的元素不变，但是元素值已经与另一个`array`中的对应元素的值进行了交换。

### 容器大小操作

- `size()`  返回容器中的元素数目  
- `max_size()`  返回一个大于或等于该类型容器所能容纳的最大元素数的值。
- `empty()` 若容器中存储了元素，返回 `false` ，否则返回 `true`

**`forward_list`支持`max_size()` 和`empty()`，但不支持`size()`**

### 关系运算符
每个容器类型都支持相等运算符（ `==` 和 `!=` ）；除了无序关联容器外的所有容器都支持关系运算符（ `>`、`>=` 、`<` 、`<=` ）。
**相同容器，相同数据类型**才能使用关系运算符。

比较两个容器实际是进行元素的逐对比较，工作方式和 `string` 的关系运算符类似：
- 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等  
- 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于大容器  
- 如果容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。
```c++
vector<int> v1 = {1, 3, 5, 7, 9, 12};
vector<int> v2 = {1, 3, 9};
vector<int> v3 = {1, 3, 5, 7};
vector<int> v4 = {1, 3, 5, 7, 9, 12};
v1 < v2; // true
v1 < v3; // false
v1 == v4; // true
v1 == v2; // false
```

#### 容器的关系运算符使用元素的关系运算符完成比较

只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。

`Sales_data`类型并未定义`==`和`<`运算。就不能比较保存两个该类型的容器。
````c++
vector<Sales_data> storeA, storeB;
if (storeA < storeB) // 错误：Sales_data 没有 < 运算符
````

## 顺序特有的容器操作
[[#^fdecfb|所有容器共有的操作]]
![[Pasted image 20230118112915.png]]

### 向顺序容器添加元素
**除`array`外，所有标准库容器都提供灵活的内存管理。**
下表列出了向顺序容器**（非`array`）**添加元素的操作。
![[Pasted image 20230122131008.png]]

当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。
- 在一个`vector`或`string`的尾部之外的任何位置，或是一个`deque`的首尾之外的任何位置添加元素，都需要移动元素。
- 向一个`vector`或`string`添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。

#### 使用push_back
`push_back` 是将一个元素追加到容器的尾部，除 `array` 和 `forward_list` ，每个顺序容器都支持该操作。
```c++
// 从标准输入读取数据，将每个单词放到容器末尾
string word;
while (cin >> word)
container.push_back(word);
```
对 `push_back` 的调用在 `container` 尾部创建一个新的元素，将 `container` 的 `size` 增大 1 。该元素的值为 `word` 的一个拷贝。

**容器类型**可以是：`list`、`vector` 或 `deque`

当用一个对象初始化容器时，或将一个对象插入到容器中的是对象的一个拷贝而不是对象本身。

#### 使用push_front

`push_front`将元素插入容器头部。
**容器类型**可以是：`list`、`foward_list`、`deque`。
```c++
list<int> ilist;
// 将元素添加到 ilist 开头
for (size_t ix = 0; ix != 4; ++ix)
ilist.push_front(ix);
```

注意，`deque` 像 `vector` 一样提供了随机访问元素的能力，但它提供了 `vector` 所不支持的 `push_front`。**`deque` 保证在容器尾部进行插入和删除元素的操作都只花费常数时间。** 与 `vector` 一样，在`deque` 尾部之外的位置插入元素会很耗时。

#### 使用insert
`insert` 允许我们在容器的任意位置插入 **0 个**或**多个**元素。
**容器类型**： `vector`、`deque`、`list` 和 `string`。`forward_list` 提供了特殊版本的 `insert`。

**每个`insert`函数都接受一个迭代器作为其第一个参数。** 迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。

C++11 新标准下， `insert` 操作返回指向第一个新加入元素的迭代器。（旧版本的标准库中，这些操作返回 `void` ）。如果范围为空，不插入任何元素，`insert` 操作会将第一个参数返回。

##### 在容器中的特定位置添加元素(单个)
`insert`函数将元素插入到迭代器所**指定的位置之前**。
**接收参数：** 迭代器和一个值。
```c++
//将"He11o！"添加到iter之前的位置
slist.insert(iter,"hello!");
```
>一些容器(`vector`)不支持`push_front`操作，但是可以使用`insert`来插入容器最前面。
>插入到`vector`末尾之外的任何位置都可能很慢
>将元素插入到`vector`、`deque`和`string`中的任何位置都是合法的。然而，这样做可能很耗时。

##### 插入范围内元素(多个元素)

`insert`函数指定数量元素插入到迭代器所**指定的范围之前**。
接收参数有两种：
- 迭代器、一个元素数目、一个值。
- 一堆迭代器或一个初始化列表。


```c++
svec.insert(svec.end(),10,"Anna");
//这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string"Anna"。

vector<string> v = {"quasi", "simba", "frollo", "scar"};
// 将 v 的最后两个元素添加到 slist 的开始位置
slist.insert(slist.begin(), v.end() - 2, v.end());

slist.insert(slist.end(),{"these","words","wiill","go","at","the","end"});

// 运行时错误： 迭代器表示要拷贝的范围，不能指向与目的的位置相同的容器
slist.insert(slist.begin(), slist.begin(), slist.end());
```
**如果我们传递给`insert`一对迭代器，它们不能指向添加元素的目标容器。**

#### 使用insert的返回值
```c++
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
iter = lst.insert(iter, word); // 等价于调用 push_front
```
`insert`返回的迭代器恰好指向这个新元素。

#### 使用emplace操作
C++11 新标准引入三个新成员，这些操作**构造**而不是拷贝元素：
	- `emplace_front`，对应`push_front`
	- `emplace`，对应`insert`
	- `emplace_back`，对应`push_back`

**不同之处**：新标准的三个操作是将**参数传递给元素的构造函数，直接在容器管理的内存空间构造元素**，而 `push` 和 `insert`则是先将元素构造出来，再拷贝到容器的内存空间中。 很显然新标准的插入操作更加的高效。这种差异使得用法也有些许的不同。
```c++
// 在 c 的末尾构造一个 Sales_data 对象
// 使用三个参数 Sales_data 构造函数
c.emplace_back("978-0590353403", 25, 15.99);

// 错误; 没有接受三个参数的 push_back 版本
c.push_back("978-0590353403", 25, 15.99);

// 正确： 创建一个临时的 Sales_data 对象传递给push_back
c.push_back(Sales_data("978-0590353403", 25, 15.99));
```
>调用`emplace_back`时，会在容器管理的内存空间中直接创建对象。
>调用`push_back`则会创建一个局部临时对象，并将其压入容器中。

`emplace` 函数在容器中直接构造元素。参数必须与元素的构造函数相匹配。


### 访问元素
下表列出了我们可以用来在**顺序容器中访问元素的操作**。如果容器中没有元素，访问操作的结果是未定义的。
![[Pasted image 20230122143803.png]]

每个顺序容器(包含`array`)都有一个`front`成员函数。而除`forward_list`之外的所有顺序容器都有一个`back`成员函数。
`back` 和 `front` 分别返回首元素和尾元素的引用：

```c++
// 在解引用一个迭代器或调用 front 或 back 之前检查是否有元素

if(!c.empty())
{
	// val1 和 val2 是 c 中第一个元素值的拷贝
	auto val1 = *c.begin(), val2 = c.front();
	// val3 和val4 是 c 中最后一个元素的拷贝
	auto last = c.end();
	auto val3 = *(--last); // 不能递减 forward_list 迭代器
	auto val4 = c.back(); // forward_list 不支持
}
```
`begin`和`end`是指向首位的迭代器(指针)。
**`back` 和 `front` 返回的是引用**，但是用 `auto` 接受的只是值拷贝，如果需要得到元素的引用，应该使用 `auto&`

#### 访问成员函数返回的是引用
在容器访问元素的成员函数（即 `front` 、`back`、下标和 `at`）返回的都是引用。如果一个容器是一个 `const` 对象，则返回值是一个 `const` 引用。
```c++
if (!c.empty())
{
	c.front() = 42; // front 返回的是第一元素的引用，将42赋予c中的第一个元素
	auto &v = c.back(); // 获得指向最后一个元素的引用
	v = 1024; // 改变c中的元素
	auto v2 = c.back(); // v2 不是一个引用，它是 c.back() 的一个拷贝
	v2 = 0； // 未改变c中的元素
}
```
我们使用`auto`变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将**变量定义为引用类型。**

#### 下标操作和安全的随机访问
- 提供快速随机访问的容器(`string`、`vector`、`deque`和`array`)也都提供下标运算符。
- 下标运算符接受一个下标参数，**返回容器中该位置的元素的引用**。
- **`at`成员函数**：`at`成员函数类似下标运算符，但如果下标越界，at会抛出一个`out_of-range`异常。
```c++
vector<string> svec; // 空vector
cout << svec[0]; // 运行时错误： svec 中没有元素
cout << svec.at(0); // 抛出一个 out_of_range 异常
```


### 删除元素
容器(除`array`)有多种删除元素的方式，下表是与删除相关的成员函数：
![[Pasted image 20230122150033.png]]
删除元素的成员函数并不检查其参数。在删除元素之前，必须确保它们是存在的。

#### pop_front 和 pop_back 成员函数
`pop_front` 和 `pop_back` 成员函数分别删除首元素和尾元素。
- `vector` 和 `string` 不支持 `pop_front` ， 
- `forward_list` 不支持 `pop_back`。
```c++
while (!ilist.empty())
{
	process(ilist.front()); //对ilist 的首元素进行一些处理
	ilist.pop_front(); // 完成处理后删除首元素
}
```

#### 从容器内部删除一个元素
成员函数 `erase` 从容器中指定位置删除元素。
- 可以删除由一个迭代器指定的单个元素，
- 可以删除一对迭代器指定的范围内的所有元素。
两种形式的 `erase` 都返回指向删除的（最后一个）元素之后的位置的迭代器。即， 若 `j` 是 `i` 之后的元素，那么 `erase(i)` 将返回指向 `j` 的迭代器。
```c++
// 循环删除一个list 中的所有奇数元素
list<int> lst = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto it = lst.begin();
while (it != lst.end())
	{
	if (*it % 2)
		it = lst.erase(it);
	else
		++it;
}
```

#### 删除多个元素
接受一对迭代器的`erase`版本允许我们删除一个范围内的元素：
```c++
// 删除两个迭代器表示的范围内的元素
// 返回指向最后一个被删除元素之后位置的迭代器
elem1 =slist.erase(elem1, elem2); // 调用后，elem1 == elem2
```

迭代器 `elem1` 指向我们要删除的第一个元素，`elem2` 指向我们要删除的最后一个元素之后的位置。
```c++
// 删除所有元素
slist.clear(); // 删除人容器中的所有元素
slist.erase(slist.begin(), slist.end()); // 等价调用
```

### 特殊的forward_list操作
`forward_list` 的特殊操作是由该容器的数据结构决定的。
**`forward_list` 是一个单向链表**，下图分别是从 `forward_list` 从删除和添加一个元素的示意图。

![[Pasted image 20230124134549.png]]
<center>删除元素</center>

![[Pasted image 20230124134654.png]]
<center>添加元素</center>

可以看到删除和添加元素都是需要先找到需要删除和添加位置的**前一个位置**的元素。
![[Pasted image 20230124135329.png]]

当在操作 `forward_list` 时，我们必须关注两个迭代器——一个指向我们要处理的元素，另一个指向其前驱。
```c++
// 删除 forward_list 中的奇数元素
forward_list<int> flst = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto prev = flst.before_begin(); // 表示 flst 的 "首前元素"
auto curr = flst.begin(); // 表示 flst 中的第一个元素
while (curr != flst.end())
{
	if (*curr % 2)
		curr = flst.erase_after(prev);
	else
	{
		prev = curr; // 移动迭代器 curr, 指向下一个元素，prev 指向curr 之前的元素
		++curr; 
	}
}
```


### 改变容器大小
`resize`可以用来增大或缩小容器。
>`array`**不支持改变大小**，因为`array`的大小是固定式是`array`的一部分。

- 如果当前大大于所要去的大小，容器后面的元素会被删除。
- 如果当前大小小于新大小，会将新元素添加到容器后。
```c++
list<int> ilist(10,42);//10个int：每个的值都是42
ilist.resize(15);//将5个值为0的元素添加到ilist的末尾
ilist.resize(25,-1);//将10个值为-1的元素添加到ilist的末尾
ilist.resize(5);//从ilist末尾删除20个元素
```
![[Pasted image 20230124152742.png]]
如果容器保存的是**类类型元素**，且`resize`向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供一个默认构造函数。


### 容器操作可能使迭代器失效
向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。
>使用失效的迭代器、指针或引用是严重的运行时错误。


#### 添加操作
在向容器添加元素后：
- 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
- 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
- 对于`list`和`forward_list`，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

#### 删除操作
当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这是很显然的。

当我们**删除**一个元素后：  
- 对于 `list` 和 `forwar_list`，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。  
- 对于 `deque`，
	- 如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。
	- 如果是删除 `deque` 的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；
	- 如果删除首元素，这些也不会受影响。  
- 对于 `vector` 和 `string`，指向被删除元素之前元素的迭代器、引用和指针仍有效。注意：但我们删除元素时，尾后迭代器总是会有效。

#### 编写改变容器的循环程序
![[Pasted image 20230124155702.png]]
- 调用`insert`和`erase`后都更新迭代器，因为他们都会使迭代器失效。
	- `insert`在给定位置之前插入新元素，然后返回指向新插入元素的迭代器。
- 调用`erase`后不必递增迭代器，因为`erase`返回的迭代器已经指向序列中的下一个元素。

#### 不要保存end返回的迭代器
当我们添加/删除`vector`或`string`的元素后，或在`deque`中首元素之外任何位置，原来`end`返回的迭代器总是会失效。
因此，**添加或删除元素的循环程序必须反复调用`end`**，而不能在循环之前保存`end`返回的迭代器，一直当作容器末尾使用。

```c++
// 灾难：此循环的行为是未定义的
auto begin = v.begin(),
end = v.end(); // 保存尾迭代器的值是一个坏主意，一些添加和删除操作会使其失效
while (begin != end) // 循环中添加了新的元素，此时end迭代器已经失效了
{
	// 做一些处理
	// 插入新值，对begin重新赋值，否则的话它就会失效
	++begin; // 向前移动begin，因为我们想在此元素之后插入元素
	begin = v.insert(begin, 42); // 插入新值
	++begin; // 向前移动begin 跳过我们刚刚加入的元素

}
```
**如果在一个循环中插入/删除`deque`、`string`或`vector`中的元素，不要缓存`end`返回的迭代器。**


## vector对象是如何增长的
`vector` `string`是将元素连续存储，在内存中每个元素紧挨着前一个元素。
`vector`和`string` 容器大小是可变的，在我们向容器中添加元素的时候，如果容器此时没有了空间。那么容器会在内存中寻找一个更大的地方，把当前所有元素**复制**到新的位置，然后添加新的元素，释放原来的存储空间。如果在容器满了之后，每添加一个元素，`vector` 就执行一次内存分配和释放操作，性能会慢到不可接受。

为了减少容器空间重新分配次数，标准库的实现一般采用这样的策略：
	- 当需要分配新的通常会分配比新空间需求更大的内存空间，比如说分配当前空间的 2 倍（不同的标准库实现可能不同）。

#### 管理容量的成员函数
下表容器大小的相关操作。
`vector`和`string`类型提供了一些成员函数，允许我们与它的实现中内存分配部分互动。

以下三种操作均不会减少容器预留的内存空间：
- `capacity` 操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素，
- `reserve` 操作允许我们通知容器它应该准备保存多少个元素。调用reserve永远不会减少容器占用空间。
	- 如果需求大小小于当前容量，那么`reserve`至少分配与需求一样大的内存空间。
	- 如果需求大小小于或等于当前容量，`reserve`什么也不做。
- `resize`操作也只改变容器中元素的树木，而不是容器的容量。
![[Pasted image 20230124161832.png]]
>`reserve`并不改变容器中元素的数量，它仅影响`vector`预先分配多大的内存空间。

如果要减少容器的内存空间：
新标准库中，可以调用`shrink_to_fit`来要求`deque`、`vector`或`string`退回不需要的内存空间。但是在不同的标准库的实现可能不同，有的可能并不保证一定退回内存空间。

#### capacity和size
- `capacity` 是容器的空间大小（可以存放元素的个数）。
- `size` 是容器当前元素的个数。
两者的关系是 `capacity` 大于等于 `size`。具体两者相差多少取决于标准库的实现中对内存空间的分配策略。
```c++
vector<int> ivec;
cout << " ivec: size: " << ivec.size()
<< " capacity: " << ivec.capacity() << endl;

for (vector<int>::size_type ix = 0; ix != 24; ix++)
{
	ivec.push_back(ix);
}
cout << " ivec: size: " << ivec.size()
<< " capacity: " << ivec.capacity() << endl;
```
输出如下：
```shell
ivec: size: 0 capacity: 0
ivec: size: 24 capacity: 28
```
`ivec`的空间状态如下：
![[Pasted image 20230124163020.png]]

之后可以使用`reserve`给容器分配内存空间。
只要还有空间，就没有必要为vector分配新的空间。实际上，只要没有操作需求超出`vector`的容量，`vector`就不能重新分配内存空间。
如果分配的空间过大，也可以调用`shrink_to_fit`将多余的内存退回给系统。
![[Pasted image 20230124163333.png]]
>值得注意的是，调用`shrink_to_fit`只是一个请求，标准库并不保证退还内存。

可能重新分配内存空间的情况：会分配多少超过给定容量的额外空间，取决于具体实现。
- 在执行`insert`操作时`size`和`capacity`相等。
- 调用`resize`或`reserve`时给定的大小超过当前`capacity`，


## 额外的string操作
除了顺序容器共同的操作之外，`string` 类型还提供了一些额外的操作。

### 构造string的其他方法
此前介绍的构造string的方法：
- [[#定义和初始化string对象]]中介绍了构造`string`的方法。
	- 直接初始化
	- 拷贝初始化
- 可以使用与其他顺序容器的相同的构造函数。[[#容器定义和初始化]]

**`string`类型还支持另外三个构造函数：** 这些构造函数接收一个`string`或一个`const char*`参数，还接受(可选的)指定拷贝多少个字符的参数。
![[Pasted image 20230124164123.png]]

- 当我们传递一个string时，还可以给定一个下标来指出从哪里开始拷贝
```c++
const char *cp = "Hello World!!!"; // 以空字符结束的数组，C风格字符串会自动添加空字符串'\o'在末尾
char noNull[] = {'H', 'i'}; // 不是以空字符结束
string s1(cp); // 拷贝cp中的字符直到遇到空字符； s1 == "Hello World!!!"
string s2(noNull, 2); // 从 noNull 拷贝两个字符； s2 == "Hi"
string s3(noNull); // 未定义： noNull 不是以空字符结束
string s4(cp + 6, 5); // 从 cp[6] 开始拷贝5个字符； s4 == "World"
string s5(s1, 6, 5); // 从 s1[6] 开始拷贝5个字符； s5 == "World"
string s6(s1, 6); // 从 s1[6] 开始拷贝，直至 s1 末尾； s6 == "World!!!"
string s7(s1, 6, 20); // 正确， 只拷贝到 s1 末尾； s7 == "World!!!"
string s8(s1, 16); // 抛出一个 out_of_range 异常
```
- 通常当我们从一个`const char*`创建`string`时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。
	- 如果传递给构造函数一个计数值，数组就不必以空字符结尾。
	- 如果我们未传递计数值，也未以空字符结尾；或者给定计数值大于数组大小，则构造函数的行为是未定义的。
- 当从一个`string`拷贝字符时，我们可以提供给一个可选的开始位置和计数值。
	- 开始位置：必须小于或等于给定`string`的大小，如果大于`size`，则抛出`out_of_range`异常。
	- 计数值：传递了计数值，则从给定位置开始拷贝这么多个字符。不管计数值多少，最多拷贝到`string`结尾。

#### substr操作
`substr`操作：返回一个`string`，它是原始`string`一部分或全部的拷贝。
- `substr`参数：
- 一个**可选的开始位置**：如果开始位置超过了`string`的大小，则`substr`函数抛出一个`out_of_range`异常。
- **计数值：** 如果开始位置加上计数值大于`string`的大小，则`substr`会调整计数值，只拷贝到`string`末尾。
```c++
string s("hello world");
string s2 = s.substr(0, 5); // s2 = hello
string s3 = s.substr(6); // s3 = world
string s4 = s.substr(6, 11); // s4 = world (书中写的： s3 = world)
string s5 = s.substr(12); // 抛出一个 out_of_range 异常
```
![[Pasted image 20230124165524.png]]

### 改变string的其他方法
- `string` 类型除了顺序容器共有的一些操作（赋值运算符、`assign`、`insert`、`erase`），它还**定义了额外的 `insert` 和 `erase` 版本，** 即使用下标的版本
```c++
s.inert(s.size(),5,'!');//在s末尾插入5个感叹号
s.erase(s.size()-5,5);//从s删除最后5个字符。
```

- 标准库`string`类型还提供了接受[[#C风格字符串|C风格字符数组]]的`insert`和[[#使用assign（仅顺序容器）|assign]]版本。
```c++
const char *cp = "Stately,plump Buck";
s.assign(cp,7);//s=="Stately"
s.insert(s.size(),cp+7);//s=="Stately,plump Buck"
```

- 可以指定将来自其他`string`或子字符串的字符插入到当前中或赋予当前`string`
```c++
string s = "some string",s2 = "some other string"
s.insert(0,s2);//在s中位置0之前插入s2的拷贝

//在s[0]之前插入s2中s2[0]开始的s2.size()个字符
s.insert(0,s2,0,s2.size())
```

#### append和replace函数
`string`类定义了两个额外的成员函数：`append`和`replace`，这两个函数可以改变`string`的内容。
	![[Pasted image 20230124170617.png]]
![[Pasted image 20230124171203.png]]

- `append`是在末尾进行`insert`
```c++
string s("hello "),s2 = s;
s.insert(s.size(),"world");
s2.append("world");
//s和s2均为"hello world"

```

- `replace`操作是调用`erase`和insert的一种简写形式
```c++
s.erase(6,5);//s=="hello"
s.insert(6,"C++");//s=="hello C++"

//从位置6开始，删除5个字符并插入"C++"
s2.replace(6,5,"C++")

//删除和插入不一定非要一样长。
```

#### 改变string的多种重载函数
`append`、`assign`、`insert`和`replace`函数有多个重载版本。根据我们如何指定要添加的字符和`string`中被替换的部分，这些函数的参数有不同版本。

`assign`和`append`函数无须指定要替换`string`中哪个部分：
- `assign`总是替换`string`中的所有内容
- `append`总是将新字符追加到`string`末尾。

- 添加字符时：当字符来自于一个`string`或一个字符指针时，我们可以传递一个额外的参数来控制是拷贝部分还是全部字符。

- `insert`不支持下标和初始化列表参数。


### string搜索操作
`string`类提供了6个不同的搜索函数，每个函数都有4个重载版本。
- 搜索成功：每个搜索操作都法案会一个`string::size_type`值，表示匹配发生位置的下标。
- 搜索失败：返回一个名为`string::npos`的`static`成员([[#类的静态成员]])
>由于`npos`是一个`unsigned`类型，此初始值意味着`npos`等于任何`string`，最大的可能大小。
![[Pasted image 20230124172546.png]]
![[Pasted image 20230124172554.png]]

**这节先略，到时候用到了再回来看，对应书里P325**


### compare函数
`compare` 函数,与C标准库的`strcmp`函数很相似，有6个版本，如下表
![[Pasted image 20230124172831.png]]

类似于`strcmp`，
- s等于参数指定字符串时，返回0
- s大于参数指定字符串时，返回正数。
- s小于参数指定字符串时，返回负数。


### 数值转换
数值数据与标准库`string`之间的转化。
```c++
int i = 42;
string s=to_string(i);//将整数i转换为字符表示形式
double d = stod(s);//将字符串s转换为浮点数
```

要转换成数值的string中的第一个非空白字符必须是数值中可能出现的字符：
```c++
string s2 = "pi = 3.14";
//转换s中以数字开始的第一个子串，结果d=3.14。
3．14
d = stod(s2.substr(s2.find_first_of("+1.0123456789")));
```
- 调用了`find_first_of`来获取s中第一个可能是数值的一部分的字符位置。
- `string`参数中第一个非空白符必须是符号（+或-）或数字。它可以以0x或0×开头来表示十六进制数。
	- 对于将字符串转换为浮点值的函数，`string`参数也可以以小数点(`.`)开头，并用e或者E来表示指数部分。
我们将`s`中从此位置开始的子串传递给`stod`，`stod`函数读取此参数，处理其中的字符，直至遇到不可能是数值的一部分的字符。然后它就将找到的这个数值的字符串表示形式转换为对应的双精度浮点值。

`string` 提供的数值转换操作如下表。
![[Pasted image 20230124173101.png]]
>如果`string`不能转换为一个数值，这些函数抛出一个`invalid_argument`异常。如果转换得到的数值无法用任何类型来表示，则抛出一个`outof_range`异常


## 容器适配器
除了顺序容器外，标准库还定义了三个顺序容器适配器：`stack`、`queue` 、`priority_queue`。
**适配器** 是标准库中的一个通用概念。容器、迭代器和函数都有适配器。**本质上，一个适配器是一种机制**。
作用：**能使某种事物的行为看起来像另外一种事物一样。** 

>如果一个顺序容器调用了stack适配器，那么就可以说这个顺序容器具有了栈机制（后进先出）。
一个适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。比如，`stack` 适配器接受一个顺序容器（除 `array` 或 `forward_list` 外），并使其操作起来像一个 `stack` 一样。


下表列出了**所有容器适配器都支持**的操作和类型。
![[Pasted image 20230124174105.png]]

### 定义一个适配器
每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。
```c++
//利用deq<int>初始化适配器
stack<int> stk(de); // 从 deq 拷贝元素到 stk
```

默认情况下，`stack`和`queue`是基于`deque`实现的。
`priority_queue`是在`vector`之上实现的。

我们可以在创建一个适配器时将一个**命名的顺序容器**作为**第二个类型参数**，来**重载**默认容器类型：
```c++
// 在 vector 上实现的空栈，因为没有传入顺序容器来初始化
stack<string, vector<string>> str_stk;
// str_stk2 在 vector 上实现，初始化时保存 svec 的拷贝
stack<string, vector<string>> str_stk2(svec)；
```

适配器支持的容器类型：
- `stack` 只要求 `push_back`、`pop_back` 和 `back` 操作，因此可以使用除了 `array` 和 `forward_list` 之外的任何容器构造 `stack`。  
>[!note]
>- 所有适配器都要求容器具有添加和删除元素的能力。所以适配器不能构造在`array`之上。
>- 所有适配器都要求容器具有添加、删除以及访问尾元素的能力。所以适配器也不能构造在`forward_list`之上。
- `queue` 适配器要求 `back` 、`push_back` 、`front` 和 `push_front` ，因此它可以构造于 `list` 或  `deque` 之上，但不能基于 `vector` 构造。  
- `priority_queue` 除了 `front` 、`push_back` 和 `pop_back` 操作之外还要随机访问能力，因此它可以构造于 `vector` 或 `deque` 之上，但不能基于 `list` 构造。

#### 栈适配器
`stack`类型定义在`stack`头文件中

- 栈支持的操作：
![[Pasted image 20230124175408.png]]

- 栈的使用：
```c++
stack<int> intStack; // 空栈
// 填满栈
for (size_t ix = 0; ix != 10; ++ix)
	intStack.push(ix); // intStack 保存 0 到 9 十个数
while (!intStack.empty())
	{ // intStack 中有值就继续循环
	int value = intStack.top();
	// 使用栈顶值得代码
	intStack.pop(); // 弹出栈顶元素，继续循环
}
```
`stack`是基于`deque`实现的，但我们不能直接使用`deque`操作。

#### 队列适配器
`queue`和`priority_queue`适配器定义在`queue`头文件中。

- `queue`和`priority_queue`支持的操作
![[Pasted image 20230124175838.png]]
![[Pasted image 20230124175847.png]]

标准库`queue`使用一种**先进先出**存储和发访问策略：进**入**队列的对象被放置到**队尾**，而离开队列的对象则从**队首删除**。

`priority_queue`允许我们为**队列**中的元素**建立优先级**。
**新加入的元素会排在所有优先级比它低的己有元素之前。**

>[!note]
>- **队列**类比：饭店按客人到达的顺序来
>- **优先级队列**类比：饭店按照客人预定时间而不是到来时间的早晚来为他们安排座位。




