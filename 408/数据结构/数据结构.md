# 栈和队列
![[Pasted image 20230401203537.png]]

## 中缀表达式转后缀/前缀表达式
### 中缀表达式转后缀表达式手算
1. 确定中缀表达式中各个运算符的运算顺序。
2. 选择下一个运算符按照【左操作数，右操作数，运算符】的方法组合成一个新的操作数
3. 如果还有运算符没有被处理则继续执行。步骤2.
**中缀转换后缀方法结果不唯一**，一般情况下遵循**左优先**原则。
>如果是中缀转前缀，那么运算符按照【运算符，左操作数，右操作数】，并且遵循右优先原则。
![[925eae58838bf3d372f70240f2c5804.jpg]]

### 中缀表达式转后缀表达式（机算）
**栈的个数以及作用**：只需要**一个栈**，用于**保存操作符**。
![[Pasted image 20230401204333.png]]
![[c858b9c80753c507b23e187ee5a9e73.jpg]]

## 通过后缀/前缀计算表达式的值
### 通过后缀/前缀计算表达式的值（手算）
从左往右，每遇到一个运算符就让运算符前面最近的两个操作数执行对应的操作，合成一个新的操作数。
![[001740cd1bd9304cf4837e74d008d9f.jpg]]


### 通过后缀/前缀计算表达式的值（机算）
- **栈的个数以及作用**：一个栈用于**保存操作数**。

- 算法步骤：
从**左到右**（前缀则是从右往左）顺序扫描表达式的每一项，根据其类型执行对应的操作。当所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。
	-  该项是**操作数**，则压**入栈**中。
	- 该项是操作符，则从栈中弹出两个操作数（先出栈的为右操作数，如果是前缀先出栈的为左操作数），执行运算，然后把运算结果重新压入栈中。
![[c3e3da8ebbd5bfdea02120fe2b123b7.jpg]]



## 通过栈计算中缀计算表达式的值
- **栈的个数以及作用**：两个栈，一个操作数栈一个运算符栈。
- 算法：[[#中缀表达式转后缀表达式（机算）]]+[[#通过后缀/前缀计算表达式的值（机算）]]
![[Pasted image 20230401205623.png]]
![[5c8bbbef9186c562b36a9639e295248.jpg]]

![[Pasted image 20230401210035.png]]

## 特殊矩阵的压缩存储
![[Pasted image 20230401224344.png]]

![[Pasted image 20230401224531.png]]

![[Pasted image 20230401224649.png]]

# 串
## 求子串。
![[Pasted image 20230403220414.png]]
- 条件判断语句：如果当前截取的子串中包含空字符则返回`false`

## 比较串
![[Pasted image 20230403220650.png]]

## 定位操作
![[Pasted image 20230403221007.png]]

## 串的模式匹配
### 朴素模式匹配算法
主串长度为 n ， 模式串长度为m
朴素模式匹配算法 ： 将主串所有长度为 m 的所有的子串依次与模式串对比， 直到找到一个完全匹配的子串 ，或所有子串都不匹配为止。
**最多对比n-m+1个子串**
![[Pasted image 20230403222405.png]]
![[Pasted image 20230403222223.png]]

### KMP算法
![[Pasted image 20230403224458.png]]

**优化**
![[Pasted image 20230404220720.png]]
**跳步**，如果当前一次跳转之后的指向的值仍然是与当前值相同时，则说明跳转之后肯定也不匹配，所以还要（至少）跳转一次，则应该取**跳转值的next**进行第二次跳转。

# 树

## 树的性质
![[Pasted image 20230405194325.png]]

## 线索二叉树

### 中序线索化

![[Pasted image 20230408193551.png]]

### 先序线索化
![[Pasted image 20230408194103.png]]
**可能存在的问题**：当`visit`D节点时，`visit`函数把D的左指针指向了其先序前驱节点，当回到主函数`PreThread`时，执行`PreThread(T->lchild)`操作会使其回到其前驱B，而B执行到`PreThread(T->lchild)`，时又会回到D，这样会形成死循环。

**改进**：在visit左孩子前判断是否已经线索化
![[Pasted image 20230408194543.png]]

整体代码：
![[Pasted image 20230408194610.png]]

### 后序线索化
![[Pasted image 20230408194729.png]]
**不会出现先序线索化的问题**，因为左右孩子节点的访问在访问该节点之前已经处理完毕。


### 二叉树线索化注意点
![[Pasted image 20230407215031.png]]

## 线索二叉树找前驱/后继
### 中序线索二叉树
#### 中序线索二叉树找后继
![[Pasted image 20230408195334.png]]

![[Pasted image 20230408195449.png]]
##### 代码实现
![[Pasted image 20230408195609.png]]
由于可以找到一个节点在中序序列中的后继节点，所以可以进行遍历。

#### 中序线索二叉树找前驱
![[Pasted image 20230408195920.png]]


### 先序线索二叉树
#### 先序线索二叉树找先序后继
![[Pasted image 20230408200242.png]]
- 如果p有左孩子，那么先序后继则是左孩子
- 如果p没有左孩子，那么先序后继是右孩子。

#### 先序线索二叉树找先序前驱
因为先序遍历是按照，根-左-右的顺序进行访问，所以p的左右孩子节点不可能是p的先序前驱。因此在节点只有左右孩子指针的情况下是**无法找到先序前驱**。

- 找到先序前驱只能通过：
1. 引入指向双亲的指针，即构造三叉链表。
2. 重新遍历二叉树。

* **在能找到前序前驱的情况**（使用三叉链表）下：p的先序前驱有4种情况。
![[Pasted image 20230408201434.png]]


### 后续线索二叉树
#### 后续线索二叉树找后续前驱
![[Pasted image 20230408201704.png]]
- 如果p有右孩子，那么先序后继则是右孩子
- 如果p没有右孩子，那么先序后继是左孩子。


#### 后续线索二叉树找后续后继
后序遍历中按照左-右-根的顺序进行访问， 左右子树中的结点只可能是根的前驱 ， 不可能是后继。

- 找到后续后继只能通过：
1. 引入指向双亲的指针，即构造三叉链表。
2. 重新进行后序遍历二叉树。

* **在能找到后序后继的情况**（使用三叉链表）下：p的后序后继有4种情况。
![[Pasted image 20230408202252.png]]

### 总结
![[Pasted image 20230408202326.png]]
![[Pasted image 20230407221408.png]]
![[Pasted image 20230408202438.png]]

## 树木、森林、与二叉树
### 树、森林、与二叉树的转换
![[Pasted image 20230408223221.png]]

### 树和森林的遍历
#### 树
##### 树的先根遍历
![[Pasted image 20230408223436.png]]

##### 树的后根遍历
![[Pasted image 20230409185636.png]]
**树的后根遍历**序列与其转成的**二叉树的中序遍历**序列相同

#### 森林
##### 森林的先序遍历
![[Pasted image 20230409190247.png]]

也可以将森林转化为二叉树，求二叉树的先序遍历序列


##### 森林的中序遍历
![[Pasted image 20230409190451.png]]
森林的中序遍历等同于对**各个树**进行**后根遍历**

也可以将森林转化成二叉树，对**二叉树**进行**中序遍历**。

#### 总结
![[Pasted image 20230409190757.png]]
森林和树的先序，与其二叉树的先序相同。
森林的树的后序，与其二叉树的中序相同。
> 森林的后序遍历中序遍历，因为对应其二叉树的中序，但是因为森林根节点是最后访问，所以也可以叫做后序遍历。

## 并查集
### 并查集优化
![[Pasted image 20230409223927.png]]
![[Pasted image 20230409224254.png]]
![[Pasted image 20230409224541.png]]
