# C++标准库：泛型算法

## 10.1 概述
- 大多数算法都**定义在头文件 algorithm** 中。
- 标准库还在**头文件 numeric** 中定义了一组**数值泛型算法**。  
- 一般情况下，这些算法并**不直接操作容器**，而是遍历由两个迭代器指定的一个元素范围来进行操作。
	- `find` 算法示例
```c++
int val = 42; // 我们将查找的值

// 如果在vec 中找到想要的元素，则返回结果指向它，否则返回结果为第二个参数表示搜索失败。
auto result = find(vec.cbegin(), vec.cend(), val);

// 报告结果
cout << "The value " << val<< (result == vec.cend()? " is not present" : " is present") << endl;
```

#### 算法如何工作
以`find`算法为例：
- `find`的工作是在一个未排序的元素序列中查找一个特定的元素。步骤如下：
1. 访问序列中的首元素。  
2. 比较此元素与我们要查找的元素。  
3. 如果此元素与我们要查找的值匹配，`find` 返回标识此元素的值。  
4. 否则，`find` 前进到下一个元素，重复执行步骤 2 和 3。  
5. 如果达到序列尾，`find` 应停止。  
6. 如果 `find` 达到序列末尾，它应该返回一个指出元素未找到的值。此值和步骤 3 返回的值必须具有相容的类型。
这些步骤都**不依赖于容器所保存的元素类型。** 因此，只要有一个**迭代器**可用来访问元素， `find` 就完全不依赖于容器类型。

#### 迭代器令算法不依赖于容器
上述的 `find` 函数的流程中，除了第 2 步外，其他步骤都可以用迭代器操作来实现。

#### 但算法依赖于元素类型的操作
虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个（或多个）元素类型上的操作。
例如，在步骤 2 中，`find` 用元素类型的 `==` 运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持 `<` 运算符。不过，我们将看到，大多数算法提供了一种方法，允许我们使用自定义的操作来替代默认的运算符。

>[!warning]
>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。


## 10.2 初识泛型算法
标准库提供了超过100个算法，这些算法都是有一致的结构，下面以几种具体的算法为例介绍标准库中算法的结构。

### 10.2.1 只读算法
- **只读算法：** 只会读取其输入范围内的元素，而从不改变元素。
>例如，`find`算法，`accumulate`算法，`equal`算法。

#### `accumulate`算法
- `accumulate`算法：对一个序列进行求和。定义在头文件`numeric`中。接受三个参数：
	- 前两个参数：指出了需要求和的元素的范围
	- 第三个参数：是和的初始值。

```c++
// vec 是一个整数序列
// 对 vec 中的元素求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```
>`accumulate` 的第三个参数的类型决定了函数中使用哪个加法运算符以及返回的类型.

#### 算法和元素类型
`accumulate` 将第三个参数作为求和起点，这蕴含这一个编程假定： 
- 将元素类型加到和的类型上的操作必须可行。 即**序列中的元素的类型必须与第三个参数匹配**，或者**能够转换**为第三个参数的类型，如果类型是自定义类型，那么自定义类型必须定义 `+` 运算符。

```c++
// v 的类型是 vector<string>
string sum = accumulate(v.cbegin(), v.cend(), string("")); // 正确，string可以使用+进行连接

string sum = accumulate(v.cbegin(), v.cend(), ""); // 错误： const char* 上没有定义 + 运算符
```
在第二个求和的调用中，第三个参数是字符串字面值，类型是 `const char*` ，由于 `const char*` 并没有 `+` 运算符，此调用将产生编译错误。

>对于**只读取而不改变元素**的算法，通常最好使用 `cbegin()` 和 `cend()` 。如果需要改变元素则使用 `begin()` 和 `end()`。

#### 操作两个序列的算法
- `equal` 算法：用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。
	- 如果所有对应元素都相等，则返回 `true` ， 否则返回 `false` 。
	- 此算法接受三个迭代器：
		- 前两个参数：表示第一个序列中的元素范围，
		- 第三个参数：表示第二个序列的首元素（指需要比较的元素范围的起始位置）
```c++
// roster2 中的元素数目应该至少与 roster1 一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```
由于 `equal` 利用迭代器完成，因此我们可以调用 `equal` 来**比较两个不同类型的容器中的元素**。而且**元素类型也不必一样**，**只要我们能用 `==` 来比较两个元素类型即可**（即两个类型需要有重载的 `==` 支持它们之间进行比较）。

但是，`equal` 基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。
>[!warning]
>那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。如`equal`等

### 10.2.2 写容器元素的算法
一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意**确保序列原大小至少不小于我们要求算法写入的元素数目**。因为算法不会执行容器操作，它们自身不能改变容器的大小。

- **算法 `fill` ：** 它的接受一对迭代器表示一个范围，还接受一个值作为第三个参数。 `fill` 将给定的这个值赋予输入序列中的每个元素。
```c++
fill(vec.begin(), vec.end(), 0); // 将每个元素重置 0

// 将容器的一个子序列设置为10
fill(vec.begin()， vec.end() + vec.size()/2, 10)
```
由于`fill`向给定输入序列中写入数据，因此，只要我们传递了一个有效的输入序列，写入操作就是安全的。

>[!note]
>一些算法接收两个序列。第二个序列参数传递的方式有两种：
>- 用单一迭代器表示第二个序列：必须保证第二个序列至少比第一个一样长。如果第二个序列是第一个序列的子集，那么将会产生一个严重的错误。算法会试图访问第二个序列末尾之后不存在的元素。
>- 用两个迭代器表示第二个序列。

#### 算法不检查写操作
一些算法接受一个迭代器来指出起始位置，使用一个计数值表示需要写入的个数。
- `fill_n` 函数接受一个单迭代器、一个计数值和一个值，它的功能是从给定迭代器的位置写入 “计数值” 个*数*，*这个数*是由第三个参数给出。
	- 第一个参数：迭代器表示写入目的位置
	- 第二个参数：写入的个数
	- 第三个参数：写入的值
```c++
vector<int> vec; // 空vector

// 使用 vec，赋予它不同的值

fill_n(vec.begin(), vec.size(), 0); // 将所有元素重置为0
```

函数 `fill_n` 假定`dest`指向一个元素，而从`dest`开始的序列至少包含`n`个元素。 `fill_n`假定写入指定元素是安全的，即，如下形式的调用：
```c++
fill_n(dest, n, val)

vector<int> vec; // 空vector
// 灾难：修改 vec 中的10个（不存在）元素
fill_n(vec.begin(), 10, 0);
```

>[!warning]
>- 如果容器不包含写入位置的元素，那么则不能使用该算法。例如，空容器。
>- 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素  
>- 算法并不会检查写入元素的个数，也不会自动改变容器的大小

#### 介绍back_inserter
- **插入迭代器**：是一种向容器添加元素的迭代器。
- 使用**插入迭代器**：保证调用写入算法有足够的空间来容纳输出数据。
- **插入迭代器与普通迭代器比较**：通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个**插入迭代器赋值**时，一个与赋值号右侧值相等的元素被添加到容器。
- 调用`back_inserter` 即可获取到容器的插入迭代器，它定义在头文件iterator中。
	- 接收的参数：一个指向容器的引用。
	- 返回值：一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中。

```c++
vector<int> vec; // 空 vector

// it 的类型为 std::back_insert_iterator<std::vector<int>>
auto it = back_inserter(vec); // 通过它赋值会将元素添加到 vec 中
*it = 42; // 42会添加到vec中
```

在算法中，常常使用`back-inserter`来创建一个迭代器，作为目的位置使用：
```c++
vector<int> vec; // 空 vector

// 正确：back_inserter 创建一个插入迭代器，可用来向vec添加元素
fill_n(back_inserter(vec), 10, 0); // 添加 10 个元素到 vec
```
>在每步迭代中，`fill_n`向给定序列的一个元素赋值。由于我们传递的参数是`back-inserter`返回的迭代器，因此每次赋值都会在`vec`上调用`push_back`.最终，这条`fill_n`调用语句向`vec`的末尾添加了10个元素，每个元素的值都是0

#### 拷贝算法
- **拷贝算法**：拷贝算法(`copy`)是一个向目的位置迭代器指向的输出序列的元素写入数据的算法。此算法接受三个迭代器：
	- 前两个参数：表示一个输入范围。
	- 第三个参数：表示目的序列的起始位置。 目的序列至少要包含与输出序列一样多的元素。

- 使用 `copy` 实现内置数组的拷贝：
```c++
int a1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

int a2[sizeof(a1)/sizeof(*a1)]; // a2和a1大小一样

// ret 指向拷贝到 a2 的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2); // 把 a1 的内容拷贝给 a2
```
>使用[[CPP#sizeof运算符|sizeof]]确保a2与数组a1包含同样多的元素。a1可以理解为指向数组第一个元素的指针，解引用得到第一个的值

`copy` 放回的是其目的位置迭代器（递增后）的值。即，`ret` 指向拷贝到 `a2` 的尾元素之后的位置。

多个算法都提供所谓的“拷贝"版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。
例如，比如 `replace` 和 `replace_copy`  （拷贝版本）
这两个函数都是替换序列中元素的值。`replace` 接受 4 个参数： 前两个是迭代器，表示输出序列，后两个一个是要被替换的值，另一个是替换后的新值。
```c++
// 将ilst 中所有值为 0 的元素改为 42
replace(ils.begin(), ilst.end(), 0, 42);
```
**`replace` 是在原始序列上改动，而 `replace_copy` 是将改动后的序列拷贝一份，原序列保持不变。** 此算法接受额外第三个迭代器参数，指出调整后序列的保存位置。
```c++
// 使用 back_inserter 按需要增长目标序列
replace_copy(ilst.cbegin(), ils.cend(),back_inserter(ivec), 0, 42);
```
此调用，`ilst` 并未改变，`ivec` 包含 `ilst` 的一份拷贝，不过原来 `ilst` 中的值为 0 的元素在 `ivec` 中都变为 42


### 10.2.3 重排容器元素的算法
**排序算法**：这类算法是利用元素类型的 `<` 运算符来实现排序的。  
  
下面以一段文本为例，这段文本保存在 `vector` 中，我们希望简化这个 `vector` ，使得每个单词只出现一次。
```Plain Text
the quick red fox jumps over the slow red turtle
```
去重排序后的 `vector`：
```Plain Text
fox jumps over quick red slow the turtle
```

#### 消除重复单词
为了消除重复单词，首先将`vector`排序，使得重复的单词都相邻出现。一旦`vector`排序完毕，我们就可以使用另一个称为`unique`的标准库算法来重排`vector`，使得不重复的元素出现在`vector`的开始部分。
>由于算法不能执行容器的操作，我们将使用`vector`的`erase`成员来完成真正的删除操作：
```c++
void eliDups(vector<string> &words)
{
	// 按字典排序 words ，以便查找重复单词
	sort(words.begin(), words.end());
	// unique 重排输入范围，使得每个单词只出现一次
	// 排序在范围的前部，返回指向不重复区域之后一个位置的迭代器
	auto end_unique = unique(words.begin(), words.end());
	// 使用容器操作 erase 删除重复元素
	words.erase(end_unique, words.end());
}
```

- `sort`算法：接受两个迭代器，表示要排序的元素范围。
完成sort之后，words顺序如下：
```Plain Text
fox jumps over quick red red slow the the turtl
```

#### 使用unique
- `unique`算法：将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。
调用 `unique` 后 `vector` 将变为：
![[Pasted image 20230127135712.png]]

`words` 的大小并没有改变，它仍有10个元素。`unique`并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。`unique` 返回的迭代器指向最后一个不重复元素之后的位置。**此位置之后的元素依然存在，但我们不知道它们的值是什么。**

>[!note]
>标准库算法对迭代器而不是容器进行操。因此，算法不能（直接）添加或删除元素。

#### 使用容器操作删除元素
为了删除无用的元素，我们必须使用容器操作。所有最后使用了 `erase` 删除重复的元素。我们删除从`end_unique`开始直至`words`末尾的范围内的所有元素。


## 10.3 定制操作
很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的 `==` 或 `<` 运算符来完成比较。标准库还为这些算法定义了额外的版本，允**许我们提供自定义的操作来代替默认运算符。**
例如，`sort`算法默认使用元素类型的`<`运算符。但可能我们希望的排序顺序与`<`所定
义的顺序不同，或是我们的序列可能保存的是未定义`<`运算符的元素类型（如`sales_data`)在这两种情况下，都需要**重载**`sort`的默认行为。

### 10.3.1 向算法传递函数
对于 `elimDups` ([[#10.2.3 重排容器元素的算法]])还希望单词按其长度排序，大小相同的再按字典序排列。为了实现按长度重排 `vector` ，我们可以使用 `sort` 的第二个版本，它接受第三个参数，此参数是一个 **谓词**。

#### 谓词
- **谓词**：谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。可调用表达式是指以 `express(args)` 这种方式调用，这里的 "可调用的表达式"可以简单的理解为就是函数指针（目前我们只知道函数和函数指针这两种可调用对象，后面章节还会介绍其他可调用对象）。标准库算法的谓词分为两类：
	- **一元谓词**：意味着它们只接受单一参数。
	- **二元谓词**：意味着它们有两个参数
- **接受谓词参数的算法对输入序列中的元素调用谓词。** 因此，元素类型必须能转换为谓词的参数类型。

- 接受一个二元谓词参数的 `sort` 版本用这个谓词来代替 `<` 来比较元素。
```c++
// 比较函数，用来按长度排序单词， 作为一个二元谓词传递给 sort
bool isShorter(const string& s1, const string& s2)
{
	return s1.size() < s2.size();
}

// 按长度有短至长排序 words
sort(words.begin(), words.end(), isShorter);
```

#### 排序算法
在我们将 `words` 按大小重排的同时，还希望具有相同长度的元素按字典序排序。为了保持相同长度的单词按字典序排序，可以使用 `stable_sort` 算法。这种稳定排序算法维持相等的元素原有顺序。
```c++
elimDups(words); // 将words按字典序重排，并消除重复单词

// 按长度重新排序，长度相同的单词维持字典序
stable_sort(words.begin(), words.end(), isShorter);

for (const auto &s : words)
	cout << s << " ";

cout << endl;
```
假定在此调用前`words`是按字典序排列的，则调用之后，`words`会按元素大小排序，而
长度相同的单词会保持字典序。如果我们对原来的`vector`内容运行这段代码，输出为：
```Plain Text
fox red the over slow jumps quick turtle
```


### 10.3.2 lambda表达式
根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。
一个例子，我们修改 [[#10.3.1 向算法传递函数]] 节的程序，求大于等于一个给定长度的单词有多少，并将这些单词打印出来。
```c++
void biggies(vector<string>& words,
vector<string>::size_type sz)
{
	elimDups(words); // 将words按字典序重排，并消除重复单词
	// 按长度重新排序，长度相同的单词维持字典序
	stable_sort(words.begin(), words.end(), isShorter);
	// 1. 获取一个迭代器，指向第一个满足 size() >= sz 的元素
	// 2. 计算满足 size() >= sz 的元素的数目
	// 3. 打印
}
```
- 在步骤1，我们可以使用标准库 `find_if` 算法来查找第一个具有特定大小的元素。- 
	- `find_if` 算法接受一对迭代器，表示一个范围，第三个参数是一个谓词。`find_if` 算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。
编写一个函数，令其接受一个 `string` 和一个长度，并返回一个 `bool` 值表示该 `string` 的长度是否大于给定长度。但是，`find_if` 接受一元谓词，不能传递一个二元谓词，为了解决此问题，需要使用 **`lambda`表达式。**

#### 介绍lambda
我们可以向一个算法传递任何类别的**可调用对象**。
- **可调用对象：** 对于一个对象或一个表达式，如果可以对其使用调用运算符`()` ，则称它为可调用对象。即，如果 `e` 是一个可调用表达式，则我们可以编写代码 `e(args)`，其中 `args` 是一个逗号分隔得一个或多个参数得列表。
- 可调用对象有：
	- 函数  
	- 函数指针  
	- 重载了函数调用运算符的类  
	- **lambda 表达式**。

C++11 一个 `lambda` 表达式表示一个可调用的代码单元。**我们可以将其理解为一个未命名的内联函数。** 与任何函数类似，一个 `lambda` 具有返回类型、参数列表和函数体。但与函数不同，`lambda` 可能定义在函数内部。
>与python中的lambda类似

- `lambda`表达式形式：
 ```c++
 [capture list] (parameter list) -> return type { function body }
 ```
 - `capture list` : 捕获列表是一个 `lambda` 所在函数中定义的局部变量。
 - `return type`、`parameter list` 和 `function body` 与普通函数一样，分别表示**返回类型**、**参数列表**和**函数体**。但是，与普通函数不同，`lambda` 必须[[CPP#使用尾置返回类型|使用尾置返回类型]]。
 - 可以忽略参数列表和返回类型，但**必须永远包含捕获列表和函数体**
```c++
// 可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体
auto f = [] { return 42; }; // 定义一个可调用对象 f,忽略了括号和空参数列表，所以该函数无需参数
cout << f() << endl; // 调用，打印42

```
在 `lambda` 中忽略括号和参数列表等价于指定一个空参数列表。
如果忽略返回类型，`lambda` 根据函数体中的代码推断出返回类型。如果函数体**只是**一个 `return` 语句，则返回类型从返回的表达式的类型推断而来。**否则返回类型为 void**。
>[!note]
>如果`lambda`的函数体**包含任何单一`return`语句之外**的内容，且**未指定返回类型**，则返回`void.`

#### 向lambda传递参数
与普通函数调用类似，调用一个 `lambda` 是给定的实参被用来初始化 `lambda` 的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda不能有[[CPP#默认实参|默认参数]]。因此，一个lambda调用的实参永远与形参数目相等。

一个带参数的lambda的例子：
```c++
[] (const string &a, const string &b)

{ return a.size() < b.size(); }
```
空捕获列表表明此`lambda`不使用它所在函数中的任何局部变量。

#### 使用捕获列表
一个`lambda`通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引`lambda`在其内部包含访问局部变量所需的信息。
示例，`lambda` 捕获 `sz` 并只有单一的 `string` 参数.
```c++
[sz] (const string &a)
{ return a.size() >= sz; }
```
>[!note]
>一个`lambda`只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

#### 调用find_if
使用此 `lambda`，我们就可以查找第一个长度大于等于 sz 的元素：
```c++
// 获取一个迭代器，指向第一个满足 size() >= sz 的元素
auto wc = find_if(words.begin(), words.end(),
[sz] (const string &a)
{ return a.size() >= sz; });
```
这里对`find_if`的调用返回一个迭代器，指向第一个长度不小于给定参数`sz`的元素。如果这样的元素不存在，则返回`words.end()`的一个拷贝。

#### for_each算法
问题的最后一部分是打印 `words` 中长度大于等于 `sz` 的元素。
```c++
// 打印长度大于等于给定值的单词，每个单词后面接一个空格
for_each(wc, words.end(),
[] (const string &s) { cout << s << " ";});
cout << endl;
```
>[!note]
>捕获列表**只用于局部非`static`变量**，`lambda`可以直接使用局部`static`变量和在它所在函数之外声明的名字。比例，上面代码的`lambda`直接使用了`cout`，该函数之外包含了`iostream`头文件，即可使用。

#### 完整的biggies
```c++
void biggies(vector<string> &words,
vector<string>::size_type sz)
{
	elimDups(words); // 将 words按字典序排序，删除重复单词
	// 按长度排序，长度相同的单词维持字典序，第三个参数是lambda表达式
	stable_sort(words.begin(), words.end(),
	[] (const string &a, const string &b)
	{ return a.size() < b.size();} );
	// 获取一个迭代器，指向第一个满足size() >= sz 的元素
	auto wc = find_if(words.begin(), words.end(),
	[sz] (const string &a)
	{ return a.size() >= sz;} );
	// 计算满足 size >= sz 的元素的数目
	auto count = words.end() - wc;
	cout << count << " " << make_plural(count, "words", "s")
	<< " of length " << sz << " or longer" << endl;
	// 打印长度大于等于给定值的单词，每个单词后面接一个空格
	for_each(wc, words.end(),
	[] (const string &s) {cout << s << " ";});
	cout << endl;
	}
```


### 10.3.3 lambda捕获和返回
当定义一个 `lambda`时，编译器生成一个与`lambda`对应的新的（未命名的）类类型。在14.8.1将介绍这种类时如何生成的。目前，可以这样理解。当向一个函数传递一个`lambda`时，同时定义一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。

当使用`auto`定义一个用`lambda`初始化的变量时，定义了一个从生成的类型的对象。
默认情况下，从`lambda`生成的类都包含一个对应该`lambda`所捕获的变量的数据成员。
类似任何普通类的数据成员，`lambda`的数据成员也在`lambda`对象创建时被初始化。

#### 值捕获
`lambda`捕获方式和参数传递类似，可以是值或引用，下表列出了几种不同的捕获列表方式
![[Pasted image 20230127151649.png]]

- 采用**值捕获的前提是变量可以拷贝。** 与传值参数不同的是，被捕获的变量的值是在`lambda`**创建时拷贝**，而不是调用时拷贝：
```c++
void fcn1()
{
	size_t v1 = 42; // 局部变量
	// 将 v1 拷贝到名为f的可调用对象
	auto f = [v1] { return v1; }
	v1 = 0;
	auto j = f(); // j 为42；f将保存了我们创建它时v1的拷贝
}
```
由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对应的值。

#### 引用捕获
我们定义`lambda` 时可以采用**引用方式捕获**变量。
```c++
void fcn2()
{
	size_t v1 = 42;
	auto f2 = [&v1] {return v1;};
	v1 = 0;
	auto j = f2(); // j 为0； f2保存v1的引用，而非拷贝
}
```


