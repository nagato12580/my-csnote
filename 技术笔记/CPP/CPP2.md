# C++标准库：泛型算法

## 10.1 概述
- 大多数算法都**定义在头文件 algorithm** 中。
- 标准库还在**头文件 numeric** 中定义了一组**数值泛型算法**。  
- 一般情况下，这些算法并**不直接操作容器**，而是遍历由两个迭代器指定的一个元素范围来进行操作。
	- `find` 算法示例
```c++
int val = 42; // 我们将查找的值

// 如果在vec 中找到想要的元素，则返回结果指向它，否则返回结果为第二个参数表示搜索失败。
auto result = find(vec.cbegin(), vec.cend(), val);

// 报告结果
cout << "The value " << val<< (result == vec.cend()? " is not present" : " is present") << endl;
```

#### 算法如何工作
以`find`算法为例：
- `find`的工作是在一个未排序的元素序列中查找一个特定的元素。步骤如下：
1. 访问序列中的首元素。  
2. 比较此元素与我们要查找的元素。  
3. 如果此元素与我们要查找的值匹配，`find` 返回标识此元素的值。  
4. 否则，`find` 前进到下一个元素，重复执行步骤 2 和 3。  
5. 如果达到序列尾，`find` 应停止。  
6. 如果 `find` 达到序列末尾，它应该返回一个指出元素未找到的值。此值和步骤 3 返回的值必须具有相容的类型。
这些步骤都**不依赖于容器所保存的元素类型。** 因此，只要有一个**迭代器**可用来访问元素， `find` 就完全不依赖于容器类型。

#### 迭代器令算法不依赖于容器
上述的 `find` 函数的流程中，除了第 2 步外，其他步骤都可以用迭代器操作来实现。

#### 但算法依赖于元素类型的操作
虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个（或多个）元素类型上的操作。
例如，在步骤 2 中，`find` 用元素类型的 `==` 运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持 `<` 运算符。不过，我们将看到，大多数算法提供了一种方法，允许我们使用自定义的操作来替代默认的运算符。

>[!warning]
>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。


## 10.2 初识泛型算法
标准库提供了超过100个算法，这些算法都是有一致的结构，下面以几种具体的算法为例介绍标准库中算法的结构。

### 10.2.1 只读算法
- **只读算法：** 只会读取其输入范围内的元素，而从不改变元素。
>例如，`find`算法，`accumulate`算法，`equal`算法。

#### accumulate算法
- `accumulate`算法：对一个序列进行求和。定义在头文件`numeric`中。接受三个参数：
	- 前两个参数：指出了需要求和的元素的范围
	- 第三个参数：是和的初始值。

```c++
// vec 是一个整数序列
// 对 vec 中的元素求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```
>`accumulate` 的第三个参数的类型决定了函数中使用哪个加法运算符以及返回的类型.

#### 算法和元素类型
`accumulate` 将第三个参数作为求和起点，这蕴含这一个编程假定： 
- 将元素类型加到和的类型上的操作必须可行。 即**序列中的元素的类型必须与第三个参数匹配**，或者**能够转换**为第三个参数的类型，如果类型是自定义类型，那么自定义类型必须定义 `+` 运算符。

```c++
// v 的类型是 vector<string>
string sum = accumulate(v.cbegin(), v.cend(), string("")); // 正确，string可以使用+进行连接

string sum = accumulate(v.cbegin(), v.cend(), ""); // 错误： const char* 上没有定义 + 运算符
```
在第二个求和的调用中，第三个参数是字符串字面值，类型是 `const char*` ，由于 `const char*` 并没有 `+` 运算符，此调用将产生编译错误。

>对于**只读取而不改变元素**的算法，通常最好使用 `cbegin()` 和 `cend()` 。如果需要改变元素则使用 `begin()` 和 `end()`。

#### 操作两个序列的算法
- `equal` 算法：用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。
	- 如果所有对应元素都相等，则返回 `true` ， 否则返回 `false` 。
	- 此算法接受三个迭代器：
		- 前两个参数：表示第一个序列中的元素范围，
		- 第三个参数：表示第二个序列的首元素（指需要比较的元素范围的起始位置）
```c++
// roster2 中的元素数目应该至少与 roster1 一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```
由于 `equal` 利用迭代器完成，因此我们可以调用 `equal` 来**比较两个不同类型的容器中的元素**。而且**元素类型也不必一样**，**只要我们能用 `==` 来比较两个元素类型即可**（即两个类型需要有重载的 `==` 支持它们之间进行比较）。

但是，`equal` 基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。
>[!warning]
>那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。如`equal`等

### 10.2.2 写容器元素的算法
一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意**确保序列原大小至少不小于我们要求算法写入的元素数目**。因为算法不会执行容器操作，它们自身不能改变容器的大小。

- **算法 `fill` ：** 它的接受一对迭代器表示一个范围，还接受一个值作为第三个参数。 `fill` 将给定的这个值赋予输入序列中的每个元素。
```c++
fill(vec.begin(), vec.end(), 0); // 将每个元素重置 0

// 将容器的一个子序列设置为10
fill(vec.begin()， vec.end() + vec.size()/2, 10)
```
由于`fill`向给定输入序列中写入数据，因此，只要我们传递了一个有效的输入序列，写入操作就是安全的。

>[!note]
>一些算法接收两个序列。第二个序列参数传递的方式有两种：
>- 用单一迭代器表示第二个序列：必须保证第二个序列至少比第一个一样长。如果第二个序列是第一个序列的子集，那么将会产生一个严重的错误。算法会试图访问第二个序列末尾之后不存在的元素。
>- 用两个迭代器表示第二个序列。

#### 算法不检查写操作
一些算法接受一个迭代器来指出起始位置，使用一个计数值表示需要写入的个数。
- `fill_n` 函数接受一个单迭代器、一个计数值和一个值，它的功能是从给定迭代器的位置写入 “计数值” 个*数*，*这个数*是由第三个参数给出。
	- 第一个参数：迭代器表示写入目的位置
	- 第二个参数：写入的个数
	- 第三个参数：写入的值
```c++
vector<int> vec; // 空vector

// 使用 vec，赋予它不同的值

fill_n(vec.begin(), vec.size(), 0); // 将所有元素重置为0
```

函数 `fill_n` 假定`dest`指向一个元素，而从`dest`开始的序列至少包含`n`个元素。 `fill_n`假定写入指定元素是安全的，即，如下形式的调用：
```c++
fill_n(dest, n, val)

vector<int> vec; // 空vector
// 灾难：修改 vec 中的10个（不存在）元素
fill_n(vec.begin(), 10, 0);
```

>[!warning]
>- 如果容器不包含写入位置的元素，那么则不能使用该算法。例如，空容器。
>- 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素  
>- 算法并不会检查写入元素的个数，也不会自动改变容器的大小

#### 介绍back_inserter
- **插入迭代器**：是一种向容器添加元素的迭代器。
- 使用**插入迭代器**：保证调用写入算法有足够的空间来容纳输出数据。
- **插入迭代器与普通迭代器比较**：通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个**插入迭代器赋值**时，一个与赋值号右侧值相等的元素被添加到容器。
- 调用`back_inserter` 即可获取到容器的插入迭代器，它定义在头文件iterator中。
	- 接收的参数：一个指向容器的引用。
	- 返回值：一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中。

```c++
vector<int> vec; // 空 vector

// it 的类型为 std::back_insert_iterator<std::vector<int>>
auto it = back_inserter(vec); // 通过它赋值会将元素添加到 vec 中
*it = 42; // 42会添加到vec中
```

在算法中，常常使用`back-inserter`来创建一个迭代器，作为目的位置使用：
```c++
vector<int> vec; // 空 vector

// 正确：back_inserter 创建一个插入迭代器，可用来向vec添加元素
fill_n(back_inserter(vec), 10, 0); // 添加 10 个元素到 vec
```
>在每步迭代中，`fill_n`向给定序列的一个元素赋值。由于我们传递的参数是`back-inserter`返回的迭代器，因此每次赋值都会在`vec`上调用`push_back`.最终，这条`fill_n`调用语句向`vec`的末尾添加了10个元素，每个元素的值都是0

#### 拷贝算法
- **拷贝算法**：拷贝算法(`copy`)是一个向目的位置迭代器指向的输出序列的元素写入数据的算法。此算法接受三个迭代器：
	- 前两个参数：表示一个输入范围。
	- 第三个参数：表示目的序列的起始位置。 目的序列至少要包含与输出序列一样多的元素。

- 使用 `copy` 实现内置数组的拷贝：
```c++
int a1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

int a2[sizeof(a1)/sizeof(*a1)]; // a2和a1大小一样

// ret 指向拷贝到 a2 的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2); // 把 a1 的内容拷贝给 a2
```
>使用[[CPP#sizeof运算符|sizeof]]确保a2与数组a1包含同样多的元素。a1可以理解为指向数组第一个元素的指针，解引用得到第一个的值

`copy` 放回的是其目的位置迭代器（递增后）的值。即，`ret` 指向拷贝到 `a2` 的尾元素之后的位置。

多个算法都提供所谓的“拷贝"版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。
例如，比如 `replace` 和 `replace_copy`  （拷贝版本）
这两个函数都是替换序列中元素的值。`replace` 接受 4 个参数： 前两个是迭代器，表示输出序列，后两个一个是要被替换的值，另一个是替换后的新值。
```c++
// 将ilst 中所有值为 0 的元素改为 42
replace(ils.begin(), ilst.end(), 0, 42);
```
**`replace` 是在原始序列上改动，而 `replace_copy` 是将改动后的序列拷贝一份，原序列保持不变。** 此算法接受额外第三个迭代器参数，指出调整后序列的保存位置。
```c++
// 使用 back_inserter 按需要增长目标序列
replace_copy(ilst.cbegin(), ils.cend(),back_inserter(ivec), 0, 42);
```
此调用，`ilst` 并未改变，`ivec` 包含 `ilst` 的一份拷贝，不过原来 `ilst` 中的值为 0 的元素在 `ivec` 中都变为 42


### 10.2.3 重排容器元素的算法
**排序算法**：这类算法是利用元素类型的 `<` 运算符来实现排序的。  
  
下面以一段文本为例，这段文本保存在 `vector` 中，我们希望简化这个 `vector` ，使得每个单词只出现一次。
```Plain Text
the quick red fox jumps over the slow red turtle
```
去重排序后的 `vector`：
```Plain Text
fox jumps over quick red slow the turtle
```

#### 消除重复单词
为了消除重复单词，首先将`vector`排序，使得重复的单词都相邻出现。一旦`vector`排序完毕，我们就可以使用另一个称为`unique`的标准库算法来重排`vector`，使得不重复的元素出现在`vector`的开始部分。
>由于算法不能执行容器的操作，我们将使用`vector`的`erase`成员来完成真正的删除操作：
```c++
void eliDups(vector<string> &words)
{
	// 按字典排序 words ，以便查找重复单词
	sort(words.begin(), words.end());
	// unique 重排输入范围，使得每个单词只出现一次
	// 排序在范围的前部，返回指向不重复区域之后一个位置的迭代器
	auto end_unique = unique(words.begin(), words.end());
	// 使用容器操作 erase 删除重复元素
	words.erase(end_unique, words.end());
}
```

- `sort`算法：接受两个迭代器，表示要排序的元素范围。
完成sort之后，words顺序如下：
```Plain Text
fox jumps over quick red red slow the the turtl
```

#### 使用unique
- `unique`算法：将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。
调用 `unique` 后 `vector` 将变为：
![[Pasted image 20230127135712.png]]

`words` 的大小并没有改变，它仍有10个元素。`unique`并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。`unique` 返回的迭代器指向最后一个不重复元素之后的位置。**此位置之后的元素依然存在，但我们不知道它们的值是什么。**

>[!note]
>标准库算法对迭代器而不是容器进行操。因此，算法不能（直接）添加或删除元素。

#### 使用容器操作删除元素
为了删除无用的元素，我们必须使用容器操作。所有最后使用了 `erase` 删除重复的元素。我们删除从`end_unique`开始直至`words`末尾的范围内的所有元素。


## 10.3 定制操作
很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的 `==` 或 `<` 运算符来完成比较。标准库还为这些算法定义了额外的版本，允**许我们提供自定义的操作来代替默认运算符。**
例如，`sort`算法默认使用元素类型的`<`运算符。但可能我们希望的排序顺序与`<`所定
义的顺序不同，或是我们的序列可能保存的是未定义`<`运算符的元素类型（如`sales_data`)在这两种情况下，都需要**重载**`sort`的默认行为。

### 10.3.1 向算法传递函数
对于 `elimDups` ([[#10.2.3 重排容器元素的算法]])还希望单词按其长度排序，大小相同的再按字典序排列。为了实现按长度重排 `vector` ，我们可以使用 `sort` 的第二个版本，它接受第三个参数，此参数是一个 **谓词**。

#### 谓词
- **谓词**：谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。可调用表达式是指以 `express(args)` 这种方式调用，这里的 "可调用的表达式"可以简单的理解为就是函数指针（目前我们只知道函数和函数指针这两种可调用对象，后面章节还会介绍其他可调用对象）。标准库算法的谓词分为两类：
	- **一元谓词**：意味着它们只接受单一参数。 ^46f254
	- **二元谓词**：意味着它们有两个参数
- **接受谓词参数的算法对输入序列中的元素调用谓词。** 因此，元素类型必须能转换为谓词的参数类型。

- 接受一个二元谓词参数的 `sort` 版本用这个谓词来代替 `<` 来比较元素。
```c++
// 比较函数，用来按长度排序单词， 作为一个二元谓词传递给 sort
bool isShorter(const string& s1, const string& s2)
{
	return s1.size() < s2.size();
}

// 按长度有短至长排序 words
sort(words.begin(), words.end(), isShorter);
```

#### 排序算法
在我们将 `words` 按大小重排的同时，还希望具有相同长度的元素按字典序排序。为了保持相同长度的单词按字典序排序，可以使用 `stable_sort` 算法。这种稳定排序算法维持相等的元素原有顺序。
```c++
elimDups(words); // 将words按字典序重排，并消除重复单词

// 按长度重新排序，长度相同的单词维持字典序
stable_sort(words.begin(), words.end(), isShorter);

for (const auto &s : words)
	cout << s << " ";

cout << endl;
```
假定在此调用前`words`是按字典序排列的，则调用之后，`words`会按元素大小排序，而
长度相同的单词会保持字典序。如果我们对原来的`vector`内容运行这段代码，输出为：
```Plain Text
fox red the over slow jumps quick turtle
```


### 10.3.2 lambda表达式
根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。
一个例子，我们修改 [[#10.3.1 向算法传递函数]] 节的程序，求大于等于一个给定长度的单词有多少，并将这些单词打印出来。
```c++
void biggies(vector<string>& words,
vector<string>::size_type sz)
{
	elimDups(words); // 将words按字典序重排，并消除重复单词
	// 按长度重新排序，长度相同的单词维持字典序
	stable_sort(words.begin(), words.end(), isShorter);
	// 1. 获取一个迭代器，指向第一个满足 size() >= sz 的元素
	// 2. 计算满足 size() >= sz 的元素的数目
	// 3. 打印
}
```
- 在步骤1，我们可以使用标准库 `find_if` 算法来查找第一个具有特定大小的元素。- 
	- `find_if` 算法接受一对迭代器，表示一个范围，第三个参数是一个谓词。`find_if` 算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。
编写一个函数，令其接受一个 `string` 和一个长度，并返回一个 `bool` 值表示该 `string` 的长度是否大于给定长度。但是，`find_if` 接受一元谓词，不能传递一个二元谓词，为了解决此问题，需要使用 **`lambda`表达式。**

#### 介绍lambda
我们可以向一个算法传递任何类别的**可调用对象**。
- **可调用对象：** 对于一个对象或一个表达式，如果可以对其使用调用运算符`()` ，则称它为可调用对象。即，如果 `e` 是一个可调用表达式，则我们可以编写代码 `e(args)`，其中 `args` 是一个逗号分隔得一个或多个参数得列表。
- 可调用对象有：
	- 函数  
	- 函数指针  
	- 重载了函数调用运算符的类  
	- **lambda 表达式**。

C++11 一个 `lambda` 表达式表示一个可调用的代码单元。**我们可以将其理解为一个未命名的内联函数。** 与任何函数类似，一个 `lambda` 具有返回类型、参数列表和函数体。但与函数不同，`lambda` 可能定义在函数内部。
>与python中的lambda类似

- `lambda`表达式形式：
 ```c++
 [capture list] (parameter list) -> return type { function body }
 ```
 - `capture list` : 捕获列表是一个 `lambda` 所在函数中定义的局部变量。
 - `return type`、`parameter list` 和 `function body` 与普通函数一样，分别表示**返回类型**、**参数列表**和**函数体**。但是，与普通函数不同，`lambda` 必须[[CPP#使用尾置返回类型|使用尾置返回类型]]。
 - 可以忽略参数列表和返回类型，但**必须永远包含捕获列表和函数体**
```c++
// 可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体
auto f = [] { return 42; }; // 定义一个可调用对象 f,忽略了括号和空参数列表，所以该函数无需参数
cout << f() << endl; // 调用，打印42

```
在 `lambda` 中忽略括号和参数列表等价于指定一个空参数列表。
如果忽略返回类型，`lambda` 根据函数体中的代码推断出返回类型。如果函数体**只是**一个 `return` 语句，则返回类型从返回的表达式的类型推断而来。**否则返回类型为 void**。
>[!note]
>如果`lambda`的函数体**包含任何单一`return`语句之外**的内容，且**未指定返回类型**，则返回`void.`

#### 向lambda传递参数
与普通函数调用类似，调用一个 `lambda` 是给定的实参被用来初始化 `lambda` 的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda不能有[[CPP#默认实参|默认参数]]。因此，一个lambda调用的实参永远与形参数目相等。

一个带参数的lambda的例子：
```c++
[] (const string &a, const string &b)

{ return a.size() < b.size(); }
```
空捕获列表表明此`lambda`不使用它所在函数中的任何局部变量。

#### 使用捕获列表
一个`lambda`通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引`lambda`在其内部包含访问局部变量所需的信息。
示例，`lambda` 捕获 `sz` 并只有单一的 `string` 参数.
```c++
[sz] (const string &a)
{ return a.size() >= sz; }
```
>[!note]
>一个`lambda`只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

#### 调用find_if
使用此 `lambda`，我们就可以查找第一个长度大于等于 sz 的元素：
```c++
// 获取一个迭代器，指向第一个满足 size() >= sz 的元素
auto wc = find_if(words.begin(), words.end(),
[sz] (const string &a)
{ return a.size() >= sz; });
```
这里对`find_if`的调用返回一个迭代器，指向第一个长度不小于给定参数`sz`的元素。如果这样的元素不存在，则返回`words.end()`的一个拷贝。

#### for_each算法
问题的最后一部分是打印 `words` 中长度大于等于 `sz` 的元素。
```c++
// 打印长度大于等于给定值的单词，每个单词后面接一个空格
for_each(wc, words.end(),
[] (const string &s) { cout << s << " ";});
cout << endl;
```
>[!note]
>捕获列表**只用于局部非`static`变量**，`lambda`可以直接使用局部`static`变量和在它所在函数之外声明的名字。比例，上面代码的`lambda`直接使用了`cout`，该函数之外包含了`iostream`头文件，即可使用。

#### 完整的biggies
```c++
void biggies(vector<string> &words,
vector<string>::size_type sz)
{
	elimDups(words); // 将 words按字典序排序，删除重复单词
	// 按长度排序，长度相同的单词维持字典序，第三个参数是lambda表达式
	stable_sort(words.begin(), words.end(),
	[] (const string &a, const string &b)
	{ return a.size() < b.size();} );
	// 获取一个迭代器，指向第一个满足size() >= sz 的元素
	auto wc = find_if(words.begin(), words.end(),
	[sz] (const string &a)
	{ return a.size() >= sz;} );
	// 计算满足 size >= sz 的元素的数目
	auto count = words.end() - wc;
	cout << count << " " << make_plural(count, "words", "s")
	<< " of length " << sz << " or longer" << endl;
	// 打印长度大于等于给定值的单词，每个单词后面接一个空格
	for_each(wc, words.end(),
	[] (const string &s) {cout << s << " ";});
	cout << endl;
	}
```


### 10.3.3 lambda捕获和返回
当定义一个 `lambda`时，编译器生成一个与`lambda`对应的新的（未命名的）类类型。在14.8.1将介绍这种类时如何生成的。目前，可以这样理解。当向一个函数传递一个`lambda`时，同时定义一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。

当使用`auto`定义一个用`lambda`初始化的变量时，定义了一个从生成的类型的对象。
默认情况下，从`lambda`生成的类都包含一个对应该`lambda`所捕获的变量的数据成员。
类似任何普通类的数据成员，`lambda`的数据成员也在`lambda`对象创建时被初始化。

#### 值捕获
`lambda`捕获方式和参数传递类似，可以是值或引用，下表列出了几种不同的捕获列表方式
![[Pasted image 20230127151649.png]]

- 采用**值捕获的前提是变量可以拷贝。** 与传值参数不同的是，被捕获的变量的值是在`lambda`**创建时拷贝**，而不是调用时拷贝：
```c++
void fcn1()
{
	size_t v1 = 42; // 局部变量
	// 将 v1 拷贝到名为f的可调用对象
	auto f = [v1] { return v1; }
	v1 = 0;
	auto j = f(); // j 为42；f将保存了我们创建它时v1的拷贝
}
```
由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对应的值。

#### 引用捕获
我们定义`lambda` 时可以采用**引用方式捕获**变量。
```c++
void fcn2()
{
	size_t v1 = 42;
	auto f2 = [&v1] {return v1;};
	v1 = 0;
	auto j = f2(); // j 为0； f2保存v1的引用，而非拷贝
}
```
当我们在`lambda`函数体内使用此变量时，实际上使用的是引用所绑定的对象。
>引用捕获和返回引用有着相同的问题和限制。在调用`lambda`表达式和返回引用的时候，我们要保证捕获的引用变量是存在的，我没有被销毁。

引用捕获有时是必要的，有些对象是不允许拷贝的，比如输入和输出流.
```c++
void biggies(vector<string> &words,
vector<string>::size_type sz,
ostream &os = cout , char c = ' ')
{
	// 与之前例子一样的重排words的代码
	// 打印 count 的语句改为打印到 os
	for_each(words.begin(), words.end(),
	[&os, c] (const string &s) {os << s << c;});
}
```

>[!warning]
>当以引用方式捕获一个变量时，必须保证在`lambda`执行时是存在的。

#### 隐式捕获
除了显式的列出我们希望使用来自所在函数的变量之外，还可以让编译器根据 `lambda` 体中的代码来推断我们要使用哪些变量。
为了指示编译器推断捕获列表，应在捕获列表中写一个 `&` 或 `=` 。
- `&` 告诉编译器采用捕获引用方式，
- `=` 则表示采用值捕获方式。
```c++
// sz 为隐式捕获，值捕获方式
wc = find_if(words.begin(), words.end(),
[=] (const string &s)
{ return s.size() >= sz; });
```

如果我们希望对**一部分变量采用值捕获**，对**其他变量采用引用捕获**，可以混合使用隐
式捕获和显式捕获：
```c++
void biggies(vector<string> &words,
vector<string>::size_type sz,
ostream &os = cout, char c = ' ')
{
	// 其他处理与前例一样
	// os 隐式捕获，引用捕获方式； c显式捕获，值捕获方式
	for_each(words.begin(), words.end(),
	[&, c](const string &s) { os << s << c; });
	// os 显式捕获，引用捕获方式； c 隐式捕获，值捕获方式
	for_each(words.begin(), words.end(),
	[=, &os](const string &s) {os << s << c;});
}
```
**当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个`&`或`=`。** 此符号指定了默认捕获方式为引用或值。

当混合使用隐式捕获和显式捕获时，**显式捕获的变量必须使用与隐式捕获不同的方式**。即，
- 如果隐式捕获是引用方式（使用了`&`），则显式捕获命名变量必须采用值方式，此不能在其名字前使用`&`
- 如果隐式捕获采用的是值方式（使用了`=`），则显式获命名变量必须采用引用方式，即，在名字前使用`&`。

#### 可变lambda
默认情况下，值拷贝的变量，`lambda`不会改变其值，如果需要改变一个被捕获变量的值，就必须在参数列表首加上关键字 `mutable`。[[CPP#^2fec59|mutable在类内的应用]]
```c++
void fcn3()
{
	size_t v1 = 42; // 局部变量
	// f 可以改变它所捕获的变量的值
	auto f = [v1] ()mutable {return ++v1;};
	v1 = 0;
	auto j = f(); // j 为 43
}
```

对于引用方式捕获的变量，是否可修改依赖于引用是否为 `const`
```c++
void fcn4()
{
	size_t v1 = 42; // 局部变量
	// v1 是一个非 const 变量的引用
	// 可以通过f2中的引用来改变它
	auto f2 = [&v1] {return ++v1;};
	v1 = 0;
	auto j = f2(); // j 为1
}
```

#### 指定lambda返回类型
到目前为止，我们所编写的`lambda`都只包含单一的 `return` 语句，这种形式的 `lambda`表达式无须指定返回类型，编译器会自动推断返回类型。
如果一个`lambda`表达式包含 `return` 之外的任何语句，则编译器假定此 `lambda` 表达式返回 `void` .
```c++
//将一个序列中的每个负数替换为其绝对值：
transform(vi.begin(), vi.end(), vi.begin(),
[](int i) { return i < 0 ? -i : i; });
```

如果就上面改成 `if` 语句，就会产生编译错误
```c++
transform(vi.begin(), vi.end(), vi.begin(),
		  [](int i) {if (i < 0) return -1; else return i; });
```
编译器推断的返回类型是 `void` , 但它返回了一个 `int` 值，正确的做法是指定返回类型，而且必须使用**尾置返回类型**。
```c++
transform(vi.begin(), vi.end(), vi.begin(),
[](int i) -> int
{if (i < 0) return -1; else return i; });
```


## 10.3.4 参数绑定
在使用一个接受一元谓词的算法 `find_if` , 我们通过给算法传递`lambda`表达式实现调用外部的变量，除了`lambda`表达式的方法，还可以使用**参数绑定**。

#### 标准库bind函数
```c++
bool check_size(const string &s, string::size_type sz)
{
	return s.size() >= sz;
}
```
该函数不能作为`find_if`的一个参数，因为`find_if`只接受一个[[#^46f254|一元谓词]]
使用`bind`函数可以解决该问题。

`bind`函数：它定义在头文件functional中。可以将`bind`函数看作一个通用的[[CPP#容器适配器|函数适配器]]，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。

调用 `bind` 的一般形式为：
```c++
 auto newCallable = bind(callable, arg_list);
```
- `newCallable` 本身是一个可调用对象，
- `arg_list` 是一个逗号分隔的参数列表，对应给定的`callable` 的参数。  
- **当我们调用`newCallable`时，`newCallable`会调用`callable`，并传递给它 `arg_list` 中的参数。**
- `arg_list` 中的参数可能包含形如 `_n` 的名字， 其中 `n` 是一个整数。这些参数是 “占位符”，表示 `newCallable` 的参数，它们占据了传递给`newCallable`的参数的“位置”。数值 `n` 表示生成的可调用对象中参数的位置：`_1` 为 `newCallable` 的第一个参数，`_2`为第二个参数，依此类推。

#### 绑定check_size的sz参数
作为一个简单的例子，我们将使用`bind`生成一个调用`check_size`的对象，如下所示，它用一个定值作为其大小参数来调用`check_size`：
```c++
auto check6 = bind(check_size, _1, 6);
//调用
string s = "hello";
bool b1 = check6(s); // check6(s) 会调用check_size(s,6)
// 使用bind,我们可以将原来基于 lambda 的 find_if 调用：
auto wc = find_if(words.begin(), words.end(),
[=] (const string &s) { return s.size() >= sw; });
//替换为：
auto wc = find_if(words.begin(), words.end(),
bind(check_size, _1, sz)));
```
- 此`bind`调用**只有一个占位符**，**表示`check6`只接受单一参数**。
- 占位符出现在的`arg_list`的第一个位置，表示`check6`的此参数对应`check_size`的第一个参数。此参数是一个`const string&`。因此，调用`check6`必须传递给它一个`string`类型的参数，`check6`会将此参数传递给`check_size`。
![[Pasted image 20230127163227.png]]

#### 使用placeholders名字
名字 `_1` 都定义在一个名为 `placeholders` 的命名空间中，而这个命名空间本身定义在 `std` 命名空间中。为了使用这些名字，我们可以使用以下声明：
```c++
using std::placeholders::_1; // 只使用 _1
// 或者
using namespace std::placeholders; //使用全部的参数
```

这种形式说明希望所有来自`namespace_name`的名字都可以在我们的程序中直接使用。
```c++
using namespace namespace_name;
```

placeholders命名空间也定义在functional头文件中。

#### bind的参数
如前文所述，我们可以用`bind`修正参数的值。更一般的，可以用`bind`绑定给定可调用对象中的参数或重新安排其顺序。
例如，假定`f`是一个可调用对象，它有5个参数:
```c++
// g 是一个有两个参数的可调用对象
auto g = bind(f, a, b, _2, c, _1);
```
生成一个新的可调用对象，它有两个参数，分别用占位符`_2`和`_1`表示。这个新的可调用
对象将它自己的参数作为第三个和第五个参数传递给`f`。`f`的第一个、第二个和第四个参
数分别被绑定到给定的值`a`、`b`和`c`上。
```c++
g(e,f);
// 实际调用：
f(a, b, f, c, e);
```

#### 用bind重排参数顺序
下面是用 `bind` 重排参数顺序的一个具体例子，我们可以用`bind`颠倒 `isShroter` 的含义。
```c++
// 按单词长度有短至长排序
sort(words.begin(), words.end(), isShorter);

// 按单词长度有长至短排序
sort(words.begin(), words.end(), bind(isShorter, _2, _1));
```
第一个调用中`isShorter(A,B)`，调用传递给`isShorter`的参数被交换过来了。因此，当`sort`比较两个元素时，就好像调用`isShorter(B,A)`—样。

#### 绑定引用参数
默认情况下，`bind`的那些不是占位符的参数(例如[[#bind的参数]]中的a、b、c)被拷贝到`bind`返回的可调用对象中。
但是，与`lambda`类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参
数的类型无法拷贝。
例如，为了替换一个引用方式捕获`ostream`的`lambda`：
```c++
// os 是一个局部变量，引用一个输出流
// c 是一个局部变量，类型为char
for_each(words.begin(), words.begin(),
[&os, c](const string &s){os << s << c;});
//
ostream &print(ostream &os, const string &s, char c)
{
	return os << s << c;
}

// 错误：不能拷贝 os
for_each(words.begin(), words.begin(),
bind(print, os, _1, ' '));

// 使用标准库ref函数，传递引用
for_each(words.begin(), words.begin(),
bind(print, ref(os), _1, ' '));
```
`bind`拷贝其参数，而我们不能拷贝一个`ostream`。如果我们希望传递给`bind`一个对象而又不拷贝它，就必须使用标准库 **`ref`函数**：
函数 `ref` 返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个 `cref` 函数，生成一个保存 `const` 引用的类。它们都定义在头文件 functional 中。


## 10.4 再探迭代器
除了为每个容器定义的迭代器之外，标准库在头文件`iterato`r中还定义了额外几中迭代器：
- **插入迭代器**：这些迭代器被绑定到一个容器上，可用来向容器插入元素。
- **反向迭代器**：这些迭代器向后而不是向前移动。除了`forward_list`之外的标准库容器都有反向迭代器。
- **移动迭代器**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。

### 10.4.1 插入迭代器
**插入迭代器**是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。
![[Pasted image 20230127165405.png]]

- [[#介绍back_inserter||back_insert]]：创建一个使用`push_back`的迭代器。
- `front_insert`：创建一个使用`push_front`的迭代器。
- `inserter`：创建一个使用`insert`的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素**之前**。
>[!note]
>- 只有在容器支持`push_front`的情况下，我们才可以使用`front_inserter`
>- 只有在容器支持`push_back`的情况下，我们才能使用`back_inserter`

以`inserter`为例，
当调用`inserter(c,iter)`时，我们得到一个迭代器，接下来使用它时，会将元素**插入到iter原来所指向的元素之前的位置**。即如果it是由inserter生成的迭代器，则：
```c++
*it = val;

//等价于
it = c.insert(it,val);//it指向新加入的元素
++it;//递增it使它指向原来的元素
```

以`front_inserter`为例，
使用`front_inserter`时，元素总是插入到容器**第一个元素之前**。只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：
```c++
list<int> lst = {1,2,3,4};
list<int> lst2,lst3;//空list

//拷贝完成之后，lst2包含4，3，2，1
copy(lst.cbegin(),lst.cend(),front_inserter(lst2));
//拷贝完成后，lst3包含1，2，3，4
copy(lst.cbegin(),lst.cend(),inserter(lst3,lst3.begin))
```
- 使用`front_inserter`：每次插入都是在第一个元素之前，每次调用之后首元素都会改变，返回的是指向首元素的迭代器。
- 使用`inserter`：每次插入都是在指定位置之前，返回的是插入之后返回迭代器指向原来的值。

### 10.4.2 iostream迭代器
虽然`iostream`类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。
- `istream_iterator`：读取输入流。
- `ostream_iterator`：向一个输出流写数据。
这些迭代器将它们对应的**流当作一个特定类型的元素序列**来处理。

#### istream_iterator操作
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。
由于`istream_iterator`使`>>`来读取流，因此`istream_iterator`尧都区的类型必须定义例如输入运算符。
```c++
istream_iterator<int> int_it(cin)//从cin读取int
istream_iterator<int> int_eof;//默认初始化迭代器，为空，可以看成创建了一个尾后迭代器。
ifstream in("afile");
istream_iterator<string> strt(in)；//从"afile"读取字符串
```

下面是一个用`istream_iterator`从标准输入读取数据，存入一个`vector`的例子：
```c++
istream_iterator<int> in_iter(cin);//从cin读取int
istream_iterator<int> eof;//istream尾后迭代器
while(in_iter!=eof)//当有数据可供读取时
	//后置递增运算读取流，返回迭代器的旧值
	//解引用迭代器，获得从流读取的前一个值
	vec.push_back(*in_iter++);
```
后置递增运算会从流中读取下一个值，向前推进，但返回的是迭代器的旧值。迭代器的旧值包含了从流中读取的前一个值，对迭代器进行解引用就能获得此值。
```c++
//等价于
istream_iterator<int>initer(cin),eof;//从cin读取int
//从迭代器范围构造vec
vector<int> vec()niter'eof)；
```
![[Pasted image 20230127173500.png]]

#### 使用算法操作流迭代器
由于**泛型算法使用迭代器操作来处理数据**，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。
使用一对`istream_iterator`来调用[[#accumulate算法]]
```c++
istream_iterator<int> in(cin),eof;
cout<<accumulate(in,eof,0）<<endl;
```
![[Pasted image 20230127173749.png]]

#### istream_iterator允许使用懒惰求值
- `istream_iterator`的惰性求值：当我们将一个`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，**直到我们使用迭代器时才真正读取**。

- 用途：
	- 创建了一个istream_iterator，没有使用就销毁
	- 从两个不同的对象同步读取同一个流


#### ostream_iterator操作
我们可以对任何具有输出运算符（`<<`运算符）的类型定义`ostream_iterator`。
创建一个`ostream_iterator`时，我们可以提供 **（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。** 此字符串必须是一个[[CPP#C风格字符串]]（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。

与`istream_iterator`不同的是在创建时必须绑定一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`
![[Pasted image 20230127174315.png]]

使用ostream_iterator输出值的序列：
```c++
ostrea_miterator<int> out_iter(cout,"");
for(auto:evec)
	*out_iter++=e；//赋值语句实际上将元素写到cout
cout<<endl;
```
每次向out_iter赋值时，写操作就会被提交。当我们向`out_iter`赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：
```c++
for(auto:evec)
	out_iter=e，//赋值语句将元素写到cout
cout<<endl;
```
运算符`*`和`++`实际上对`ostream_iterator`对象不做任何事情，因此忽略它们对我们的
程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。

使用copy打印vec中的元素：
```c++
copy(vec.begin(),vec.end(),out_iter)
cout<<endl;
//out_iter是ostream_iterator绑定了cout。
```

#### 使用流迭代器处理类类型
- 可以为任何定义了输入运算符（`>>`）的类型创建`istream_iterator`对象。
- 可以为任何定义了输入运算符（`<<`）的类型创建`ostream_iterator`对象。
![[Pasted image 20230128133253.png]]

### 反向迭代器
**反向迭代器**：反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。
对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（`++it`）会移动到前一个。

**除了`forward_list`之外，其他容器都支持反向迭代器。**

- 调用反向迭代器：`rbegin`、`rend`、`crbegin`、`crend`
![[Pasted image 20230128133729.png]]
```c++
vector<int> vec = {0,1,2,3};
for(auto riter = vec.crbegin();riter!=vec.crend();++iter){
	cout<<*riter<<endl;//打印3，2，1，0
	}

//利用sort排序为递减序列
sort(vec.begin(),vec.end());
sort(vec.rbegin(),vec.rend());//逆序：从大到小
```

#### 不适用反向迭代器的情况
除了`forward_list`之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。
但是，**流迭代器不支持递减运算**，因为不可能在一个流中反向移动。
因此，**不可能**从一个`forward_list`或一个**流迭代器**创建反向迭代器。

#### 反向迭代器和其他迭代器间的关系
**反向迭代器可以转化为普通迭代器**，使用调用`reverse_iterator`的`base`成员进行转换。
![[Pasted image 20230128135745.png]]
- **反向迭代器`rcomma`** 通过调用`base()`方法之后转变为普通迭代器，其递增递减的方向发生改变，与普通迭代器一致。
- `rcomma`和`rcomma.base()`指向不同元素，`line.crbegin`和`line.cend`也是如此。这些不同保证了元素范围无论是正向处理还是方向处理都是相同的。
- 从技术上讲，普通迭代器与反向迭代器的关系反映了**左闭合区间**的特性。键点在于$[line.crbegin(),rcomma)$和$[rcomma.base(),line.cend())$指向`line`中相同元素范围。都是单词`LAST`。
>[!note]
>反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要的结果：
>当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。


## 10.5 泛型算法结构
C++ STL 提供的泛型算法不是直接操作容器的，而是通过迭代器操作数据的，这些算法所需要的迭代器操作可以分为5个迭代器类别：
![[Pasted image 20230128140453.png]]
>每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。

### 10.5.1 5类迭代器
- 类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。
- 迭代器是按他们所提供的操作来分类的，而这种分类形成了一种层次。**除了输出迭代器之外，一个高层次类别的迭代器支持低层类别迭代器的所有操作(向下兼容)**。
- C++ 标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如， find 算法在一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。
>对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。

#### 迭代器类别
- **输入迭代器**：可以读取序列中的元素。**只用于顺序访问**。一个输入迭代器必须支持
	- 用于比较两个迭代器的相等和不相等运算符 (`==、!=`)  
	- 用于推进迭代器的前置和后置递增运算 (`++`)  
	- 用于读取元素的解引用运算符（`*`）；解引用只会出现在赋值运算符的右侧  
	- 箭头运算符（`->`），等价于 `(*it).member`，即，解引用迭代器，并提取对象的成员。
>算法`find`和`accumulate`要求输入迭代器：而`istream_iterator`是一种输入迭代器。

- **输出迭代器**：可以看作输入迭代器功能上的补集——**只写而不读元素**。输入迭代器必须支持
	- 用于推进迭代器的前置和后置递增运算 （`++`）  
	- 解引用运算符（`*`），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代出赋值，就是将值写入它所指向的元素）
>只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。`copy`函数的第三个参数就是输出迭代器，`ostream_iterator`类型也是输出迭代器。

- **前向迭代器**：可以读写元素。这类迭代器只能在序列中沿一个方向移动。
>支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。算法`replace`要求前向迭代器，`forward_list`上的迭代器是前向迭代器。

- **双向迭代器**：可以正向/反向读写序列中的元素。
>支持所有前向迭代器的操作，还支持前置和后置递减运算符（`--`）。reverse要求双向迭代器，除`forward_list`之外，其他标准库都提供符合双向迭代器要求的迭代器。

- **随机访问迭代器**：提供在常量时间内访问序列中任意元素的能力。此外还支持以下操作：
	- 用于比较两个迭代器相对位置的关系运算符 （`<`、`<=`、`>` 和 `>=` ）  
	- 迭代器和一个整数值的加减运算（ `+` 、`+=` 、`-` 和 `-=`），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置  
	- 用于两个迭代器上的减法运算符（`-`），得到两个迭代器的距离  
	- 下标运算符（`iter[n]`）于 `*(iter[n])` 等价。
![[Pasted image 20230128141933.png]]
>随机访问迭代器支持上表所有操作。算法`sort`要求随机访问迭代器。`array`、`deque`、`string`和`vector`的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。


### 10.5.2 算法形参模式
大多数算法具有如下4中形式之一：
- `alg(beg, end, other args);`  
- `alg(beg, end, dest, other args);`  
- `alg(beg, end, beg2, other args);`  
- `alg(beg, end, beg2, end2, other args);`
>`alg`是算法的名字，`beg` 和 `end` 表示算法所操作的**输入范围**。几乎所有算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种——`dest` 、`beg2` 和 `end2`，都是迭代器参数，分别指定目的位置和第二个范围。

#### 接受单个目标迭代器的算法
`dest` 参数是一个表示算法可以写入的目的位置迭代器。
**算法假定**：按其需要写入数据，不管写入多少个元素都是安全的。  
>**向输入迭代器写入数据的算法都假定目标空间足够容纳写入的数据**

#### 接受第二个输入序列的算法
接受单独的 `beg2` 或者接受`beg2` 和 `end2` 的算法用这些迭代器表示第二个输入范围。
- 如果一个算法接受`beg2`和`end2`，这两个迭代器表示第二个范围。
- 只接受单独的`beg2`（不接受`end2`）的算法将`beg2`作为第二个输入范围中的元素。此范围的结束位置未指定，这些算法假定从`beg2`开始的范围与`beg`和`end`所表示的范围**至少一样大。**

### 10.5.3 算法命名规范
除了参数规范，算法还遵循一套命名和重载规范。

#### 一些算法使用重载形式传递一个谓词
**接受谓词参数来代替 `<=` 或 `==` 运算符**的算法，以及那些不接受额外参数的算法，通常都是重载的函数。  
例如:
```c++
unique(beg, end); // 使用 == 运算符比较元素
unique(beg, end, comp); // 使用 comp 比较元素
```
两个调用都重新整理给定序列，将相邻的重复元素删除。

#### _ if 版本的算法
接受一个元素值的算法通常有另一个不同名的（**不是重载**的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的 `_if` 前缀：
```c++
find(beg, end, val); // 查找输入范围中 val第一次出现的位置
find_if(beg, end, pred); // 查找第一个令 pred 为真的元素
```
这两个算法提供了命名上差异的版本，而非[[CPP#函数重载|重载]]，因为两个版本的算法都**接受相同数目的参数。**

#### 区分拷贝元素的版本和不拷贝的版本
默认情况下，重排元素的算法将重排后的元素写入给定的输入序列中。这些算法还提供另一个版本，将**元素写到一个指定的输出目的位置**。写到额外目的空间的算法都在名字后面附加一个 `_copy`
```c++
reverse(beg, end); // 将反转输入范围中元素的顺序
reverse_copy(beg, end, dest); // 将元素按逆序拷贝到 dest
```
一些算法同时提供 `_copy` 和 `_if` 版本。这些版本接受一个目的位置迭代器和一个谓词：
```c++
// 从 v1 中删除奇数元素
remove_if(v1.begin(), v1.end(),
[](int i){return i%2; });

// 将偶数元素从v1拷贝到v2; v1 不变
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),
[](int i) { return i % 2; });
```
>[[#介绍back_inserter]]


## 10.6 特定容器算法
链表类型 `list` 和 `forward_list` 定义了几个成员函数形式的算法，如下表
![[Pasted image 20230128144309.png]]
![[Pasted image 20230128144316.png]]
特别是，它们定义了独有的`sort`、`merge`、`remove`、`reverse`和`unique`。
>通用版本的`sort`要求随机访问迭代器，因此不能用于`list`和`forward_list`，因为这两个类型分别提供双向迭代器和前向迭代器。并且随机访问链表开销较大。

>[!note]
>对于`list`和`forward_list`，应该优先使用成员函数版本的算法而不是通用算法

#### splice成员
**链表类型**还定义了 `splice` 算法，此算法是链表数据结构所特有的，因此不需要通用版本
![[Pasted image 20230128144533.png]]
>可能用于链表中移动多个元素？

#### 链表特有的操作会改变容器
- 多数链表特有的算法都与其通用版本很相似，但不完全相同。
- 链表特有版本与通用版本间的一个至关重要的区别是**链表版本会改变底层容器。** 例如， `remove` 的链表版本会删除元素。`unique`的链表版本会删除第二个和后继重复元素，`merge`和`splice`会销毁参数。
>例如，通用版本的`merge`将合并的序列
写到一个给定的目的迭代器：两个输入序列是不变的。而链表版本的`merge`函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用`merge`的链表对象中。在之后，来自两个链表中的元素仍然存在，但它们都己在同一个链表中。




# C++标准库：关联容器
关联容器和顺序容器有着根本的不同：关联容器中的元素是**按关键字来保存和访问
的。** 与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。

关联容器**支持高效**的关键字**查找和访问**。两个主要的关联容器：
- `map`：`map`中的元素是一些关键字一值对：
	- 关键字：起索引的作用
	- 值：与索引相关联的数据
- `set`：每个元素只包含一个关键字。支持搞笑的关键字查询操作——检查某关键字是否在`set`中

#### 标准库提供的关联容器
标准库提供8个关联容器：
![[Pasted image 20230128150430.png]]

这8个容器间的**不同**体现在三个维度上：
1. 或者是一个`set`，或者是一个`map`;
2. 或者要求不重复的关键字，或者允许重复关键字：
3. 按顺序保存元素，或无序保存。
	- 允许重复关键字的容器的名字中都包含单词`multi`；
	- 不保持关键字按顺序存储的容器的名字都以单词`unordered`开头。

定义位置：
- 类型`map`和`multimap`定义在头文件`map`中；
- `set`和`multiset`定义在头文件`set`中
- 无序容器则定义在头文件`unordered_map`和`unordered_set`中。

## 11. 1 使用关联容器
- `map`和`set`的简单介绍：
	- `map`：`map`类型通常被称为**关联数组。** 关联数组与“正常”数组类似，不同之处在于其**下标不必是整数**。
	- `set`：`set`就是关键字的简单集合。当只是**想知道一个值是否存在**时，`set`是最有用的

#### 使用map
- 使用关键数组`map`进行单词计数。
```c++
map<string,size_t> word_cout;//string到size_t的空map
string word;
//统计
while(cin>>word){
	++word_count[word];//提取word的计数器并加1
}
//输出
for(const auto &w:word_count)//对map中每个元素
	cout<<w.first<<"occurs"<<w,second<<((w.second>1?"times":"time")<<endl;)
```
- 关联容器也是模板，定义时必须**指定关键字和值的类型**，上例中关键字是`string`，值是`size_t`

#### 使用set
- 对[[#使用map]]中的程序进行扩展：忽略常见单词，如“the”、“and”，“or”，我们使用`set`保存想忽略单词，只对不在集合中的单词统计出现次数。
```c++
//统计输入中每个单词出现的次数,忽略常见单词
map<string,size_t> word_count;//string到size_t的空map
set<string> exclude = {"the","but","and","or"};
string word;
while(cin>>word)
	//不存在set中则添加到map	if(exclude.find(word)==exclude.end)
	++word_count[word];//获取并递增word的计数器
```
- `set`也是模板。为了定义一个`set`，必须指定其元素类型,本例中`set`是`string`类型。

## 11.2 关联容器概述
- 关联容器（有序的和无序的）都支持[[CPP#^fdecfb|普通容器操作]]。
- 关联容器不支持顺序容器的位置相关的操作，例如`push_front`或`push_back`。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。
- 除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外无序容器还提供一些用来调整哈希性能的操作。
- 关联容器的迭代器都是双向的.

### 定义关联容器
#### 初始化map和set
在新标准下，我们也可以对关联容器进行值初始化：
```c++
map<strin,size_t> word_count;//空容器
set<string> exclude={"1",'2'}
map<string,string> autors={
{"Joyce","James"},
{"HHH","heiheihei"}
};
```
- 当初始化一个`map`时，必须提供关键字类型和值类型。我们将每个关腱字一值对包围:
```c++
{key,value}
```

#### 初始化multimap或multiset
map和set中，关键字必须是唯一的。容器`multimap`和`multiset`的**关键字可以重复。**
```c++
vector<int> ivec{1,1,2,2,3,3};
//使用迭代器初始化
set<int> iset(ivec.cbegin(),ivec.cend);//包含3个元素
multiset<int> miset(ivec.cbegin(),ivec.cend);//包含六个元素
```

### 11.2.2 关键字类型的要求
- 对于**无序容器**中关键字的要求，11.4
- 对于**有序容器**——`map`、`multimap`、`set`、`multset`，关键字类型必须定义元素比较的方法。默认使用`<`

#### 有序容器的关键字类型
- 可以使用[[#10.3 定制操作|定制操作]]向算法提供一个自定义的比较操作，替换关键字上的`<`运算符。
- 所提供的操作必须在关键字类型上定义一个**严格弱序**，即是“**小于等于**”。
- 自定义比较操作的函数必须具备如下性质：
	- 两个关键字**不能同时“小于等于**”对方。
	- 比较传递性：如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。
	- “等价传递性”：如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“**等价**”的。如果k1“等价于”k2，且k2“等价于”k3，那么k1必须“等价于”k3。
- 如果两个关键字是**等价的**（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。
>[!note]
>在实际编程中，重要的是，如果一个类型定义了“行为正常”的`<`运算符，则它可以用作关键字类型。

#### 使用关键字类型的比较函数
- 为Sales_data定义一个函数，使其有一个**严格弱序**，并且提供比较运算符。
```c++
bool compareIsbn(const Sales_data &lhs,const Sales_data &rhs)
{
	return lhs.isbn()<rhs.isbn();
}
```

- 使用定制操作，创建有序容器：必须提供两个类型：
	- 关键字类型
	- 比较操作类型——一种[[CPP#函数指针|函数指针]]类型。
```c++
//bookstore中多条记录可以有相同的ISBN
//bookstore中的元素以ISBN的顺序进行排列
multiset<Sa1es_data,decltype(compareIsbn)*> bookstore(compareIsbn)；
```
>使用`decltype`来指出自定义操作的类型，根据函数类型生成函数指针。
>用`compareIsbn`来初始化`bookstore`对象，这表示当我们向`bookstore`通过调用`compareIsbn`来为这些**元素排序**。

>[!note]
>- 自定义比较操作必须提供严格**弱序**
>- 对于没有`<`操作的类自定义类，在生成有序容器时就需要自定义比较操作
>- 创建自定义比较操作的有序容器：`容器<类型,函数指针>`,，如果初始化时把比较操作函数作为参数进行初始化，那么创建额容器将按照这个操作进行排序。


### 11.2.3 pair类型
- `pair`的标准库类型：它定义在头文件utility中。
- `pair`**作用**：用来生成特定类型的模板。
- **创建**`pair`：
	- 一个`pair`保存两个数据成员，当创建一个`pair`时，我们必须提供两个类型别名，两个类型不要求一样：

- 默认初始化：
```c++
pair<string,string> annon;
pair<string,size_t> word_count;
pair<string,vector<int>> line;
```
>	`pair`的默认构造函数对数据成员进行**值初始化**。因此初始化之后anno是一个包含两个空`string`的`pair`

- 提供初始化值：以下一个`pair`两个成员被初始化为对应的值
```c++
pair<string,string> author{"hello","C++"};
```

- `pair`的数据成员：
	- `pair`的数据成员是`public`，分别命名为`first`和`second`
```c++
author.first=="hello";
author.word=="C++";
```

- `pair`的操作：
![[Pasted image 20230128162354.png]]

#### 创建pair对象的函数
- 创建一个返回一个`pair`的函数：
```c++
pair<string, int> process(vector<string> &v){
	//处理v
	if(!v.empty())
		//不为空，返回一个由v中最后一个string机器大小组成的pair
		return {v.back(),v.back.size()};//列表初始化
	else
		//构造一个空pair
		return pair<string,int>()//隐式构造返回值
}
```

## 11.3 关联容器操操作
![[Pasted image 20230128162823.png]]
![[Pasted image 20230128162837.png]]
除了上表列出的类型，关联容器还定义了以下操作：
![[Pasted image 20230128162928.png]]

- 对于`set`类型：`key_type`和`value_type`是一样的。`set`中保存的就是关键字。
- 对一个`map`类型：每个元素是`pair`对象，包含一个关键字和一个关联的值，由于关键字不能改变，所以`pair`的关键字部分是`const`的。
- 可以使用作用域孕妇桉树提取一个类型的成员。例如：`map<string,int>::key_type`

### 11.3.1 关联容器迭代器
当解引用一个关联容器迭代器时，我们会得到一个类型为容器的`value_type`的值的引用。
	- 对于`map`：`value_type`是一个`pair`类型。
	- 对于`set`：`set`的迭代器是`const`的，虽然`set`类型同时定义了`iterator`和`const_iterator`类型，但两种类型都**只允许只读访问`set`中的元素。**

```c++
auto it = word_count.begin();
it->first;//关键字，是const的不能改变
it->second;//值，可以改变

set<int> iset={1,2,3};
set<int>::iterator set_it = iset.begin();
*set_it ==1;//由于set中const是只读，所以不能赋值。
```

#### 遍历关联容器
`map`和`set`类型都支持`begin`和`end`操作。
```c++
auto map_it = word_count.cbegin();
while(map_it!=word_count.cend()){
	cout<<map_it->first<<":"<map_it->second<<endl;
	++map_it;//递增这代器，移动到下一个元素
}
```

#### 关联容器和算法
- 我们**通常不对关联容器使用泛型算法。**
**关键字是`const`** 这一特性意味着不能将关联容器传递给修改或重排容器元素的算法。

- 关联容器可**用于只读取元素的算法**。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行（快速）查找，所以**对其使用泛型搜索算法几乎总是个坏主意**。

- 在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置。例如，可以用泛型`copy`算法将元素从一个关联容器拷贝到另一个序列。

### 11.3.2 添加元素
