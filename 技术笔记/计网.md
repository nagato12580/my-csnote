# 计算机网络和因特网
121212
## 因特网的概念

因特网是一个世界范围的计算机网络，即它是一个互联了遍及全世界的数以亿计的计算设备的网络。

## 协议

### 协议的概念

一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其他事件所采取的动作。


### 协议的作用

因特网广泛使用了协议，不同协议用于完成不同的通信任务。



# 应用层

## 应用层协议原理

研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。

### 网络应用程序体系结构

现代网络应用程序中所使用的两种*主流体系结构*：
- **客户-服务器体系结构**
- **对等（P2P）体系结构**

#### 客户-服务器体系结构

![[Pasted image 20221215200323.png]]
在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请
求的情况。例如，一个流行的社交网络站点如果仅有一台服务器来处理所有请求，将很快变得不堪重负。*为此，配备大量主机的数据中心常被用于创建强大的虚拟服务器。* 最为流行的因特网服务一一洳搜索引擎（如谷歌和Bing)、因特网商务（如亚马逊和宀Bay）、基于Web的电子邮件（如Grnail和雅虎邮件）、社交网络（如脸谱和推特），就应用了一个或多个数据中心。如在1.3.3节中所讨论的那样，谷歌有分布于全世界的30、50个数据中心，这些数据中心共同处理搜索、YouTube、Gmail和其他服务。一个数据中心能够有数十万台服务器，它们必须要供电和维护。此外，服务提供商必须支付不断出现的互联和带宽费用，以发送和接收到达／来自数据中心的数据。

##### 特征
- 在客户一服务器体系结构（client-serverarchitecture)中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。例如客户主机上的浏览器和web服务器。
**利用客户-服务器体系结构，客户相互之间不直接通信；**  例如Web应用中两个浏览器并不直接通信。
- 该服务器具有固定的、周知的地址，该地址称为**IP地址**。 

##### 典型应用程序
Web FTP，Telnet，电子邮件。




#### 对等（P2P）体系结构
对数据中心的专用服务器有最小的依赖，应用程序在连接的主机中进行直接通信，这些主机称为对等方。目前最流行的、流量密集型的应用都是P2P体系结构的。例如文件共享（BitTorrent）、对等方协助下载加速器（迅雷）、因特网电话（Skype）和IPTV（迅雷看看和PPstream）。

![[Pasted image 20221215201720.png]]


##### 特征
- **自拓展性：** 在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。
>例如，像种子文件的下载与上传，下载量增加，对等方增加，系统服务能力也就增强。
- P2P体系结构也是成本有效的，通常不需要庞大的服务器基础设施和服务器带宽

##### 面临的主要挑战
- ISP友好。大多数住宅ISP（包括和电缆ISP)已经受制于“非对称的"带宽应用，也就是说，下载比上载要多得多。但是P2P视频流和文件分发应用改变了从服务器到住宅ISP的上载流量，因而给ISP带来了巨大压力。
- 安全性。因为它们的高度分布和开放特性，P应用给安全带来挑战.
- 激励。未来P2P应用的成功也取决于说服用户自愿向应用提供带宽、存储和计算资源，这对激励设计带来挑。

#### 混合体系结构
结合了客户-服务器和P2P的元素。例如，对于许多即时讯息应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间（无需通过中间服务器）直接发送。


### 进程通信

**一个进程可以被认为是运行在端系统中的一个程序。**

在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过将报文发送回去进行响应。
![[Pasted image 20221215202014.png]]

#### 客户和服务器进程

##### 客户和服务器的概念
- **客户：** 发起通信（即在该会话开始时发起与其他进程的联系）的进程。
- **服务器：** 在会话开始时等待联系的进程是服务器。

##### 进程与计算机网络之间的接口

进程通过一个称为**套接字（socket）** 的软件接口向网络发送报文和从网络接收报文。
![[Pasted image 20221215203450.png]]

**套接字** 是同一台主机内应用程序和网络之间的应用程序编程接口（API）。

>应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。

应用程序开发者对于运输层的控制仅限于：
1. 选择运输层协议；
2. 设定某些运输层参数，如最大缓存和最大报文段长度等。

#### 进程寻址
为了向特定目的地发送邮政邮件，目的地需要有一个地址。
一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。

为了表示该接收进程，需要定义两种信息：
- . **主机的地址**
>在因特网中，主机由其**IP地址**标识。

- . 定义在目的主机中的接收**进程的标识符**。
>目的主机中运行着许多进程，**端口号**用于接收进程。


### 可供应用程序使用的运输服务

运输层协议能为调用的应用程序提供的服务：
1. **可靠数据传输**。确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。
	>多媒体应用，如交谈式音频/视频，能够容忍一定量数据损失，可靠数据传输对其不是必要的。

2. **吞吐量。** 可用吞叶量就是发送进程能够向接收进程交付比特的速率。
	>其他进程共享该网络路径的带宽，可用吞吐力量将随着时间波动。
>**带宽敏感应用：** 有吞吐量要求的多媒体应用。
>**弹性应用：** 根据情况或多或少地利用可供使用地吞吐量。
3. **定时。** 对于交互式实时应用，为了有效性，对数据交付有严格地时间限制。
4. **安全性。** 运输协议能够为应用程序提供一种或多种安全性服务。例如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。


### 因特网提供地运输服务

因特网（更一般的是TCP/IP网络）为应用程序提供两个运输层协议，即**UDP和TCP**。每个协议为调用它们的应用程序提供了不同的服务集合。

某些应用程序地服务要求
![[Pasted image 20221215210715.png]]

#### TCP服务
TCP服务模型包括**面向连接服务**和**可靠数据传输服务**。
- **面向连接的服务：** 在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的握手过程提示客户和服务器，使它们为大量分组的到来做好准备。在握手阶段后，一个TCP连接（TCPconnection）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。
- **可靠的数据传送服务：** 通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。
>为了保证发送方发送的数据在中中间链路上不被发现，引入了**安全套接字层（SSL）**。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。我们强调SSL不是与TCP和UDP在相同层次上的第三种因特网运输协议，而是一种对TCP的加强，这种强化是在应用层上实现的。


#### UDP服务
UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。
- **无连接。** 在两个进程通信前没有握手过程。
- **不可靠。** 当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。
- **没有拥塞控制机制。** UDP的发送端可以用它选定的任何速率向其下层（网络层）注人数据。（然而，值得注意的是实际端到端吞吐量可能小于这种速率，这可能是因为中间链路的带宽受限或因为拥塞而造成的。）
- **到达接收进程地报文可能无序。


#### 因特网运输协议所不提供的服务
吞吐量或定时保证，即这些服务目前的因特网运输协议并没有提供。

总之，今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证。


### 应用层协议

应用层协议（application-layer protocol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是应用层协议定义了 ：
- **交换的报文类型**，例如请求报文和响应报文。
- 各种报文类型的**语法**，如报文中的各个字段及这些字段是如何描述的。
- 字段的**语义**，即这些字段中的信息的含义。
- 确定一个进程**何时以及如何发送报文**，对报文进行响应的规则。

**应用层协议只是网络应用的一部分。**
例如，Web是一种客户-服务器应用，它允许客户按照需求从Web服务器获得文档。Web的应用层协议是HTTP,它定义了在浏览器和Web服务器之间传输的报文格式和序列。因此，HTTP只是Web应用的一个*重要部分*。电子邮件的首要应用层协议SMTP也只是电子邮件应用的一个部分（尽管是重要部分）。

### 网络应用

5种重要的应用：**Web、文件传输、电子邮件、目录服务、流式视频和P2P。**


## Web与HTTP

### 基本概念
- **web页面：** 也叫文档，是由对象组成的。 
- **对象：** 文件，如一个HTML文件、一个JPEG图形、一个Java小程序或一个视频片段这样的文件,且它们可通过一个URL地址寻址。
- **URL地址:** 每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。
	>例如,URL 地址 http://www. someSchool. edu/someDepartment/picture. gif,其中的 www. someSchool. edu 就是主机名，/someDepartment/picture, gif 就是路径名
- **Web服务器：** 实现了 HTTP的服务器端，它用于存储Web对象，每个对象由URL寻址。流行的Web服务器有Apache和Microsoft Internet Information Server （微软互联网信息服务器）。

*多数Web页面含有一个HTML基本文件（base HTMfile）以及几个引用对象。*
>例如，如果一个Web页面包含HTML文本和5个JPEG图形，那么这个Web页面有6个对象：一个HTML基本文件加5个图形。HTML基本文件通过对象的URL地址引用页面中的其他对象.



### HTTP 概况
Web的应用层协议是**超文本传输协议**（HyperText Transfer Protocol, **HTTP**）,它是Web的核心。

HTTP由两个程序实现：**一个客户程序和一个服务器程序**。
客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。

HTTP定义了 Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。
![[Pasted image 20221216231048.png]]

**HTTP使用TCP作为它的支撑运输协议(而不是在UDP上运行)。** TCP为HTTP提供可靠数据传输服务。

Web服务器总是打开的，即便客户端频繁请求同一对象也会重新发送该对象。

### 非持续连接和持续链接

- **持续链接：** 每个请求/响应是经一个单独的TCP发送的。
- **非持续链接：** 每个请求/响应是经一个单独的TCP连接发送的。
>HTTP既然能采用非持续连接也能采用持续链接，默认法按时下HTTP使用持续链接，HTTP客户端和服务器应该配置成使用非持续链接。

- **往返时间（RTT）：** 短分组从客户到服务器然后再返回客户所花费的时间。包括四个部分
	- 分组传播时延
	- 分组在中间路由器和交换机上的排队时延
	- 分组处理时延

#### 采用非持续链接的HTTP

*非持续连接下。从服务器向客户端传送一个web页面的步骤：*
假设该页面有一个HTML基本文件和十个JPEG图形，并且这11个对象位于同一台服务器上。
1. HTTP客户进程在端口号80发起一个到服务器的TCP连接，该端口号是HTTP默认的端口号，分别于客户和服务器上分别由一个他奥戒指与该连接相关联。
2. HTTP客户经过它的套接字向该服务器发送一个HTTP请求报文。该报文中包含文件路径名。
3. HTTP服务器经过它的套接字接收该请求报文，从其存储器中检索出请求对象，封装在一个HTTP响应中，通过其 套接字向客户发送响应报文。
4. HTTP服务器通知TCP断开该TCP连接。（直到TCP确认客户已经完整地收到响应报文为止，它才会实际中断连接。）
5. HTTP客户接收响应报文，TCP连接关闭。客户从报文中提取出该文件。
6. 对每个JPEG应用都重复前四个步骤。
**每个TCP连接在服务器发送一个对象之后就关闭，每个TCP连接只传输一个请求报文和响应报文，上述例子中，一共要产生11个TCP连接。**


![[Pasted image 20221217150842.png]]
请求并接收一个HTML文件设计三次握手过程。
第一次握手：客户向服务器发起TCP请求。
第二次握手，服务器发给客户一个小TCP报文段做出响应和确认。
第三次握手：客户向服务器返回确认，携带HTTP请求报文。
	>一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。

三次握手中前两个部分耗费的时间占一个RTT，HTTP请求/和响应占了另有一个RTT。


#### 采用持续链接的HTTP

持续链接的**缺点：**
1. 必须为*每一个请求的对象建立和维护一个全新的连接*。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量,这给Web服务器带来了严重的负担
2. 每一个对象经受*两倍RTT的交付时延*,即一个RTT用于创建TCP,另一个RTT用于请求和接收一个对象。

- HTTP1.1的持续链接特点：
服务器在发送响应后保持TCP连接打开状态。在相同的客户和服务器之间后续的请求和响应报文能够通过相同的连接进行传送。对对象的这些请求可以一个接一个地发出，而不必等待对未决请求（流水线）的回答。

- HTTP/2持续链接的特点：
构建在HTTP1.1上，允许在相同连接中多个请求和回答交错，并增加了在该连接中优化HTTP报文请求和回答的机制。


### HTTP报文格式

HTTP报文有两种：**请求报文和响应报文。**

#### HTTP请求报文

典型HTTP请求报文
![[Pasted image 20221217152253.png]]
**分析：**
HTTP请求报文第一行叫做**请求行，** 后继的行叫做**首部行。**
**请求行：** 包含三个字段：*方法字段*、*URL字段*、*HTTP版本字段*。
	方法字段包括：GET、POST、HEAD、PUT、DELETE
**首部行：**
	host：指定对象所在主机，是web告诉代理缓存所需要的。
	connection：浏览器告诉服务器不要使用持续链接。
	user-agent：指明用户代理。
	Accept-language：表示用户向得到该对象的法语版本。（如果服务器中存在的话）。否则发送默认版本。仅是HTTP中可用的众多内容协商首部之一。


##### 通用格式
![[Pasted image 20221217153758.png]]
包含**请求行**和**首部行**，还有**实体体**
使用GET方法时实体体为空，而使用POST方法时才使用该实体体。当用户提交表单时，HTTP客户常常使用POST方法。
>使用GET实体体为空，使用POST，实体体中包含用户在表单字段中输入的值。


>HEAD方法类似于GET方法。当服务器收到一个使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。应用程序开发者常用HEAD方法进行调试跟踪。PUT方法常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径（目录）。PUT方法也被那些需要向Web服务器上传对象的应用程序使用。DELETE方法允许用户或者应用程序删除Web服务器上的对象。

*浏览器产生的首部行与很多因素有关，包括浏览器的类型和协议版本（例如，HTTP/1. 0浏览器将不会产生任何1.1版本的首部行）、浏览器的用户配置（如喜好的语言）、浏览器当前是否有一个缓存的但是可能超期的对象版本。*

#### HTTP响应报文

典型HTTP响应报文
![[Pasted image 20221217154535.png]]

**分析：**
HTTP响应报文包含**初始状态行，** 6个**首部行**，以及**实体体**。
**实体体是报文的主要部分，即它包含所请求对象本身。**
**状态行：** 包含三个字段：*协议版本字段、状态码和相应状态信息*。
**首部行：**
	connection：告诉客户，发送完报文后将关闭该TCP连接。
	Server：指示该报文是由一台Apache Web服务器产生的，它类似于HTTP请求报文中的User-agent:首部行。
	Date：首部行指示服务器产生并发送该响应报文的日期和时间。时间是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间。
	Last-Modified:首部行指示了对象创建或者最后修改的日期和时间。**对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要。**
	ContentLength： 首部行指示了被发送对象中的字节数。
	Content-Type:首部行指示了实体体中的对象是HTML文本。
	

##### 通用格式
![[Pasted image 20221217155336.png]]
包含**初始状态行，** **首部行**，以及**实体体**。

>状态码相关：
>200 0K：请求成功，信息在返回的响应报文中。
 301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location:首部行中。客户软件将自动获取新的URL。
 400 Bad Request: 一个通用差错代码，指示该请求不能被服务器理解。
404 Not Found:被请求的文档不在服务器上。
505 HTTP Version Not Supported:服务器不支持请求报文使用的HTTP协议版本。

*产品、版本和配置上的差异，都会影响响应报文中包含的首部行。*


### 用户与服务器的交互：cookie

**HTTP服务器是无状态的**，简化了服务器的设计。然而一个站点通常希望能够识别用户，因此引入了cookie，**cookie允许站点对用户进行跟踪。**

#### cookie的四个组件

1. 在HTTP**响应**报文中的一个**cookie首部行**；
2. 在HTTP**请求**报文中的一个**cookie首部行**；
3. 在**用户端**系统中保留有一个**cookie文件**，并由用户的浏览器进行管理；
4. 位于**Web站点**的一个**后端数据库**。

#### cookie工作过程
![[Pasted image 20221217160220.png]]
1. 在客户第一次访问web站点的时候，服务器会位该客户生成唯一的标识码，将其携带在响应报文中的首部行返回，并且存放到后端数据库中。
2. 客户获取到服务器的响应后，提取其中的cookie标识码，与该站点的主机名一起保存在本地cookie文件中。
3. 当客户再次发起请求该主机时，浏览器将查询本地cookie文件是否有该主机的标识码，有则放到请求报文首部行中。
4. 主机接收到客户端的请求报文之后，查找是否存在标识码，不存在则生成，存在则在后端数据库中保存该标识码客户访问的活动记录。


### Web缓存

Web缓存器（Web cache）也叫**代理服务器（proxy server）**,它*是能够代表初始Web服务器来满足HTTP请求的网络实体。* Web缓存器有自己的磁盘存储空间,
并在存储空间中**保存**最近请求过的**对象的副本**。

可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web缓存器。

#### 客户通过web缓存器请求过程
![[Pasted image 20221217161637.png]]
1. 在配置Web服务器之，浏览器会创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。
2. Web缓存器进行检查，如果本地存储了该对象副本，Web缓存器就向客户浏览器用HTTP响应报文返回给对象。
3. 如果Web缓存器中没有该对象，它就打开一个与该对象初始服务器的TCP连接。Web服务器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求，在收到请求之后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。
4.  当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本（通过现有的客户浏览器和Web缓存器之间的TCP连接）
**Web缓存器既是服务器又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户**
>Web缓存器通常由ISP购买并安装。

#### 引入Web缓存的意义

- Web缓存器可以**大大减少对客户请求的响应时间，** 特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。
- 能够大大**减少**一个机构的接入链路到**因特网的通信量**。

### 条件GET方法

**Web缓存器存在的问题**：放在缓存器中的对象副本可能是比较旧的。
**解决方法：** 使用条件GET（conditional GET）方法保持缓存器中的副本是最新的。

-  **条件GET方法的构成。**
1. 请求报文使用GET方法。
2. 请求报文中包含一个“If Modified-Since： ”首部行。

**原理：** If Modified-Since首部行包含该对象最后修改的时间，通过保存该时间，在下一次客户请求该对象的时候，Web缓存器携带该时间（在首部行中）去服务器请求对象，服务器对比最后修改时间，如果在这个时间之后被修改过则在响应报文中包含被修改过的新对象，如果每被求该国则发送一个空的响应报文，告诉Web缓存该对象没有被修改。



## 因特网中的电子邮件
![[Pasted image 20221222211406.png]]

**邮件发送过程概述：** 从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。
>用户代理：理允许用户阅读、回复、转发、保存和撰写报文。例如微软的Outlook和Google Mail

### SMTP
**作用：** 用于从发送方的邮件服务器发送报文到接收方的邮件服务器。

**SMTP基本操作：** 
1. 用户Alice调用邮件代理，并且提供用户Bob的邮件地址，然后撰写报文，指示用户代理发送该报文。
2. Alice的用户代理把报文发给她的邮件服务器，在哪里该报文被放在报文队列中。
3. 运行在Alice的邮件服务器上的STMP客户端端发现了报文队列中的这个报文，它就创建一个到运行在Bob的邮件服务器上的SMTP服务器的**TCP连接**。
4. 在经过一些初始SMTP握手后，SMTP客户通过该TCP连接发送Alice的报文。
5. 在Bob的邮件服务器上，SMTP的服务器端接收该报文。Bob的邮件服务器然后将该报文放入Bob的邮箱中。
![[Pasted image 20221222212421.png]]
**SMTP一般不使用中间邮件服务器发送邮件**

#### SMTP客户和SMTP服务器TCP建立后交换文本的例子
![[Pasted image 20221222213302.png]]
>其中，客户主机名为crepes.fr
>服务器主机名为hamburger.edu
>以C：开头的ASCII码文本行正是客户交给其TCP套接字的那些行，以S：开头的ASCII码则是服务器发送给其TCP套接字的那些行。

**SMTP用的是持续连接：** 如果发送邮件服务器有几个报文发往同一个接收邮件服务器，它可以通过同一个TCP连接发送这些所有的报文。

### SMTP与HTTP的对比
**相同：** 
- 都用于从一台主机向另一台主机传送文件。
	>HTTP从Web服务器向Web客户(通常是浏览器)。
	>SMTP从一个邮件服务器向另一个邮件服务器传送文
- 持续的HTTP和SMTP都使用持续TCP链接。

**区别1：** 
+ HTTP是一个**拉协议。** 用户使用HTTP从Web服务器拉取信息。
+ SMTP是一个**推协议**。即发送邮件服务器把文件推向接收邮件服务器。特别是，这个TCP连接是由要发送该文件的机器发起的。

**区别2：** 
- SMTP要求每个报文采用**7比特ASCII码格式**。含有非7比特的ASCII字符则必须按照7比特ASCII码进行编码。
- HTTP不受字符编码格式的束缚。

**区别3：** 
+ SMTP把包括图片又包含文本的文档法放在同一个报文中。
+ HTTP把每个对象封装在自己的HTTP响应报文中。


### 邮件报文格式
- From：首部行，**必须有**，指明发送方的邮箱地址。
- To：首部行，首部行，**必须有**，指明接收方的邮箱地址。
- Subject：首部行，可选。
*也可以包含其他首部行。*


### 邮件访问协议

**邮件服务器通常由ISP进行维护，其他用户共享。**
![[Pasted image 20221222221124.png]]
Alice首先发送邮件到Alice的邮件服务器存储，然后邮件服务器重复尝试向Bob的邮件服务器发送该报文，直到Bob的邮件服务器变得运行为止。
>为何Alice的用户代理不直接向Bob的服务器发邮件？
>Alice的用户代理将没有任何办法到达一个不可达的目的地接收服务器。

**由于取报文是用户自主点击是拉操作，所以Bob没办法使用STMP向Bob的邮件服务器获取报文。于是采用邮件访问协议来获取邮件。**

**邮件访问协议：** 包括第三版的邮局协议(POP3),因特网邮件访问协(IMAP),以及HTTP。
**邮件访问协议的作用:** 用来将邮件从接收方的邮件服务器传送到接收方的用户代理。

#### POP3



