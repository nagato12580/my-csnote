# 数组
## 移除元素
### 原题
[leetcode.27 移除元素](https://leetcode.cn/problems/remove-element/) #双指针 #暴力 
![[Pasted image 20221216214012.png]]
### 思路
**思路：** 双指针、暴力。
- **双指针法** 
定义两个快慢指针，分别指向数组中的元素，慢指针代表新数组中的下标，筷子真代表原数组的下标。每次在遇到是新数组元素中的值域的时候慢指针就+，在语到不是新数组中的值的时候慢指针保持不变，等待下次更新该位置的值。

### 代码
1. 双指针法
```c++
//双指针法
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowly=0;
        for(int fast=0;fast<nums.size();fast++){
            if(nums[fast]!=val){
                nums[slowly++]=nums[fast];
            }
        }
        return slowly;
    }

};
```


## 977.有序数组的平方
### 原题
[leetcode.977 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/) 
![[Pasted image 20221216215103.png]]

### 思路
**双指针法** 
因为要按需输出，原先数组也是排好序的，平方之后大值肯定是在两端，所以定义两个指针分别指向两端，比较两个指针指向的数的平方，大的就放到新数组末尾，然后该指针移动，直到两个指针交叉为止。

### 代码
1. 双指针法
```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int slow=0,fast=nums.size()-1;
        vector<int> newArray(nums.size(),0); 
        int i=nums.size()-1;
        while(slow<=fast){
            if(nums[slow]*nums[slow]<=nums[fast]*nums[fast]){
                newArray[i--]=nums[fast]*nums[fast];
                --fast;
            }
            else{

                newArray[i--]=nums[slow]*nums[slow];
                ++slow;
            }
        }
        return newArray;
    }
};
```

## 414.第三大的数
### 原题
 [414. 第三大的数](https://leetcode.cn/problems/third-maximum-number/)
![[Pasted image 20230129110102.png]]

### 思路
1. 利用标准库函数`sort()`和`unique()`实现。`sort()`将数组中的元素进行排序。`unique()`去除重复元素，返回一个返指向不重复值范围末尾的迭代器。再创建一个新数组进行保存不重复元素。
	- 时间复杂度：`sort()`的时间复杂度是`nlogn`，`unique()`的时间复杂度是n
	- 空间复杂度：因为开辟了新的空间保存不重复数组，所以空间复杂度是n

2. 阿秀刷题中的解法：
开辟三个空间保存最大的三个数，遍历数组把最大的元素放在第一个数，第二大放在第二个位置，第三大放在最后一个位置，在插入的过程中保持这**三个数是逆序的**。



### 代码
1. 我自己写的 
```c++
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        sort(nums.rbegin(),nums.rend());
        auto unique_iter = unique(nums.begin(),nums.end());
        vector<int> nums_unique(nums.begin(),unique_iter);
        if(nums_unique.size()>=3)
            return nums[2];
        else
            return nums[0];
    }
};
```

2. 阿秀写法：
```c++
class Solution {
public:
 int thirdMax(vector<int>& nums) {
	 //这三个数将逆序保存数组中不同的三个最大元素
    long long  firstNum = LONG_MIN,secondNum = LONG_MIN,thirdNum = LONG_MIN;
    for (auto& a : nums) {
        if (firstNum < a) { 
	        //放置最大的元素，舍弃第三大元素
            thirdNum = secondNum;
            secondNum = firstNum;
            firstNum = a; 
        }
        else if (firstNum > a && secondNum < a) { 
	        //放置第二大的元素，舍弃第三大元素
            thirdNum = secondNum;
            secondNum = a; 
        }
        //放置第三大元素，判断条件是当前数比第二个小，但是比第三个大
       else if (secondNum > a && thirdNum<a ) { 
            thirdNum = a; 
        }
    }
//在遍历过程中重复元素不会被排序，因此如果第三个大的数存在的话则返回，不存在则返回最大的数。
    if (thirdNum == LONG_MIN)
        return firstNum;
    else
        return thirdNum;
    }
};
```

## 581. 最短无需连续子数组

### 原题
[581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)
![[Pasted image 20230129115258.png]]

### 思路
1. 从左到右遍历元素，记录前面的最大值，如果是升序，那么当前值会大于前面子数组的最大值，如果当前值小于前面子数组的最大值，则说明是逆序，记录下标。从左到右遍历，最后记录的值是该逆序序列最后的下标。
2. 从右往左遍历元素，记录后面的最大值，如果是升序，那么当前值会小于后面子数组的最小数，如果当前值大于后面子数组的最小值，则说明是逆序，记录下标。从右到左遍历，最后记录的值是该逆序序列最开始的下标。
- 时间复杂度$O(n)$

### 代码
```c++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int len = nums.size(),Max = nums[0],Min = nums[len-1];
        int low=0,hight=len-1;
        if(len==1) return 0;
        for(int i=1;i<len;++i){
            Max=max(Max,nums[i]);
            if(nums[i]<Max){
                low=i;
            }
        }
        for(int i=len-1;i>=0;--i){
            Min=min(Min,nums[i]);
            if(nums[i]>Min){
                hight=i;
            }
        }
        if(low>hight){
            return low-hight+1;
        }
        else
            return 0;
    }
};
```

## 题目

### 原题

### 思路

### 代码
